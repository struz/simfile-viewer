{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/assets/noteskins/USWCelETT/_Down_Tap_Note_16x8.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_Body_Active.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_Body_Inactive.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_BottomCap_active.png","webpack:///./src/components/Screen.vue?5b13","webpack:///./src/assets/noteskins/USWCelETT/Down_Roll_BottomCap_Inactive.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_BottomCap_inactive.png","webpack:///./src/assets/noteskins/common/Fallback_Tap_Mine_8x1.png","webpack:///./src/assets/noteskins/USWCelETT/_Down_Receptor_Go_4x1.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Roll_Body_Inactive.png","webpack:///./src/plugins/vuetify.ts","webpack:///./src/App.vue?c9b7","webpack:///./src/lib/entities/EntitiesConstants.ts","webpack:///./src/components/Screen.vue?bde3","webpack:///./src/lib/PlayerNumber.ts","webpack:///./src/lib/ResourceManager.ts","webpack:///./src/lib/entities/EntityManager.ts","webpack:///./src/lib/entities/Entity.ts","webpack:///./src/lib/entities/GameSprite.ts","webpack:///./src/lib/entities/AnimatedGameSprite.ts","webpack:///./src/lib/entities/TapNoteReceptorSprite.ts","webpack:///./src/lib/NoteTypes.ts","webpack:///./src/lib/TimingSegments.ts","webpack:///./src/lib/TimingData.ts","webpack:///./src/lib/GameTimer.ts","webpack:///./src/lib/GameConstantsAndTypes.ts","webpack:///./src/lib/SongSound.ts","webpack:///./src/lib/GameSoundManager.ts","webpack:///./src/lib/Debug.ts","webpack:///./src/lib/SongPosition.ts","webpack:///./src/lib/PlayerState.ts","webpack:///./src/lib/Error.ts","webpack:///./src/lib/GameState.ts","webpack:///./src/lib/ArrowEffects.ts","webpack:///./src/lib/entities/TapNoteSprite.ts","webpack:///./src/lib/entities/TapMineSprite.ts","webpack:///./src/lib/entities/BodyAndCapNote.ts","webpack:///./src/lib/entities/HoldTailSprite.ts","webpack:///./src/lib/entities/RollTailSprite.ts","webpack:///./src/lib/entities/NoteField.ts","webpack:///./src/lib/ScreenManager.ts","webpack:///./src/components/Screen.vue?08f1","webpack:///./src/components/Screen.vue?9bde","webpack:///./src/components/Screen.vue","webpack:///./src/components/ChartPicker.vue?2d86","webpack:///./src/components/ChartPicker.vue?33d0","webpack:///./src/components/ChartPicker.vue?16f8","webpack:///./src/components/ChartPicker.vue","webpack:///./src/lib/NoteData.ts","webpack:///./src/lib/RhythmAssist.ts","webpack:///./src/lib/GameLoop.ts","webpack:///./src/lib/Steps.ts","webpack:///./src/lib/MsdFile.ts","webpack:///./src/lib/NoteDataUtil.ts","webpack:///./src/lib/Song.ts","webpack:///./src/lib/NoteLoaderSM.ts","webpack:///./src/lib/FileOperations.ts","webpack:///./src/App.vue?5dd0","webpack:///./src/App.vue?aea5","webpack:///./src/App.vue","webpack:///./src/main.ts","webpack:///./src/assets/sounds/assist_clap.ogg"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","app","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Screen_vue_vue_type_style_index_0_id_5f8721bc_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Screen_vue_vue_type_style_index_0_id_5f8721bc_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default","vue_runtime_esm","use","lib","iconfont","TapNoteDirection","Appvue_type_template_id_50d27166_render","_vm","this","_h","$createElement","_c","_self","attrs","dark","staticClass","_v","flat","href","target","row","md6","on","changeChart","click","playPauseTrack","seekTrack","type","model","callback","$$v","seek","_n","expression","staticRenderFns","Screenvue_type_template_id_5f8721bc_scoped_true_render","ref","_t","Screenvue_type_template_id_5f8721bc_scoped_true_staticRenderFns","TAPNOTE_WIDTH_PX","TAPNOTE_HEIGHT_PX","HOLD_BOTTOM_CAP_HEIGHT_PX","directionToLaneIndex","direction","DOWN","LEFT","UP","RIGHT","Error","concat","laneIndexToDirection","laneIndex","PlayerNumber","LANE_MARGIN","DOWN_TAP_NOTE_SHEET_NAME","DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME","TAP_MINE_SHEET_NAME","DOWN_HOLD_BODY_ACTIVE_SHEET_NAME","DOWN_HOLD_BODY_INACTIVE_SHEET_NAME","DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME","DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME","DOWN_ROLL_BODY_INACTIVE_SHEET_NAME","DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME","SPRITE_DEFINITIONS","textureUrl","_Down_Tap_Note_16x8_default","a","width","height","numSprites","numAnimFrames","animLength","animLoop","_Down_Receptor_Go_4x1_default","Fallback_Tap_Mine_8x1_default","Down_Hold_Body_Active_default","Down_Hold_Body_Inactive_default","Down_Hold_BottomCap_active_default","Down_Hold_BottomCap_inactive_default","Down_Roll_Body_Inactive_default","Down_Roll_BottomCap_Inactive_default","ResourceManager_ResourceManager","ResourceManager","classCallCheck","spriteInfo","map_default","doneLoading","spriteTextures","undefined","loader","lib_ScreenManager","getPixiApp","_i","_SPRITE_DEFINITIONS","add","load","onLoad","_i2","_SPRITE_DEFINITIONS2","extractTexturesFromSpriteSheet","sprite","spriteTexture","resources","texture","sprites","spriteAnimTextures","f","rectangle","pixi_es","spriteFrame","baseTexture","set","textures","instance","RESOURCEMAN","getInstance","lib_ResourceManager","EntityManager_EntityManager","EntityManager","entities","createClass","entity","deltaTime","forEach","update","ENTITYMAN","entities_EntityManager","Entity_Entity","Entity","registerEntity","deregisterEntity","entities_Entity","GameSprite_GameSprite","GameSprite","_this","possibleConstructorReturn","getPrototypeOf","onStage","zIndex","anchor","x","y","isDoneLoading","removeFromStage","stage","addChild","removeChild","z","entities_GameSprite","AnimatedGameSprite_AnimatedGameSprite","AnimatedGameSprite","spriteIndex","arguments","animationSpeed","loop","entities_AnimatedGameSprite","RECEPTOR_MARGIN_TOP_PX","TapNoteReceptorSprite_TapNoteReceptorSprite","TapNoteReceptorSprite","checkDependencies","getSpriteInfo","alpha","rotation","Math","PI","play","entities_TapNoteReceptorSprite","NUM","TapNoteType","TapNoteSubType","TapNoteSource","PLAYER_INVALID","Invalid","NoteTypes_TapNoteResult","TapNoteResult","NoteTypes_HoldNoteResult","HoldNoteResult","NoteType","NoteTypes_TapNote","TapNote","Empty","subType","source","Original","pn","occursAtSecond","endSecond","highestSubtypeOnRow","Hold","duration","holdResult","other","assign_default","create_default","get_prototype_of_default","Fake","console","debug","tapNote","NoteTypes_NoteHelpers","NoteHelpers","beatNum","round","ROWS_PER_BEAT","trunc","start","newLength","position","nt","N_4TH","N_8TH","N_12TH","N_16TH","N_24TH","N_32ND","N_48TH","N_64TH","N_192ND","ROWS_PER_MEASURE","beat","getNoteType","beatToNoteRow","NoteTypes","MAX_NOTE_ROW","TimingSegmentType","SegmentEffectType","BEATS_PER_MEASURE","NoteTypes_TapNotes","TapNotes","EMPTY","copy","ORIGINAL_TAP","ORIGINAL_LIFT","ORIGINAL_HOLD_HEAD","ORIGINAL_ROLL_HEAD","ORIGINAL_MINE","ORIGINAL_ATTACK","ORIGINAL_AUTO_KEYSOUND","ORIGINAL_FAKE","ADDITION_TAP","ADDITION_MINE","Tap","Lift","HoldHead","Roll","Mine","Attack","AutoKeysound","Addition","ROW_INVALID","TimingSegments_TimingSegment","TimingSegment","beatOrRow","isRow","startRow","setRow","scalePosition","getRow","noteRowToBeat","dec","getBeat","toString","num1","num2","abs","EPSILON","TimingSegments_WarpSegment","_TimingSegment","WarpSegment","lengthRowsOrBeats","isRows","lengthRows","inherits","WARP","Range","getLengthBeats","rows","beats","startBeat","endBeat","getLength","newStartBeat","newEndBeat","setLengthBeats","getType","getLengthRows","lengthBeats","toFixed","compareFloat","TimingSegments_TickcountSegment","_TimingSegment2","TickcountSegment","_this2","ticks","DEFAULT_TICK_COUNT","ticksPerBeat","TICKCOUNT","Indefinite","getTicks","FoundEventType","TimingSegments_TimeSignatureSegment","_TimingSegment3","TimeSignatureSegment","_this3","numerator","denominator","TIME_SIG","num","den","getNum","getDen","TimingSegments_BPMSegment","_TimingSegment4","BPMSegment","_this4","bpm","bps","setBpm","BPM","getBpm","TimingSegments_StopSegment","_TimingSegment5","StopSegment","_this5","seconds","STOP","Row","pause","getPause","TimingSegments_DelaySegment","_TimingSegment6","DelaySegment","_this6","DELAY","INVALID_INDEX","DummySegments","TimingData_GetBeatArgs","GetBeatArgs","elapsedTime","bpsOut","warpDestOut","warpBeginOut","freezeOut","delayOut","TimingData_GetBeatStarts","GetBeatStarts","warp","stop","delay","lastRow","lastTime","warpDestination","isWarping","TimingData_TimingData","TimingData","beatStartLookup","timeStartLookup","beat0OffsetInSecs","timingSegments","args","maxSegment","segs","bpms","warps","stops","delays","curSegment","getBpmAtRow","eventRow","max_safe_integer_default","eventType","NOT_FOUND","findEvent","timeToNextEvent","nextEventTime","WARP_DESTINATION","BPM_CHANGE","getBps","STOP_DELAY","delaySeg","stopSeg","warpSeg","warpSum","Number","MAX_VALUE","findMarker","MARKER","releaseLookup","segmentsPerLookup","totalSegments","beatStart","getBeatInternal","timeStart","getElapsedTimeInternal","index","lookup","lit","item","starts","bpmInfo","segInfoStr","warpInfo","stopInfo","delayInfo","str","dumpOneLookupTable","tst","noteRow","segments","getTimingSegments","retSegment","getSegmentIndexAtRow","seg","getEffectType","_retSegment","getSegmentAtRow","getBpmSegmentAtRow","getStopSegmentAtRow","getDelaySegmentAtRow","beatRow","getStopAtRow","getDelayAtRow","isWarpAtRow","isFakeAtRow","isJudgableAtRow","amount","setOffset","offset","cur","isNotable","onSameRow","prev","next","equals","findIndex","ts","lessThan","cpy","measureIndexOut","beatIndexOut","rowsRemainder","tSigs","curSig","segmentEndRow","rowsPerMeasureThisSegment","getNoteRowsPerMeasure","rowsPerBeatThisSegment","getNoteRowsPerBeat","numRowsThisSegment","numMeasuresThisSegment","_numRowsThisSegment","_numMeasuresThisSegment","min","max","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","get_iterator_default","done","err","return","getNextSegmentBeatAtRow","backup","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","getPreviousSegmentBeatAtRow","getBeatAndBpsFromElapsedTime","second","getBeatFromElapsedTime","lookedUpStart","findEntryInLookup","getElapsedTimeFromBeatNoOffset","getBeatAndBpsFromElapsedTimeNoOffset","songBeat","musicSeconds","speeds","SPEED","allowEmpty","empty","warn","addSegment","entry","lower","upper","lookupItem","status","tmpRow","lib_TimingData","TIMESTAMP_RESOLUTION","NANOSECONDS_PER_MICROSECOND","GameTimer_GameTimer","GameTimer","secs","us","touch","now","subtract","time","getTime","diff","difference","ago","probableDelay","tm","sum","rhs","browser_process_hrtime_default","initTimeSecs","initTimeUs","deltaSecs","deltaUs","lhs","ret","StepsTypeCategory","StepsType","lib_GameTimer","gZeroTimer","EXPECTED_FPS","Difficulty","GameConstantsAndTypes_StepsTypeInfo","StepsTypeInfo","stepTypeName","numTracks","allowAutogen","stepsTypeCategory","StepsTypeInfos","Single","Double","Couple","Routine","OldStyleStringToDifficultyMap","Beginner","Easy","Medium","Hard","Challenge","Edit","GameConstantsAndTypes_Helpers","Helpers","stepsType","st","oldDifficulty","difficulty","toLowerCase","HHMMSS","arrayBits","split","stringToInt","stringToFloat","gameEnum","iterator","keys","keys_default","map","k","int","parse_int_default","isNaN","float","parse_float_default","h","l1","h1","l2","h2","lerp","GameConstantsAndTypes","SongSound_SongSound","SongSound","sound","at","timeElapsed","lib_SongSound","MAX_TOLERATED_DRIFT_SECS","DRIFT_SECS_BEFORE_UPDATE","GameSoundManager_MusicPlaying","MusicPlaying","music","timing","hasTiming","applyMusicRate","GameSoundManager_MusicToPlay","MusicToPlay","startSeconds","lengthSeconds","fadeInLengthSeconds","fadeOutLengthSeconds","forceLoop","alignBeat","GameSoundManager_GameSoundManager","GameSoundManager","updatingTimer","beatLastCrossed","outOfSyncSecs","musicPlaying","seekTimeSeconds","currentTimeSeconds","getTimeElapsed","toPlay","state","newMusic","getSound","playbackRate","lib_GameState","curSong","updateSongPosition","songTiming","rowNow","beatToNoteRowNotRounded","beatNow","resyncSongTimingWithMusicPosition","updateIfMusicNotPlaying","playing","musicPlayingPosSeconds","drift","log","SOUNDMAN","lib_GameSoundManager","DEBUG_ASSERT","cond","trace","ASSERT","message","Debug_DebugTools","DebugTools","pauseMusic","resumeMusic","numFrames","timeAdvanceSeconds","musicSkipforwards","getMusicTimeSeconds","getMusicTiming","SongPosition_SongPosition","SongPosition","songBeatNoOffset","curBps","freeze","warpBeginRow","lastBeatUpdate","musicSecondsVisible","songBeatVisible","positionSeconds","timestamp","isZero","beatInfo","getBeatFromElapsedTimeNoOffset","lib_SongPosition","PlayerState_PlayerState","PlayerState","playerNumber","PLAYER_1","readBPM","delta","isUsingStepTiming","steps","curSteps","timingData","Error_NotImplementedError","_Error","NotImplementedError","wrapNativeSuper","GameState_GameState","GameState","lastPositionTimer","lastPositionSeconds","paused","playerState","forEachEnum","hasteRate","reset","newSong","resetMusicStatistics","setCurSong","prepareLookup","handleSongTimer","isHandlingSongTimer","setBgmTime","timeNoOffset","beatNoOffset","currentBgmTime","currentBgmBeat","currentBgmTimeNoOffset","currentBgmBeatNoOffset","currentBgmBeatPlayer","currentBgmBeatPlayerNoOffset","setPlayerBgmBeat","GAMESTATE","songData","songMusic","loadNextSong","startMusic","ARROW_SPACING","ArrowEffects_ArrowEffects","noteBeat","peakYOffsetOut","isPastPeakOut","yOffset","getSteps","timeSpacing","ArrowEffects","getDisplayedBeat","getDisplayedSpeedPercent","songSeconds","noteSeconds","getElapsedTimeFromBeat","secondsUntilStep","scrollBpm","yOffsetTimeSpacing","scrollSpeed","maxScrollBpm","readBpm","displayedBeatCache","displayedBeat","velocity","noteStatCache","speedScrollSpeed","speedScrollBpm","lib_ArrowEffects","TapNoteSprite_TapNoteSprite","TapNoteSprite","noteType","beatToNoteType","setYPosBasedOnBeat","peakYOffset","getYOffset","entities_TapNoteSprite","TapMineSprite_TapMineSprite","TapMineSprite","entities_TapMineSprite","BodyAndCapNote_BodyAndCapNote","BodyAndCapNote","bodySpriteInfo","capSpriteInfo","calculateLongNoteHeight","firstBodySegmentTexStartY","firstBodySegmentTexHeight","bodyTilingSprite","remainingHeight","segmentHeight","bodySegmentTex","bodySegmentSprite","bodySpriteTex","bodySprite","bottomCapSprite","laneX","gs","getSprite","updateSprites","addToStage","headYPos","capYPos","tilingPosY","setPosY","entities_BodyAndCapNote","HoldTailSprite_HoldTailSprite","HoldTailSprite","entities_HoldTailSprite","RollTailSprite_RollTailSprite","RollTailSprite","entities_RollTailSprite","NoteField_NoteTrackData","NoteTrackData","tapNotes","holdCaps","NoteField_NoteField","NoteField","noteTracks","resetTracks","track","tn","destroy","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_tn","drawDistanceAfterTargetsPixels","low","high","hasCache","NUM_ITERATIONS","MAX_NOTES_AFTER","firstBeatToDraw","mid","isPastPeakYOffset","getNumNotesRange","drawDistanceBeforeTargetsPixels","displayedPosition","displayedTiming","searchDistance","lastBeatToDraw","speedMultiplier","notesLower","notesUpper","noteStatLow","getNumNotesFromBeginning","noteStatHigh","PIXELS_TO_DRAW_OFFSCREEN","findFirstDisplayedBeat","findLastDisplayedBeat","firstRow","nd","getNoteData","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tnEntry","has","tnSprite","tailSprite","setZIndex","toDestroy","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","tnsEntry","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_tnsEntry","tnsAndTrackEntry","delete","updateNotes","entities_NoteField","ScreenManager_ScreenManager","ScreenManager","pixiApp","receptorsVisible","receptorSprites","options","view","renderCanvas","backgroundColor","loadSprites","ticker","maxFPS","desiredFps","isInit","color","renderer","initOrder","_initOrder","receptor","visible","noteField","SCREENMAN","Screenvue_type_script_lang_ts_Screen","_Vue","Screen","$refs","offsetWidth","offsetHeight","initPixi","tslib_es6","vue_property_decorator","Screenvue_type_script_lang_ts_","components_Screenvue_type_script_lang_ts_","component","componentNormalizer","components_Screen","ChartPickervue_type_template_id_65bde944_scoped_true_render","items","packs","item-text","item-value","label","change","$event","changePackEvent","selectedPack","charts","changeChartEvent","selectedChart","ChartPickervue_type_template_id_65bde944_scoped_true_staticRenderFns","PACK_INDEX_FILENAME","NODE_ENV","BASE_URL","VUE_APP_PACK_INDEX_FILENAME","DEFAULT_SELECTED_CHART","oggFilename","simFilename","ChartPickervue_type_script_lang_ts_ChartPicker","ChartPicker","axios_default","then","response","pack","unshift","catch","error","foundPack","find","foundChart","chart","event","findPack","packName","findChart","ogg","simFile","urls","$emit","ChartPickervue_type_script_lang_ts_","components_ChartPickervue_type_script_lang_ts_","ChartPicker_component","components_ChartPicker","installComponents_default","VSelect","IteratorDirection","NoteData_TrackMap","TrackMap","mapReverse","size","isSorted","proxy","startAt","endAt","sort","NoteData_TrackMapIterator","Forwards","values","iterator_default","Backwards","sortedEntriesAsc","toConsumableArray","entries","sortNumbersAsc","sortedEntriesDesc","reverse","mapProps","get_own_property_names_default","prop","skipOverride","indexOf","mapFunc","reverseMapFunc","wrapFunc","retVal","b","TrackMapIterator","it","end","compare","lastNextResult","value1","value2","FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE","last","fn","getNextTapNoteRowForAllTracks","NoteData_NoteData","NoteData","loaded","noteCounts","holdDurations","newNumTracks","trackMap","newEmpty","endRow","constIterator","rowInAndOut","ignoreAutoKeysounds","mapTrack","iter","closestNextRow","anyHaveNextNote","getNumTracks","newRowThisTrack","getNextTapNoteRowForTrack","reverseEntries","closestPrevRow","anyHavePrevNote","getPrevTapNoteRowForTrack","dest","src","rowBegin","rowEnd","clear","headRow","rowPbr","getTapNote","getFirstTrackWithTap","getFirstTrackWithTapOrHoldHead","lib_NoteData","RhythmAssist_RhythmAssist","RhythmAssist","metronome","clap","song","songRow","rowLastCrossed","clapRow","isThereATapOrHoldHeadAtRow","tickBeat","tickSecond","clapSound","lastCrossedMeasureIndex","lastCrossedBeatIndex","lastCrossedRowsRemainder","noteRowToMeasureAndBeat","currentMeasureIndex","currentBeatIndex","currentRowsRemainder","metronomeRow","changedMeasure","_tickBeat","_tickSecond","howler","assist_clap_default","volume","lib_RhythmAssist","gGameplayTimer","GameLoop_GameLoop","outsideDeltaTime","GameLoop","drawnFrames","getDeltaTime","totalTime","playTicks","isReadyToDraw","drawnArrow","showReceptors","DisplayBPM","lib_GameLoop","MsdFile_MsdFile","MsdFile","readBuffer","valueIndex","paramIndex","buf","unescape","readingValue","currentParam","addValue","addParam","param","join","trim","lib_MsdFile","NoteDataUtil_NoteDataUtil","NoteDataUtil","out","smNoteData_","smNoteData","indexCommentStart","indexCommentEnd","substr","clearAll","setNumTracks","loadFromSmNoteDataStringWithPlayer","emptyFilter","measures","filter","measureIndex","measure","measureLines","lineIndex","line","percentIntoMeasure","trackIndex","noteChar","charAt","parseTapNoteData","setTapNote","_step$value","slicedToArray","_beat","removeTapNote","newOriginalTap","newOriginalHoldHead","newOriginalRollHead","isHoldNoteAtRow","holdNote","findTapNote","newOriginalMine","newOriginalAutoKeysound","newOriginalLift","newOriginalFake","Steps_Steps","Steps","noteData","stepsTypeName","description","chartStyle","meter","credit","chartName","displayBPMType","ACTUAL","specifiedBpmMin","specifiedBpmMax","noteDataIsFilled","noteDataCompressed","getStepsTypeInfo","loadFromSmNoteDataString","stepsTypeString","lib_Steps","Song_Song","Song","fileName","groupName","mainTitle","subTitle","artist","mainTitleTranslit","subTitleTranslit","artistTranslit","version","genre","origin","musicLengthSec","musicSampleStartSec","musicSampleLengthSec","displayBpmType","firstSecond","lastSecond","specifiedLastSecond","unknownStyleSteps","stepsByType","tidyUpData","lib_Song","FAST_BPM_WARP","SMSetTitle","info","params","SMSetSubtitle","SMSetArtist","SMSetTitleTranslit","SMSetSubtitleTranslit","SMSetArtistTranslit","SMSetGenre","SMSetCredit","SMSetBanner","SMSetBackground","SMSetLyricsPath","SMSetCDTitle","SMSetMusic","SMSetOffset","SMSetBPMs","bpmChanges","NoteLoaderSM_NoteLoaderSM","parseBpms","SMSetStops","parseStops","SMSetDelays","processDelays","SMSetTimeSignatures","processTimeSignatures","SMSetTickCounts","processTickcounts","SMSetInstrumentTrack","SMSetSampleStart","HHMMSSToSeconds","SMSetSampleLength","SMSetDisplayBPM","RANDOM","SPECIFIED","SMSetSelectable","SMSetBGChanges","SMSetFGChanges","SMSetKeysounds","SMSetAttacks","songTagHandlers","NoteLoaderSM","rowsPerBeat","replace","stringToStepsType","oldStyleStringToDifficulty","songBpmInfo","bpmChangeExpressions","arrayBpmChangeValues","rowToBeat","newBpm","songStopInfo","arrayFreezeExpressions","arrayFreezeValues","freezeBeat","freezeSeconds","arrayDelayExpressions","arrayDelayValues","vs1","s1","vs2","arrayTickcountExpressions","arrayTickcountValues","tickcountBeat","clamp","prevbeat","warpstart","warpend","prewarpbpm","timeofs","compareFirst","stopIndex","stopMax","stopPair","adjustOffset","bpmIndex","bpmMax","bpmPair","changeIsBpm","msdFile","reusedSongInfo","getNumValues","numParams","getNumParams","getValue","valueName","toUpperCase","handler","loadFromTokens","decompress","addSteps","hasSteps","processBpmsAndStops","lib_NoteLoaderSM","OGG_LOAD_TIMEOUT","OGG_LOAD_POLL","FileOperations_FileOperations","uri","responseType","oggHowl","onload","onloaderror","_","msg","promise_default","resolve","reject","startTime","now_default","timeout","checkLoaded","setTimeout","lib_FileOperations","main","requestAnimationFrame","gameLoop","DEFAULT_PACK_URL_PREFIX","debugTools","Appvue_type_script_lang_ts_App","App","packPathPrefix","VUE_APP_PACK_URL_PREFIX","musicSeek","$data","isPaused","newHowl","absoluteSimURI","p1","loadTextFile","smText","loadFromSimfile","absoluteHowlURI","p2","loadOggFileAsHowl","howl","all","loadSong","components","Appvue_type_script_lang_ts_","src_Appvue_type_script_lang_ts_","App_component","src_App","VApp","VBtn","VContainer","VContent","VFlex","VLayout","VSpacer","VGrid","VTextField","VToolbar","VToolbarTitle","components_VToolbar","config","productionTip","render","$mount"],"mappings":"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","file":"js/app.1d49d57b.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/simfile-viewer/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = __webpack_public_path__ + \"img/_Down_Tap_Note_16x8.884d6e62.png\";","module.exports = __webpack_public_path__ + \"img/Down_Hold_Body_Active.adc2d5a2.png\";","module.exports = __webpack_public_path__ + \"img/Down_Hold_Body_Inactive.623b36a7.png\";","module.exports = \"data:image/png;base64,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\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=style&index=0&id=5f8721bc&scoped=true&lang=css&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=style&index=0&id=5f8721bc&scoped=true&lang=css&\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"img/Fallback_Tap_Mine_8x1.47690a50.png\";","module.exports = __webpack_public_path__ + \"img/_Down_Receptor_Go_4x1.6a5930ce.png\";","module.exports = __webpack_public_path__ + \"img/Down_Roll_Body_Inactive.a6ed17c5.png\";","import Vue from 'vue';\nimport Vuetify from 'vuetify/lib';\nimport 'vuetify/src/stylus/app.styl';\n\nVue.use(Vuetify, {\n  iconfont: 'md',\n});\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-app',{attrs:{\"dark\":\"\"}},[_c('v-toolbar',{attrs:{\"app\":\"\"}},[_c('v-toolbar-title',{staticClass:\"headline text-uppercase\"},[_c('span',[_vm._v(\"Vuetify\")]),_c('span',{staticClass:\"font-weight-light\"},[_vm._v(\"MATERIAL DESIGN\")])]),_c('v-spacer'),_c('v-btn',{attrs:{\"flat\":\"\",\"href\":\"https://github.com/vuetifyjs/vuetify/releases/latest\",\"target\":\"_blank\"}},[_c('span',{staticClass:\"mr-2\"},[_vm._v(\"Latest Release\")])])],1),_c('v-content',[_c('v-container',[_c('v-layout',{attrs:{\"row\":\"\"}},[_c('v-flex',{attrs:{\"md6\":\"\"}},[_c('screen')],1),_c('v-flex',{attrs:{\"md6\":\"\"}},[_c('chart-picker',{on:{\"changeChart\":_vm.changeChart}})],1)],1),_c('v-flex',[_c('v-btn',{on:{\"click\":_vm.playPauseTrack}},[_vm._v(\"Play/Pause\")]),_c('v-btn',{on:{\"click\":_vm.seekTrack}},[_vm._v(\"Seek\")]),_c('v-text-field',{attrs:{\"type\":\"number\"},model:{value:(_vm.seek),callback:function ($$v) {_vm.seek=_vm._n($$v)},expression:\"seek\"}})],1)],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/** The width of a tap note sprite before any scaling. */\nexport const TAPNOTE_WIDTH_PX = 64;\n/** The height of a tap note sprite before any scaling. */\nexport const TAPNOTE_HEIGHT_PX = 64;\n/** The height of a hold note bottom cap before any scaling. */\nexport const HOLD_BOTTOM_CAP_HEIGHT_PX = 32;\n\n/** Tap note directions in rotation order from the down arrow. */\nexport enum TapNoteDirection {\n    DOWN,\n    LEFT,\n    UP,\n    RIGHT,\n}\n/** Translation function from direction index to lane index. */\nexport function directionToLaneIndex(direction: TapNoteDirection) {\n    switch (direction) {\n        case TapNoteDirection.DOWN: return 1;\n        case TapNoteDirection.LEFT: return 0;\n        case TapNoteDirection.UP: return 2;\n        case TapNoteDirection.RIGHT: return 3;\n        default: throw new Error(`unknown TapNoteDirection: ${direction}`);\n    }\n}\nexport function laneIndexToDirection(laneIndex: number) {\n    switch (laneIndex) {\n        case 0: return 1;\n        case 1: return 0;\n        case 2:\n        case 3:\n            return laneIndex;\n        default: throw new Error(`unknown laneIndex: ${laneIndex}`);\n    }\n}\n\n/** The margin on each side of the lane outside of the note tracks. */\nexport const LANE_MARGIN = 64;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"pixi-renderer\"},[_c('canvas',{ref:\"renderCanvas\"}),_vm._t(\"default\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","// Player number stuff\nexport enum PlayerNumber {\n    PLAYER_1 = 0,\n    PLAYER_2,\n    NUM,\t// leave this at the end\n    Invalid,\n}\nexport const NUM_PLAYERS = PlayerNumber.NUM;\nexport const PLAYER_INVALID = PlayerNumber.Invalid;\n","import * as PIXI from 'pixi.js';\nimport { TAPNOTE_WIDTH_PX, TAPNOTE_HEIGHT_PX, HOLD_BOTTOM_CAP_HEIGHT_PX } from './entities/EntitiesConstants';\nimport SCREENMAN from './ScreenManager';\n\n// Images used for sprites\n// Tap notes\nimport DownReceptor from '@/assets/noteskins/USWCelETT/_Down_Receptor_Go_4x1.png';\nimport DownTapNote from '@/assets/noteskins/USWCelETT/_Down_Tap_Note_16x8.png';\nimport TapMine from '@/assets/noteskins/common/Fallback_Tap_Mine_8x1.png';\n// Holds\nimport DownHoldBodyActive from '@/assets/noteskins/USWCelETT/Down_Hold_Body_Active.png';\nimport DownHoldBodyInactive from '@/assets/noteskins/USWCelETT/Down_Hold_Body_Inactive.png';\nimport DownHoldBottomCapActive from '@/assets/noteskins/USWCelETT/Down_Hold_BottomCap_active.png';\nimport DownHoldBottomCapInactive from '@/assets/noteskins/USWCelETT/Down_Hold_BottomCap_inactive.png';\n// Rolls\nimport DownRollBodyActive from '@/assets/noteskins/USWCelETT/_Down_Roll_Body_active_4x1.png';\nimport DownRollBodyInactive from '@/assets/noteskins/USWCelETT/Down_Roll_Body_Inactive.png';\nimport DownRollBottomCapActive from '@/assets/noteskins/USWCelETT/_Down_Roll_BottomCap_active_4x1.png';\nimport DownRollBottomCapInactive from '@/assets/noteskins/USWCelETT/Down_Roll_BottomCap_Inactive.png';\n\ninterface LoadSpriteInfo {\n    name: string;\n    textureUrl: string;\n    width: number;\n    height: number;\n    numSprites: number;\n    numAnimFrames: number;\n    animLength: number; // number of frames before advancing to the next anim sprite\n    animLoop: boolean;\n}\n\nexport interface GameSpriteInfo {\n    name: string;\n    width: number;\n    height: number;\n    animLength: number;\n    animLoop: boolean;\n    textures: PIXI.Texture[][]; // sprites can have sub-sprites (i.e. all the arrow colours)\n}\n\n// Tap note resources\nexport const DOWN_TAP_NOTE_SHEET_NAME = 'DownTapNoteSheet';\nexport const DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME = 'DownReceptorSheet';\nexport const TAP_MINE_SHEET_NAME = 'TapMineSheet';\n\n// Hold note resources\nexport const DOWN_HOLD_BODY_ACTIVE_SHEET_NAME = 'DownHoldBodyActiveSheet';\nexport const DOWN_HOLD_BODY_INACTIVE_SHEET_NAME = 'DownHoldBodyInactiveSheet';\nexport const DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME = 'DownHoldBottomCapActiveSheet';\nexport const DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME = 'DownHoldBottomCapInactiveSheet';\n\n// Roll note resources\nexport const DOWN_ROLL_BODY_ACTIVE_SHEET_NAME = 'DownRollBodyActiveSheet';\nexport const DOWN_ROLL_BODY_INACTIVE_SHEET_NAME = 'DownRollBodyInactiveSheet';\nexport const DOWN_ROLL_BOTTOM_CAP_ACTIVE_SHEET_NAME = 'DownRollBottomCapActiveSheet';\nexport const DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME = 'DownRollBottomCapInactiveSheet';\n\n/** List of all the textures we need to load. */\nconst SPRITE_DEFINITIONS: LoadSpriteInfo[] = [\n    // Tap notes\n    {\n        name: DOWN_TAP_NOTE_SHEET_NAME,\n        textureUrl: DownTapNote,\n        width: TAPNOTE_WIDTH_PX,\n        height: TAPNOTE_HEIGHT_PX,\n        numSprites: 8,\n        numAnimFrames: 16,\n        animLength: 2,\n        animLoop: true,\n    },\n    {\n        name: DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME,\n        textureUrl: DownReceptor,\n        width: TAPNOTE_WIDTH_PX,\n        height: TAPNOTE_HEIGHT_PX,\n        numSprites: 1,\n        numAnimFrames: 4,\n        animLength: 30,\n        animLoop: true,\n    },\n    {\n        name: TAP_MINE_SHEET_NAME,\n        textureUrl: TapMine,\n        width: TAPNOTE_WIDTH_PX,\n        height: TAPNOTE_HEIGHT_PX,\n        numSprites: 1,\n        numAnimFrames: 8,\n        animLength: 3,\n        animLoop: true,\n    },\n    // Holds\n    {\n        name: DOWN_HOLD_BODY_ACTIVE_SHEET_NAME,\n        textureUrl: DownHoldBodyActive,\n        width: TAPNOTE_WIDTH_PX,\n        height: 128,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n    {\n        name: DOWN_HOLD_BODY_INACTIVE_SHEET_NAME,\n        textureUrl: DownHoldBodyInactive,\n        width: TAPNOTE_WIDTH_PX,\n        height: 128,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n    {\n        name: DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME,\n        textureUrl: DownHoldBottomCapActive,\n        width: TAPNOTE_WIDTH_PX,\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n    {\n        name: DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME,\n        textureUrl: DownHoldBottomCapInactive,\n        width: TAPNOTE_WIDTH_PX,\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n    // Rolls\n    // {\n    //     name: DOWN_ROLL_BODY_ACTIVE_SHEET_NAME,\n    //     textureUrl: DownRollBodyActive,\n    //     width: TAPNOTE_WIDTH_PX,\n    //     height: 256,\n    //     numSprites: 1,\n    //     numAnimFrames: 1,\n    //     animLength: 1,\n    //     animLoop: false,\n    // },\n    {\n        name: DOWN_ROLL_BODY_INACTIVE_SHEET_NAME,\n        textureUrl: DownRollBodyInactive,\n        width: TAPNOTE_WIDTH_PX,\n        height: 256,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n    // {\n    //     name: DOWN_ROLL_BOTTOM_CAP_ACTIVE_SHEET_NAME,\n    //     textureUrl: DownRollBottomCapActive,\n    //     width: TAPNOTE_WIDTH_PX,\n    //     height: HOLD_BOTTOM_CAP_HEIGHT_PX,\n    //     numSprites: 1,\n    //     numAnimFrames: 1,\n    //     animLength: 1,\n    //     animLoop: false,\n    // },\n    {\n        name: DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME,\n        textureUrl: DownRollBottomCapInactive,\n        width: TAPNOTE_WIDTH_PX,\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\n        numSprites: 1,\n        numAnimFrames: 1,\n        animLength: 1,\n        animLoop: false,\n    },\n];\n\n/** Handles loading the resources we need to make things happen. */\nclass ResourceManager {\n    // Singleton\n    public static getInstance() {\n        if (!ResourceManager.instance) {\n            ResourceManager.instance = new ResourceManager();\n        }\n        return ResourceManager.instance;\n    }\n    private static instance: ResourceManager;\n\n    /** Stores all the textures we load, indexed by their identifiers.\n     * The textures are animated if there is more than one texture in the list.\n     * Stores other sprite metadata for convenience.\n     */\n    private spriteInfo: Map<string, GameSpriteInfo> = new Map();\n\n    /** Have we finished loading everything? */\n    private doneLoading = false;\n\n    // Private constructor for singleton pattern\n    private constructor() {}\n\n    public isDoneLoading() { return this.doneLoading; }\n    public getSpriteInfo(name: string) {\n        const spriteTextures = this.spriteInfo.get(name);\n        if (spriteTextures === undefined) {\n            throw new Error(`Could not find info for unknown sprite ${name}`);\n        }\n        return spriteTextures;\n    }\n\n    public loadSprites() {\n        // Load the sprites we'll need\n        const loader = SCREENMAN.getPixiApp().loader;\n        for (const spriteInfo of SPRITE_DEFINITIONS) {\n            loader.add(spriteInfo.name, spriteInfo.textureUrl);\n        }\n        // TODO: use loader.on.('progress', callbackFunc) to do a loading bar\n        loader.load(this.onLoad.bind(this));\n    }\n\n    /** Things to do when our textures finish loading. */\n    private onLoad() {\n        for (const spriteInfo of SPRITE_DEFINITIONS) {\n            this.extractTexturesFromSpriteSheet(spriteInfo);\n        }\n\n        this.doneLoading = true;\n    }\n\n    /** Extract animated textures from a sprite sheet. Add them to the global lookup.\n     * @param sprite: information describing how to extract the sprite.\n     */\n    private extractTexturesFromSpriteSheet(sprite: LoadSpriteInfo) {\n        const spriteTexture = SCREENMAN.getPixiApp().loader.resources[sprite.name].texture;\n\n        const sprites: PIXI.Texture[][] = [];\n        for (let s = 0; s < sprite.numSprites; s++) {\n            const spriteAnimTextures: PIXI.Texture[] = [];\n            for (let f = 0; f < sprite.numAnimFrames; f++) {\n                // Define a rectangle at the point we want to extract from\n                const rectangle = new PIXI.Rectangle(\n                    f * sprite.width,\n                    s * sprite.height,\n                    sprite.width,\n                    sprite.height,\n                );\n                // Clone that rectangle out of the original texture into a new smaller one\n                const spriteFrame = new PIXI.Texture(spriteTexture.baseTexture, rectangle);\n                spriteAnimTextures.push(spriteFrame);\n            }\n            // Store the sprite for later use\n            sprites.push(spriteAnimTextures);\n        }\n\n        this.spriteInfo.set(sprite.name, {\n            name: sprite.name,\n            width: sprite.width,\n            height: sprite.height,\n            animLength: sprite.animLength,\n            animLoop: sprite.animLoop,\n            textures: sprites,\n        });\n    }\n}\nconst RESOURCEMAN = ResourceManager.getInstance();\nexport default RESOURCEMAN;\n","import Entity from './Entity';\n\ninterface ScreenManagerOptions {\n    renderCanvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n}\n\n/** Responsible for managing all game entities. */\nexport class EntityManager {\n    // Singleton\n    public static getInstance() {\n        if (!EntityManager.instance) {\n            EntityManager.instance = new EntityManager();\n        }\n        return EntityManager.instance;\n    }\n    private static instance: EntityManager;\n\n    private entities: Entity[] = [];\n\n    // Private constructor for singleton\n    private constructor() {}\n\n    public registerEntity(entity: Entity) {\n        this.entities.push(entity);\n        return this;\n    }\n\n    public deregisterEntity(entity: Entity) {\n        for (let i = 0; i < this.entities.length; i++) {\n            if (this.entities[i] === entity) {\n                // TODO: Not the most efficient implementation. Change later.\n                this.entities.splice(i, 1);\n            }\n        }\n        return this;\n    }\n\n    /** Update all the entities we know about. */\n    public update(deltaTime: number) {\n        this.entities.forEach((entity) => {\n            entity.update(deltaTime);\n        });\n        return this;\n    }\n}\nconst ENTITYMAN = EntityManager.getInstance();\nexport default ENTITYMAN;\n","import ENTITYMAN from './EntityManager';\nimport NoteField from './NoteField';\n\n// The base class for all game entities\nabstract class Entity {\n    constructor() {\n        ENTITYMAN.registerEntity(this);\n    }\n\n    /** All entities must implement an update loop, even if it does nothing. */\n    public abstract update(deltaTime: number): this;\n\n    /** Destroys the current entity and unregisters it. */\n    public destroy() {\n        // TODO: look into what is necessary to recursively destroy a JS object\n        ENTITYMAN.deregisterEntity(this);\n    }\n}\nexport default Entity;\n","import * as PIXI from 'pixi.js';\nimport RESOURCEMAN, { GameSpriteInfo } from '../ResourceManager';\nimport SCREENMAN from '../ScreenManager';\nimport Entity from './Entity';\n\n/** Interface that describes anything that is drawable, including groups of sprites. */\nexport interface Drawable {\n    addToStage(): this;\n    removeFromStage(): this;\n    isOnStage(): boolean;\n    destroy(): void;\n}\n\n// Class to parent all sprite subsets\nclass GameSprite extends Entity implements Drawable {\n    public static checkDependencies() {\n        // We can't do anything if the resource manager isn't initialised\n        if (!RESOURCEMAN.isDoneLoading()) { throw new Error('RESOURCEMAN has not finished loading'); }\n    }\n\n    protected sprite: PIXI.Sprite;\n    protected onStage: boolean;\n\n    public constructor(sprite: PIXI.Sprite) {\n        super();\n\n        this.sprite = sprite;\n        this.onStage = false;\n\n        this.sprite.zIndex = 0;  // be explicit\n\n        // Anchor rotation around the center point\n        this.sprite.anchor.x = 0.5;\n        this.sprite.anchor.y = 0.5;\n    }\n\n    public destroy() {\n        this.removeFromStage();\n        super.destroy();\n    }\n\n    public isOnStage() { return this.onStage; }\n    public getSprite() { return this.sprite; }\n    public setPos(x: number, y: number) {\n        this.sprite.x = x;\n        this.sprite.y = y;\n        return this;\n    }\n    public setPosX(x: number) {\n        this.sprite.x = x;\n        return this;\n    }\n    public setPosY(y: number) {\n        this.sprite.y = y;\n        return this;\n    }\n    public addToStage() {\n        if (this.onStage) { return this; }\n\n        this.onStage = true;\n        SCREENMAN.getPixiApp().stage.addChild(this.sprite);\n        return this;\n    }\n    public removeFromStage() {\n        if (!this.onStage) { return this; }\n\n        this.onStage = false;\n        SCREENMAN.getPixiApp().stage.removeChild(this.sprite);\n        return this;\n    }\n\n    public setZIndex(z: number) {\n        this.sprite.zIndex = z;\n        return this;\n    }\n\n    public update(deltaTime: number): this {\n        // Basic sprite does nothing\n        return this;\n    }\n}\nexport default GameSprite;\n","import * as PIXI from 'pixi.js';\nimport { GameSpriteInfo } from '../ResourceManager';\nimport GameSprite from './GameSprite';\n\n// Class representing all sprites that are animated\nclass AnimatedGameSprite extends GameSprite {\n    protected sprite: PIXI.AnimatedSprite;\n\n    public constructor(spriteInfo: GameSpriteInfo, spriteIndex = 0) {\n        const sprite = new PIXI.AnimatedSprite(spriteInfo.textures[spriteIndex]);\n        super(sprite);\n        this.sprite = sprite;\n\n        // Translate frames of animation into an animation speed modifier\n        this.sprite.animationSpeed = 1 / spriteInfo.animLength;\n        this.sprite.loop = spriteInfo.animLoop;\n    }\n\n    public getSprite(): PIXI.AnimatedSprite {\n        return this.sprite;\n    }\n}\nexport default AnimatedGameSprite;\n","import AnimatedGameSprite from './AnimatedGameSprite';\nimport RESOURCEMAN, { DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME } from '../ResourceManager';\nimport { TapNoteDirection, directionToLaneIndex, LANE_MARGIN, TAPNOTE_WIDTH_PX } from './EntitiesConstants';\nimport GameSprite from './GameSprite';\n\nexport const RECEPTOR_MARGIN_TOP_PX = 32;\n\nclass TapNoteReceptorSprite extends AnimatedGameSprite {\n    private direction: TapNoteDirection;\n\n    /** Create a new tap note receptor sprite.\n     * @param direction the direction the arrow should go in.\n     */\n    constructor(direction: TapNoteDirection) {\n        GameSprite.checkDependencies();\n        super(RESOURCEMAN.getSpriteInfo(DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME));\n\n        this.direction = direction;\n        this.sprite.alpha = 0.75;\n        this.sprite.y = RECEPTOR_MARGIN_TOP_PX;\n\n        // Set the rotation based on the direction, using the down arrow as a reference\n        this.sprite.rotation = (90 * this.direction) * (Math.PI / 180);\n\n        // Set the x based on the note track\n        const laneIndex = directionToLaneIndex(this.direction);\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\n\n        this.sprite.play();\n    }\n\n    public getDirection() { return this.direction; }\n\n    public update(deltaTime: number) {\n        return this;\n    }\n}\nexport default TapNoteReceptorSprite;\n","import { PlayerNumber, PLAYER_INVALID } from './PlayerNumber';\n\n// Types for holding tap notes and scores\n\n// tslint:disable: max-classes-per-file\n\nexport class TapNoteResult {\n    // TODO: implement\n}\n\nexport class HoldNoteResult {\n    // TODO: implement\n}\n\n/** What is the TapNote's core type? */\nexport enum TapNoteType {\n    Empty, \t\t    /** There is no note here. */\n    Tap,\t\t    /** The player simply steps on this. */\n    HoldHead,\t    /** This is graded like the Tap type, but should be held. */\n    HoldTail,\t    /** In 2sand3s mode, holds are deleted and hold_tail is added. */\n    Mine,\t\t    /** In most modes, it is suggested to not step on these mines. */\n    Lift,\t\t    /** Lift your foot up when it crosses the target area. */\n    Attack,\t\t    /** Hitting this note causes an attack to take place. */\n    AutoKeysound,\t/** A special sound is played when this note crosses the target area. */\n    Fake,\t\t    /** This arrow can't be scored for or against the player. */\n    NUM,\n    Invalid,\n}\n\n/** The list of a TapNote's sub types. */\nexport enum TapNoteSubType {\n    Hold,   /** The start of a traditional hold note. */\n    Roll,   /** The start of a roll note that must be hit repeatedly. */\n    // Mine,\n    NUM,\n    Invalid,\n}\n\n// I'm not sure how useful this will be for a viewer - Struz\n/** The different places a TapNote could come from. */\nexport enum TapNoteSource {\n    Original,\t/** This note is part of the original NoteData. */\n    Addition,\t/** This note is additional note added by a transform. */\n    NUM,\n    Invalid,\n}\n\n/** The various properties of a tap note. */\nexport class TapNote {\n    /** Factory for non-default TapNotes */\n    public static create(\n        type: TapNoteType,\n        subType: TapNoteSubType,\n        source: TapNoteSource): TapNote {\n        if (type > TapNoteType.Fake) {\n            console.debug(`Invalid tap note type ${type} (most likely) due to random vanish issues.`);\n            type = TapNoteType.Empty;\n        }\n        const tapNote = new TapNote();\n        tapNote.type = type;\n        tapNote.subType = subType;\n        tapNote.source = source;\n        return tapNote;\n    }\n\n    /** The core note type that is about to cross the target area. */\n    public type: TapNoteType = TapNoteType.Empty;\n    /** The sub type of the note. This is only used if the type is HoldHead. */\n    public subType: TapNoteSubType = TapNoteSubType.Invalid;\n    /** The originating source of the TapNote. */\n    public source: TapNoteSource = TapNoteSource.Original;\n    /** The result of hitting or missing the TapNote. */\n    public result: TapNoteResult = new TapNoteResult();\n    /** The Player that is supposed to hit this note. This is mainly for Routine Mode. */\n    public pn: PlayerNumber = PLAYER_INVALID;\n\n    // Empty until filled in by NoteData.  These exist so that the notefield\n    // doesn't have to call GetElapsedTimeFromBeat 2-6 times for every note\n    // during rendering. -Kyz\n    public occursAtSecond: number = 0;\n    public endSecond: number = 0;  // occursAtSecond plus duration\n    // highestSubtypeOnRow is for rendering a tap as a hold head if\n    // there is a hold head on the same row.  It needs to be a TapNoteSubType\n    // instead of a bool to handle rolls. -Kyz\n    public highestSubtypeOnRow: TapNoteSubType = TapNoteSubType.Hold;\n    // ommitted idInChart, idInColumn, rowId - as these are for passing to mods\n\n    // ommitted attackModifiers, attackDurationSeconds - these are for attacks\n\n    // ommitted keySoundIndex as we don't support keysounds\n\n    // also used for HoldHead only;\n    /** The duration of the hold in note rows. */\n    public duration: number = 0;\n    public holdResult: HoldNoteResult = new HoldNoteResult();\n\n    public equals(other: TapNote) {\n        if (this.type !== other.type ||\n            this.subType !== other.subType ||\n            this.source !== other.source ||\n            this.duration !== other.duration ||\n            this.pn !== other.pn) {\n            return false;\n        }\n        return true;\n    }\n\n    // This was a struct in C++ which allowed copy by assignation.\n    // We deep copy here to get the same result.\n    public copy(): TapNote {\n        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    }\n}\n\n/** A collection of functions that manipulate note types and data. */\nexport class NoteHelpers {\n    public static beatToNoteRow(beatNum: number) {\n        return Math.round(beatNum * ROWS_PER_BEAT);\n    }\n    public static beatToNoteRowNotRounded(beatNum: number) {\n        return Math.trunc(beatNum * ROWS_PER_BEAT);\n    }\n    public static noteRowToBeat(row: number) {\n        return row / ROWS_PER_BEAT;\n    }\n\n    /**\n     * Scales the position.\n     * @param start - the starting row of the scaling region\n     * @param length - the length of the scaling region\n     * @param newLength - the new length of the scaling region\n     * @param position - the position to scale\n     * @return the scaled position\n     */\n    public static scalePosition(start: number, length: number, newLength: number, position: number): number {\n        if (position < start) {\n            return position;\n        }\n        if (position >= start + length) {\n            return position - length + newLength;\n        }\n        return start + (position - start) * newLength / length;\n    }\n\n    /**\n     * Convert the NoteType to a beat representation.\n     * @param nt the NoteType to check.\n     * @return the proper beat.\n     */\n    public static noteTypeToBeat(nt: NoteType) {\n        switch (nt) {\n            case NoteType.N_4TH:   return 1;\t    // quarter notes\n            case NoteType.N_8TH:   return 1 / 2;\t// eighth notes\n            case NoteType.N_12TH:  return 1 / 3;\t// quarter note triplets\n            case NoteType.N_16TH:  return 1 / 4;\t// sixteenth notes\n            case NoteType.N_24TH:  return 1.0 / 6;\t// eighth note triplets\n            case NoteType.N_32ND:  return 1 / 8;\t// thirty-second notes\n            case NoteType.N_48TH:  return 1 / 12;   // sixteenth note triplets\n            case NoteType.N_64TH:  return 1 / 16;   // sixty-fourth notes\n            case NoteType.N_192ND: return 1 / 48;   // sixty-fourth note triplets\n            case NoteType.Invalid: return 1 / 48;\n            default:\n                throw new Error(`Unrecognized note type: ${nt}`);\n        }\n    }\n\n    public static noteTypeToRow(nt: NoteType) {\n        switch (nt) {\n            case NoteType.N_4TH: return 48;\n            case NoteType.N_8TH: return 24;\n            case NoteType.N_12TH: return 16;\n            case NoteType.N_16TH: return 12;\n            case NoteType.N_24TH: return 8;\n            case NoteType.N_32ND: return 6;\n            case NoteType.N_48TH: return 4;\n            case NoteType.N_64TH: return 3;\n            case NoteType.N_192ND:\n            case NoteType.Invalid:\n                return 1;\n            default:\n                throw new Error(`Unrecognized note type: ${nt}`);\n        }\n    }\n\n    /**\n     * Retrieve the proper quantized NoteType for the note.\n     * @param row The row to check for.\n     * @return the quantized NoteType.\n     */\n    public static getNoteType(row: number): NoteType {\n        if (row % (ROWS_PER_MEASURE / 4) === 0) {\n            return NoteType.N_4TH;\n        } else if (row % (ROWS_PER_MEASURE / 8) === 0) {\n            return NoteType.N_8TH;\n        } else if (row % (ROWS_PER_MEASURE / 12) === 0) {\n            return NoteType.N_12TH;\n        } else if (row % (ROWS_PER_MEASURE / 16) === 0) {\n            return NoteType.N_16TH;\n        } else if (row % (ROWS_PER_MEASURE / 24) === 0) {\n            return NoteType.N_24TH;\n        } else if (row % (ROWS_PER_MEASURE / 32) === 0) {\n            return NoteType.N_32ND;\n        } else if (row % (ROWS_PER_MEASURE / 48) === 0) {\n            return NoteType.N_48TH;\n        } else if (row % (ROWS_PER_MEASURE / 64) === 0) {\n            return NoteType.N_64TH;\n        }\n        return NoteType.N_192ND;\n    }\n\n    public static beatToNoteType(beat: number) {\n        return this.getNoteType(NoteHelpers.beatToNoteRow(beat));\n    }\n\n    /**\n     * Determine if the row has a particular type of quantized note.\n     * @param row the row in the Steps.\n     * @param t the quantized NoteType to check for.\n     * @return true if the NoteType is t, false otherwise.\n     */\n    public static isNoteOfType(row: number, t: NoteType) {\n        return this.getNoteType(row) === t;\n    }\n}\nexport default NoteHelpers;\n\n/**\n * The number of rows per beat.\n * This is a divisor for our \"fixed-point\" time/beat representation. It must be\n * evenly divisible by 2, 3, and 4, to exactly represent 8th, 12th and 16th notes.\n */\nexport const ROWS_PER_BEAT: number = 48;\n\n/** The max number of rows allowed for a Steps pattern. */\n// tslint:disable-next-line: no-bitwise\nexport const MAX_NOTE_ROW: number = (1 << 30);\n\n/** The list of quantized note types allowed at present. */\nexport enum NoteType {\n    N_4TH,\t /** quarter note */\n    N_8TH,\t /** eighth note */\n    N_12TH,\t /** quarter note triplet */\n    N_16TH,\t /** sixteenth note */\n    N_24TH,\t /** eighth note triplet */\n    N_32ND,\t /** thirty-second note */\n    N_48TH,  /** sixteenth note triplet */\n    N_64TH,\t /** sixty-fourth note */\n    N_192ND, /** sixty-fourth note triplet */\n    NUM,\n    Invalid,\n}\n\n// STEPMANIA-TODO: Remove these constants that aren't time signature-aware\nexport const BEATS_PER_MEASURE = 4;\nexport const ROWS_PER_MEASURE = ROWS_PER_BEAT * BEATS_PER_MEASURE;\n\nexport class TapNotes {\n    public static EMPTY = TapNote.create(\n        TapNoteType.Empty, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_TAP = TapNote.create(\n        TapNoteType.Tap, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_LIFT = TapNote.create(\n        TapNoteType.Lift, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_HOLD_HEAD = TapNote.create(\n        TapNoteType.HoldHead, TapNoteSubType.Hold, TapNoteSource.Original);\n    public static ORIGINAL_ROLL_HEAD = TapNote.create(\n        TapNoteType.HoldHead, TapNoteSubType.Roll, TapNoteSource.Original);\n    public static ORIGINAL_MINE = TapNote.create(\n        TapNoteType.Mine, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_ATTACK = TapNote.create(\n        TapNoteType.Attack, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_AUTO_KEYSOUND = TapNote.create(\n        TapNoteType.AutoKeysound, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ORIGINAL_FAKE = TapNote.create(\n        TapNoteType.Fake, TapNoteSubType.Invalid, TapNoteSource.Original);\n    public static ADDITION_TAP = TapNote.create(\n        TapNoteType.Tap, TapNoteSubType.Invalid, TapNoteSource.Addition);\n    public static ADDITION_MINE = TapNote.create(\n        TapNoteType.Mine, TapNoteSubType.Invalid, TapNoteSource.Addition);\n\n    // The original code was in C++ so the above were structs that\n    // could be copied on assign. We use these functions to get around this.\n    public static newEmpty() { return this.EMPTY.copy(); }\n    public static newOriginalTap() { return this.ORIGINAL_TAP.copy(); }\n    public static newOriginalLift() { return this.ORIGINAL_LIFT.copy(); }\n    public static newOriginalHoldHead() { return this.ORIGINAL_HOLD_HEAD.copy(); }\n    public static newOriginalRollHead() { return this.ORIGINAL_ROLL_HEAD.copy(); }\n    public static newOriginalMine() { return this.ORIGINAL_MINE.copy(); }\n    public static newOriginalAttack() { return this.ORIGINAL_ATTACK.copy(); }\n    public static newOriginalAutoKeysound() { return this.ORIGINAL_AUTO_KEYSOUND.copy(); }\n    public static newOriginalFake() { return this.ORIGINAL_FAKE.copy(); }\n    public static newAdditionTap() { return this.ADDITION_TAP.copy(); }\n    public static newAdditionMine() { return this.ADDITION_MINE.copy(); }\n}\n","// Various structures to deal with segments of songs that have different timings\n// tslint:disable: max-classes-per-file\n\nimport NoteHelpers from './NoteTypes';\n\nexport enum TimingSegmentType {\n    BPM,\n    STOP,\n    DELAY,\n    TIME_SIG,\n    WARP,\n    LABEL,\n    TICKCOUNT,\n    COMBO,\n    SPEED,\n    SCROLL,\n    FAKE,\n    NUM,\n    Invalid,\n}\n\n// XXX: dumb names\nexport enum SegmentEffectType {\n    Row,\t\t// takes effect on a single row\n    Range,\t    // takes effect for a definite amount of rows\n    Indefinite,\t// takes effect until the next segment of its type\n    NUM,\n    Invalid,\n}\n\nexport const ROW_INVALID = -1;\n\nexport abstract class TimingSegment {\n    // for our purposes, two floats within this level of error are equal\n    public static EPSILON: number = 1e-6;\n\n    /** Compare two numbers for equality.\n     * @param num1 A number.\n     * @param num2 Another number.\n     * @returns true if they are close enough to be equal, false otherwise.\n     */\n    public static compareFloat(num1: number, num2: number) {\n        if (Math.abs(num1 - num2) > this.EPSILON) {\n            return false;\n        }\n        return true;\n    }\n\n    /** The row in which this segment activates */\n    private startRow: number = 0;\n\n    constructor(beatOrRow = ROW_INVALID, isRow = true) {\n        // If it's a row, store it, otherwise convert it to a row\n        this.startRow = (isRow ? beatOrRow : NoteHelpers.beatToNoteRow(beatOrRow));\n    }\n\n    public abstract getType(): TimingSegmentType;\n    public abstract getEffectType(): SegmentEffectType;\n    public abstract isNotable(): boolean;\n    public abstract debugPrint(): void;\n\n    /**\n     * Scales itself.\n     * @param start Starting row\n     * @param length Length in rows\n     * @param newLength The new length in rows\n     */\n    public scale(start: number, length: number, newLength: number): void {\n        this.setRow(NoteHelpers.scalePosition(start, length, newLength, this.getRow()));\n    }\n\n    public getRow() { return this.startRow; }\n    public setRow(row: number) { this.startRow = row; }\n\n    public getBeat() { return NoteHelpers.noteRowToBeat(this.startRow); }\n    public setBeat(beat: number) { this.setRow(NoteHelpers.beatToNoteRow(beat)); }\n\n    public toString(dec: number) { return this.getBeat().toString(); }\n    public abstract getValues(): number[];\n\n    public lessThan(other: TimingSegment) {\n        return this.getRow() < other.getRow();\n    }\n\n    // overloads should not call this base version; derived classes\n    // should only compare contents, and this compares position.\n    public equals(other: TimingSegment): boolean {\n        return this.getRow() === other.getRow();\n    }\n}\n\n/**\n * Identifies when a song needs to warp to a new beat.\n *\n * A warp segment is used to replicate the effects of Negative BPMs without\n * abusing negative BPMs. Negative BPMs should be converted to warp segments.\n * WarpAt=WarpToRelative is the format, where both are in beats.\n * (Technically they're both rows though.)\n */\nexport class WarpSegment extends TimingSegment {\n    private lengthRows: number;\n\n    constructor(startRow?: number, lengthRowsOrBeats?: number, isRows = true) {\n        // Do a poor man's overloaded constructor *sigh*\n        // constructor() is valid, constructor(row, lengthRows) is vaild,\n        // and constructor(row, lengthBeats) is valid.\n        // isRows defines whether lengthRowsOrBeats refers to rows or not\n        if (startRow === undefined) {\n            super();\n            this.lengthRows = 0;\n            return;\n        }\n        if (lengthRowsOrBeats === undefined) {\n            throw new Error('invalid constructor used - must provide nothing, or both optinoal parameters');\n        }\n        super(startRow, true);\n        if (isRows) {\n            this.lengthRows = lengthRowsOrBeats;\n        } else {\n            this.lengthRows = NoteHelpers.beatToNoteRow(lengthRowsOrBeats);\n        }\n    }\n\n    public getType() { return TimingSegmentType.WARP; }\n    public getEffectType() { return SegmentEffectType.Range; }\n\n    public isNotable() { return this.lengthRows > 0; }\n\n    public getLengthRows() { return this.lengthRows; }\n    public getLengthBeats() { return NoteHelpers.noteRowToBeat(this.lengthRows); }\n    public getLength() { return this.getLengthBeats(); }\n\n    public setLengthRows(rows: number) { this.lengthRows = rows; }\n    public setLengthBeats(beats: number) { this.lengthRows = NoteHelpers.beatToNoteRow(beats); }\n\n    public scale(start: number, length: number, newLength: number) {\n        // XXX: this function is duplicated, there should be a better way\n        const startBeat    = this.getBeat();\n        const endBeat      = startBeat + this.getLength();\n        const newStartBeat = NoteHelpers.scalePosition(\n            NoteHelpers.noteRowToBeat(start),\n            NoteHelpers.noteRowToBeat(length),\n            NoteHelpers.noteRowToBeat(newLength),\n            startBeat);\n        const newEndBeat   = NoteHelpers.scalePosition(\n            NoteHelpers.noteRowToBeat(start),\n            NoteHelpers.noteRowToBeat(length),\n            NoteHelpers.noteRowToBeat(newLength),\n            endBeat);\n        this.setLengthBeats(newEndBeat - newStartBeat);\n        super.scale(start, length, newLength);\n    }\n\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const lengthRows = this.getLengthRows();\n        const lengthBeats = this.getLengthBeats();\n        console.debug(`\\t${type}(${row} [${beat}], ${lengthRows} [${lengthBeats}])`);\n    }\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const length = this.getLength();\n        return `${beat}=${length}`;\n    }\n\n    public getValues(): number[] {\n        return [this.getLength()];\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof WarpSegment)) {\n            return false;\n        }\n        // If they differ in length, return false\n        if (!TimingSegment.compareFloat(this.lengthRows, other.lengthRows)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Identifies when a chart is to have a different tickcount value\n * for hold notes.\n *\n * A tickcount segment is used to better replicate the checkpoint hold\n * system used by various based video games. The number is used to\n * represent how many ticks can be counted in one beat.\n */\nexport class TickcountSegment extends TimingSegment {\n    /** The default amount of ticks per beat. */\n    public static DEFAULT_TICK_COUNT = 4;\n\n    /** The amount of hold checkpoints counted per beat */\n    private ticksPerBeat: number;\n\n    constructor(startRow = ROW_INVALID, ticks = TickcountSegment.DEFAULT_TICK_COUNT) {\n        super(startRow, true);\n        this.ticksPerBeat = ticks;\n    }\n\n    public getType() { return TimingSegmentType.TICKCOUNT; }\n    public getEffectType() { return SegmentEffectType.Indefinite; }\n    public isNotable() { return true; } // indefinite segments are always true\n\n    public getTicks() { return this.ticksPerBeat; }\n    public setTicks(ticks: number) { this.ticksPerBeat = ticks; }\n\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const ticks = this.getTicks();\n        console.debug(`\\t${type}(${row} [${beat}], ${ticks})`);\n    }\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const ticks = this.getTicks();\n        return `${beat}=${ticks}`;\n    }\n\n    public getValues(): number[] {\n        return [this.getTicks()];\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof TickcountSegment)) {\n            return false;\n        }\n        // If they differ in tick count, return false\n        if (!TimingSegment.compareFloat(this.ticksPerBeat, other.ticksPerBeat)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Identifies when a song changes its time signature.\n *\n * This only supports simple time signatures. The upper number\n * (called the numerator here, though this isn't properly a\n * fraction) is the number of beats per measure. The lower number\n * (denominator here) is the note value representing one beat.\n */\nexport class TimeSignatureSegment extends TimingSegment {\n    private numerator: number;\n    private denominator: number;\n\n    constructor(startRow = ROW_INVALID, numerator = 4, denominator = 4) {\n        super(startRow, true);\n        this.numerator = numerator;\n        this.denominator = denominator;\n    }\n\n    public getType() { return TimingSegmentType.TIME_SIG; }\n    public getEffectType() { return SegmentEffectType.Indefinite; }\n    public isNotable() { return true; } // indefinite segments are always true\n\n    public getNum() { return this.numerator; }\n    public setNum(num: number) { this.numerator = num; }\n\n    public getDen() { return this.denominator; }\n    public setDen(den: number) { this.denominator = den; }\n\n    public set(num: number, den: number) { this.numerator = num; this.denominator = den; }\n\n    /**\n     * Retrieve the number of note rows per measure within the TimeSignatureSegment.\n     *\n     * With BeatToNoteRow(1) rows per beat, then we should have BeatToNoteRow(1)*m_iNumerator\n     * beats per measure. But if we assume that every BeatToNoteRow(1) rows is a quarter note,\n     * and we want the beats to be 1/m_iDenominator notes, then we should have\n     * BeatToNoteRow(1)*4 is rows per whole note and thus BeatToNoteRow(1)*4/m_iDenominator is\n     * rows per beat. Multiplying by m_iNumerator gives rows per measure.\n     * @returns the number of note rows per measure.\n     */\n    public getNoteRowsPerMeasure() {\n        return NoteHelpers.beatToNoteRow(1) * 4 * this.numerator / this.denominator;\n    }\n\n    /**\n     * Retrieve the number of note rows per beat within the TimeSignatureSegment.\n     *\n     * This is just the number of note rows per measure, divided by the time signature\n     * denominator. For example, in a 4/4 time signature, there are 4 4th note beats\n     * in the measure.\n     */\n    public getNoteRowsPerBeat() {\n        return NoteHelpers.beatToNoteRow(1) * 4 / this.denominator;\n    }\n\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const num = this.getNum();\n        const den = this.getDen();\n        console.debug(`\\t${type}(${row} [${beat}], ${num}/${den})`);\n    }\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const num = this.getNum();\n        const den = this.getDen();\n        return `${beat}=${num}=${den}`;\n    }\n\n    public getValues(): number[] {\n        return [this.getNum(), this.getDen()];\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof TimeSignatureSegment)) {\n            return false;\n        }\n        // If they differ in either numerator or denominator, return false\n        if (!TimingSegment.compareFloat(this.numerator, other.numerator)) {\n            return false;\n        }\n        if (!TimingSegment.compareFloat(this.denominator, other.denominator)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Identifies when a song changes its BPM.\n */\nexport class BPMSegment extends TimingSegment {\n    /** The number of beats per second within this BPMSegment. */\n    private bps: number = 0;\n\n    constructor(startRow = ROW_INVALID, bpm = 0.0) {\n        super(startRow, true);\n        this.setBpm(bpm);\n    }\n\n    public getType() { return TimingSegmentType.BPM; }\n    public getEffectType() { return SegmentEffectType.Indefinite; }\n    public isNotable() { return true; } // indefinite segments are always true\n\n    public getBps() { return this.bps; }\n    public getBpm() { return this.bps * 60.0; }\n\n    public setBps(bps: number) { this.bps = bps; }\n    public setBpm(bpm: number) { this.bps = bpm / 60.0; }\n\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const bpm = this.getBpm();\n        console.debug(`\\t${type}(${row} [${beat}], ${bpm})`);\n    }\n\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const bpm = this.getBpm().toFixed(dec);\n        return `${beat}=${bpm}`;\n    }\n\n    public getValues(): number[] {\n        return [this.getBpm()];\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof BPMSegment)) {\n            return false;\n        }\n        // If they differ in bps, return false\n        if (!TimingSegment.compareFloat(this.bps, other.bps)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/**\n * Identifies when a song has a stop, DDR/ITG style.\n */\nexport class StopSegment extends TimingSegment {\n    /** The number of seconds to pause at the segment's row. */\n    private seconds: number;\n\n    constructor(startRow = ROW_INVALID, seconds = 0.0) {\n        super(startRow, true);\n        this.seconds = seconds;\n    }\n\n    public getType() { return TimingSegmentType.STOP; }\n    public getEffectType() { return SegmentEffectType.Row; }\n    public isNotable() { return this.seconds > 0; } // indefinite segments are always true\n\n    public getPause() { return this.seconds; }\n    public setPause(seconds: number) { this.seconds = seconds; }\n\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const pause = this.getPause();\n        console.debug(`\\t${type}(${row} [${beat}], ${pause})`);\n    }\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const pause = this.getPause();\n        return `${beat}=${pause}`;\n    }\n\n    public getValues(): number[] {\n        return [this.getPause()];\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof StopSegment)) {\n            return false;\n        }\n        return TimingSegment.compareFloat(this.seconds, other.seconds);\n    }\n}\n\n/**\n * Identifies when a song has a delay, or pump style stop.\n */\nexport class DelaySegment extends TimingSegment {\n    /** The number of seconds to pause at the segment's row. */\n    private seconds: number = -1;\n\n    constructor(startRow = ROW_INVALID, seconds = 0) {\n        super(startRow, true);\n        this.seconds = seconds;\n    }\n\n    public getType() { return TimingSegmentType.DELAY; }\n    public getEffectType() { return SegmentEffectType.Row; }\n\n    public getPause() { return this.seconds; }\n    public setPause(seconds: number) { this.seconds = seconds; }\n\n    public isNotable() { return this.seconds > 0; }\n    public getValues() { return [this.getPause()]; }\n    public debugPrint() {\n        const type = this.getType();\n        const row = this.getRow();\n        const beat = this.getBeat();\n        const pause = this.getPause();\n        console.debug(`\\t${type}(${row} [${beat}], ${pause})`);\n    }\n    public toString(dec: number) {\n        const beat = this.getBeat().toFixed(dec);\n        const pause = this.getPause().toFixed(dec);\n        return `${beat}=${pause}`;\n    }\n\n    public equals(other: TimingSegment): boolean {\n        if (this.getType() !== other.getType()) {\n            return false;\n        }\n\n        if (!(other instanceof DelaySegment)) {\n            return false;\n        }\n        return TimingSegment.compareFloat(this.seconds, other.seconds);\n    }\n}\n","// tslint:disable: max-classes-per-file\nimport { TimingSegment, TimingSegmentType, SegmentEffectType,\n    TimeSignatureSegment, BPMSegment, TickcountSegment,\n    WarpSegment, StopSegment, DelaySegment } from './TimingSegments';\nimport { PassByRef } from './GameConstantsAndTypes';\nimport NoteHelpers from './NoteTypes';\nimport { NotImplementedError } from './Error';\n\nconst INVALID_INDEX: number = -1;\n\n/* DummySegments: since our model relies on being able to get a segment at will,\n * whether one exists or not, we have a bunch of dummies to return if there is\n * no segment. It's kind of kludgy, but when we have functions making\n * indiscriminate calls to get segments at arbitrary rows, I think it's the\n * best solution we've got for now.\n *\n * Note that types whose SegmentEffectAreas are \"Indefinite\" are NULL here,\n * because they should never need to be used; we always have at least one such\n * segment in the TimingData, and if not, we'll crash anyway. -- vyhd */\nconst DummySegments: Array<TimingSegment | null> = [\n    null, // BPMSegment\n    new StopSegment(),\n    new DelaySegment(),\n    null, // TimeSignatureSegment\n    new WarpSegment(),\n    null, // LabelSegment\n    null, // TickcountSegment\n    null, // ComboSegment\n    null, // SpeedSegment\n    null, // ScrollSegment\n    null, // Haven't implemented FakeSegment yet //new FakeSegment(),\n];\n\nenum FoundEventType {\n    WARP,\n    WARP_DESTINATION,\n    BPM_CHANGE,\n    STOP,\n    DELAY,\n    STOP_DELAY, // we have these two on the same row.\n    MARKER,\n    NOT_FOUND,\n}\n\n/** Simple struct for finding events in timing data. */\nclass FindEventStatus {\n    public bpm = 0;\n    public warp = 0;\n    public stop = 0;\n    public delay = 0;\n    public lastRow = 0;\n    public lastTime = 0;\n    public warpDestination = 0;\n    public isWarping = false;\n}\n\n// GetBeatArgs, GetBeatStarts, m_beat_start_lookup, m_time_start_lookup,\n// PrepareLookup, and ReleaseLookup form a system for speeding up finding\n// the current beat and bps from the time, or finding the time from the\n// current beat.\n// The lookup tables contain indices for the beat and time finding\n// functions to start at so they don't have to walk through all the timing\n// segments.\n// PrepareLookup should be called before gameplay starts, so that the lookup\n// tables are populated.  ReleaseLookup should be called after gameplay\n// finishes so that memory isn't wasted.\n// -Kyz\n/** Struct for passing around timing info. */\nexport class GetBeatArgs {\n    public elapsedTime = 0;\n    public beat = 0;\n    public bpsOut = 0;\n    public warpDestOut = 0;\n    public warpBeginOut = -1; // int\n    public freezeOut = false;\n    public delayOut = false;\n}\nexport class GetBeatStarts {\n    public bpm = 0;     // int\n    public warp = 0;    // int\n    public stop = 0;    // int\n    public delay = 0;   // int\n    public lastRow = 0; // int\n    public lastTime = 0;\n    public warpDestination = 0;\n    public isWarping = false;\n}\n/** A pair representing <beat or second, GetBeatStarts> */\ntype LookupItem = [number, GetBeatStarts];\ntype BeatStartLookup = Array<LookupItem | undefined>;\n\n/** Holds data for translating beats<->seconds. */\nexport class TimingData {\n    // Utility functions\n    public static findEntryInLookup(lookup: BeatStartLookup, entry: number): LookupItem | undefined {\n        if (lookup.length === 0) { return undefined; }\n        let lower = 0;\n        let upper = lookup.length - 1;\n\n        // If the entry we're looking for is outside the bounds of the array\n        // then fail fast\n        let lookupItem = lookup[lower];\n        if (lookupItem === undefined) { throw new Error('lookup[lower] must be defined'); }\n        if (lookupItem[0] > entry) {\n            return undefined;\n        }\n        lookupItem = lookup[upper];\n        if (lookupItem === undefined) { throw new Error('lookup[upper] must be defined'); }\n        if (lookupItem[0] < entry) {\n            // See explanation at the end of this function. -Kyz\n            return lookup[upper - 1];\n        }\n\n        // Otherwise use a binary search to find it\n        while (upper - lower > 1) {\n            const next = Math.trunc((upper + lower) / 2); // int\n            lookupItem = lookup[next];\n            if (lookupItem === undefined) { throw new Error('lookup[next] must be defined'); }\n            if (lookupItem[0] > entry) {\n                upper = next;\n            } else if (lookupItem[0] < entry) {\n                lower = next;\n            } else {\n                // We found the element\n                lower = next;\n                break;\n            }\n        }\n        // If the time or beat being looked up is close enough to the starting\n        // point that is returned, such as putting the time inside a stop or delay,\n        // then it can make arrows unhittable.  So always return the entry before\n        // the closest one to prevent that. -Kyz\n        if (lower === 0) { return undefined; }\n        return lookup[lower - 1];\n    }\n\n    public static findEvent(\n        eventRow: PassByRef<number>, eventType: PassByRef<number>,\n        status: FindEventStatus, beat: number, findMarker: boolean, bpms: TimingSegment[],\n        warps: TimingSegment[], stops: TimingSegment[], delays: TimingSegment[]) {\n            if (status.isWarping && NoteHelpers.beatToNoteRow(status.warpDestination) < eventRow.value) {\n                eventRow.value = NoteHelpers.beatToNoteRow(status.warpDestination);\n                eventType.value = FoundEventType.WARP_DESTINATION;\n            }\n            if (status.bpm < bpms.length && bpms[status.bpm].getRow() < eventRow.value) {\n                eventRow.value = bpms[status.bpm].getRow();\n                eventType.value = FoundEventType.BPM_CHANGE;\n            }\n            if (status.delay < delays.length && delays[status.delay].getRow() < eventRow.value) {\n                eventRow.value = delays[status.delay].getRow();\n                eventType.value = FoundEventType.DELAY;\n            }\n            if (findMarker && NoteHelpers.beatToNoteRow(beat) < eventRow.value) {\n                eventRow.value = NoteHelpers.beatToNoteRow(beat);\n                eventType.value = FoundEventType.MARKER;\n            }\n            if (status.stop < stops.length && stops[status.stop].getRow() < eventRow.value) {\n                // Because of the way we PassByRef we need to assign a value like this to make it separate\n                const tmpRow = {value: eventRow.value};\n                eventRow.value = stops[status.stop].getRow();\n                eventType.value = (tmpRow.value === eventRow.value) ? FoundEventType.STOP_DELAY : FoundEventType.STOP;\n            }\n            if (status.warp < warps.length && warps[status.warp].getRow() < eventRow.value) {\n                eventRow.value = warps[status.warp].getRow();\n                eventType.value = FoundEventType.WARP;\n            }\n        }\n\n    // Beat<->Second translation structures\n    public beatStartLookup: BeatStartLookup = [];\n    public timeStartLookup: BeatStartLookup = [];\n\n    /** The initial offset of a song. */\n    private beat0OffsetInSecs: number = 0;\n    // All of the following vectors must be sorted before gameplay.\n    private timingSegments: TimingSegment[][] = [];\n\n    constructor() {\n        // TimingSegments has one array per valid TimingSegmentType enum\n        for (let i = 0; i < TimingSegmentType.NUM; i++) {\n            this.timingSegments.push([]);\n        }\n    }\n\n    public getBeatInternal(start: GetBeatStarts, args: GetBeatArgs, maxSegment: number) {\n        const segs = this.timingSegments;\n        const bpms = segs[TimingSegmentType.BPM];\n        const warps = segs[TimingSegmentType.WARP];\n        const stops = segs[TimingSegmentType.STOP];\n        const delays = segs[TimingSegmentType.DELAY];\n        let curSegment = start.bpm + start.warp + start.stop + start.delay;\n\n        let bps = this.getBpmAtRow(start.lastRow) / 60;\n\n        while (curSegment < maxSegment) {\n            const eventRow = { value: Number.MAX_SAFE_INTEGER };\n            const eventType = { value: FoundEventType.NOT_FOUND };\n            TimingData.findEvent(eventRow, eventType, start, 0, false, bpms, warps, stops, delays);\n            if (eventType.value === FoundEventType.NOT_FOUND) { break; }\n            let timeToNextEvent = start.isWarping ? 0 :\n                NoteHelpers.noteRowToBeat(eventRow.value - start.lastRow) / bps;\n            let nextEventTime = start.lastTime + timeToNextEvent;\n            if (args.elapsedTime < nextEventTime) { break; }\n            start.lastTime = nextEventTime;\n\n            switch (eventType.value) {\n                case FoundEventType.WARP_DESTINATION:\n                    start.isWarping = false;\n                    break;\n                case FoundEventType.BPM_CHANGE:\n                    bps = (bpms[start.bpm] as BPMSegment).getBps();\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.bpm++;\n                    break;\n                case FoundEventType.DELAY:\n                case FoundEventType.STOP_DELAY:\n                    const delaySeg = (delays[start.delay] as DelaySegment);\n                    timeToNextEvent = delaySeg.getPause();\n                    nextEventTime = start.lastTime + timeToNextEvent;\n                    if (args.elapsedTime < nextEventTime) {\n                        args.freezeOut = false;\n                        args.delayOut = true;\n                        args.beat = delaySeg.getBeat();\n                        args.bpsOut = bps;\n                        return;\n                    }\n                    start.lastTime = nextEventTime;\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.delay++;\n                    if (eventType.value === FoundEventType.DELAY) { break; }\n                case FoundEventType.STOP:\n                    const stopSeg = (stops[start.stop] as StopSegment);\n                    timeToNextEvent = stopSeg.getPause();\n                    nextEventTime = start.lastTime + timeToNextEvent;\n                    if (args.elapsedTime < nextEventTime) {\n                        args.freezeOut = true;\n                        args.delayOut = false;\n                        args.beat = stopSeg.getBeat();\n                        args.bpsOut = bps;\n                        return;\n                    }\n                    start.lastTime = nextEventTime;\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.stop++;\n                    break;\n                case FoundEventType.WARP:\n                    start.isWarping = true;\n                    const warpSeg = (warps[start.warp] as WarpSegment);\n                    const warpSum = warpSeg.getLength() + warpSeg.getBeat();\n                    if (warpSum > start.warpDestination) {\n                        start.warpDestination = warpSum;\n                    }\n                    args.warpBeginOut = eventRow.value;\n                    args.warpDestOut = start.warpDestination;\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.warp++;\n                    break;\n                default:\n                    break;\n            }\n            start.lastRow = eventRow.value;\n        }\n\n        if (args.elapsedTime === Number.MAX_VALUE) {\n            args.elapsedTime = start.lastTime;\n        }\n        args.beat = NoteHelpers.noteRowToBeat(start.lastRow) + (args.elapsedTime - start.lastTime) * bps;\n        args.bpsOut = bps;\n    }\n\n    public getElapsedTimeInternal(start: GetBeatStarts, beat: number, maxSegment: number) {\n        const segs = this.timingSegments;\n        const bpms = segs[TimingSegmentType.BPM];\n        const warps = segs[TimingSegmentType.WARP];\n        const stops = segs[TimingSegmentType.STOP];\n        const delays = segs[TimingSegmentType.DELAY];\n        let curSegment = start.bpm + start.warp + start.stop + start.delay;\n\n        let bps = this.getBpmAtRow(start.lastRow) / 60;\n        const findMarker = beat < Number.MAX_VALUE;\n\n        while (curSegment < maxSegment) {\n            const eventRow = { value: Number.MAX_SAFE_INTEGER };\n            const eventType = { value: FoundEventType.NOT_FOUND };\n            TimingData.findEvent(eventRow, eventType, start, beat, findMarker, bpms, warps, stops, delays);\n            let timeToNextEvent = start.isWarping ? 0 :\n                NoteHelpers.noteRowToBeat(eventRow.value - start.lastRow) / bps;\n            let nextEventTime = start.lastTime + timeToNextEvent;\n            start.lastTime = nextEventTime;\n\n            switch (eventType.value) {\n                case FoundEventType.WARP_DESTINATION:\n                    start.isWarping = false;\n                    break;\n                case FoundEventType.BPM_CHANGE:\n                    bps = (bpms[start.bpm] as BPMSegment).getBps();\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.bpm++;\n                    break;\n                case FoundEventType.STOP:\n                case FoundEventType.STOP_DELAY:\n                    const stopSeg = (stops[start.stop] as StopSegment);\n                    timeToNextEvent = stopSeg.getPause();\n                    nextEventTime = start.lastTime + timeToNextEvent;\n                    start.lastTime = nextEventTime;\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.stop++;\n                    break;\n                case FoundEventType.DELAY:\n                    timeToNextEvent = (delays[start.delay] as DelaySegment).getPause();\n                    nextEventTime = start.lastTime + timeToNextEvent;\n                    start.lastTime = nextEventTime;\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.delay++;\n                    break;\n                case FoundEventType.MARKER:\n                    return start.lastTime;\n                case FoundEventType.WARP:\n                    start.isWarping = true;\n                    const warpSeg = (warps[start.warp] as WarpSegment);\n                    const warpSum = warpSeg.getLength() + warpSeg.getBeat();\n                    if (warpSum > start.warpDestination) {\n                        start.warpDestination = warpSum;\n                    }\n                    // INC_INDEX next 2 lines\n                    curSegment++;\n                    start.warp++;\n                    break;\n                default:\n                    break;\n            }\n            start.lastRow = eventRow.value;\n        }\n        return start.lastTime;\n    }\n\n    public prepareLookup() {\n        // If multiple players have the same timing data, then adding to the\n        // lookups would probably cause FindEntryInLookup to return the wrong\n        // thing.  So release the lookups. -Kyz\n        this.releaseLookup();\n        const segmentsPerLookup = 16;\n        const segs = this.timingSegments;\n        const bpms = segs[TimingSegmentType.BPM];\n        const warps = segs[TimingSegmentType.WARP];\n        const stops = segs[TimingSegmentType.STOP];\n        const delays = segs[TimingSegmentType.DELAY];\n\n        const totalSegments = bpms.length + warps.length + stops.length + delays.length;\n        // extend the arrays with 'undefined' entries\n        for (let curSegment = segmentsPerLookup; curSegment < totalSegments; curSegment += segmentsPerLookup) {\n            const beatStart = new GetBeatStarts();\n            beatStart.lastTime = -this.beat0OffsetInSecs;\n            const args = new GetBeatArgs();\n            args.elapsedTime = Number.MAX_VALUE;\n            this.getBeatInternal(beatStart, args, curSegment);\n            this.beatStartLookup.push([args.elapsedTime, beatStart]);\n\n            const timeStart = new GetBeatStarts();\n            timeStart.lastTime = -this.beat0OffsetInSecs;\n            this.getElapsedTimeInternal(timeStart, Number.MAX_VALUE, curSegment);\n            this.timeStartLookup.push([NoteHelpers.noteRowToBeat(timeStart.lastRow), timeStart]);\n        }\n        // If there are less than two entries, then FindEntryInLookup in lookup\n        // will always decide there's no appropriate entry.  So clear the table.\n        // -Kyz\n        if (this.beatStartLookup.length < 2) { this.releaseLookup(); }\n    }\n\n    public releaseLookup() {\n        this.beatStartLookup = [];\n        this.timeStartLookup = [];\n    }\n\n    public segInfoStr(segs: TimingSegment[], index: number, name: string) {\n        if (index < segs.length) {\n            return `${name}: ${index} at ${segs[index].getRow()}`;\n        }\n        return `${name}: ${index} at end`;\n    }\n\n    public dumpOneLookupTable(lookup: BeatStartLookup, name: string) {\n        const segs = this.timingSegments;\n        const bpms = segs[TimingSegmentType.BPM];\n        const warps = segs[TimingSegmentType.WARP];\n        const stops = segs[TimingSegmentType.STOP];\n        const delays = segs[TimingSegmentType.DELAY];\n        console.debug(`${name} lookup table:`);\n        for (let lit = 0; lit < lookup.length; lit++) {\n            const item = lookup[lit];\n            if (item === undefined) { throw new Error('item should never be undefined'); }\n            const starts = item[1];\n            console.debug(`${lit}: ${item[0]}`);\n\n            const bpmInfo = this.segInfoStr(bpms, starts.bpm, 'bpm');\n            const warpInfo = this.segInfoStr(warps, starts.warp, 'warp');\n            const stopInfo = this.segInfoStr(stops, starts.stop, 'stop');\n            const delayInfo = this.segInfoStr(delays, starts.delay, 'delay');\n            const str = `  ${bpmInfo}, ${warpInfo}, ${stopInfo}, ${delayInfo},\\n` +\n                        `  lastRow: ${starts.lastRow}, lastTime: ${starts.lastTime},\\n` +\n                        `  warpDestination: ${starts.warpDestination}, isWarping: ${starts.isWarping}`;\n            console.debug(str);\n        }\n    }\n\n    public dumpLookupTables() {\n        console.debug('Dumping timing data lookup tables');\n        this.dumpOneLookupTable(this.beatStartLookup, 'beatStartLookup');\n        this.dumpOneLookupTable(this.timeStartLookup, 'timeStartLookup');\n        console.debug('Finished dumping lookup tables');\n    }\n\n\n    public empty() {\n        for (let tst = 0; tst < TimingSegmentType.NUM; tst++) {\n            if (this.timingSegments[tst].length > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Retrieve the TimingSegment at the specified row.\n     * @param iNoteRow the row that has a TimingSegment.\n     * @param tst the TimingSegmentType requested.\n     * @return the segment in question.\n     */\n    public getSegmentAtRow(noteRow: number, tst: TimingSegmentType) {\n        const segments = this.getTimingSegments(tst);\n\n        if (segments.length === 0) {\n            const retSegment = DummySegments[tst];\n            if (retSegment === null) { throw new Error('FATAL: retSegment should never be null'); }\n            return retSegment;\n        }\n\n        const index = this.getSegmentIndexAtRow(tst, noteRow);\n        const seg = segments[index];\n\n        switch (seg.getEffectType()) {\n            case SegmentEffectType.Indefinite:\n                // this segment is in effect at this row\n                return seg;\n            default:\n                // if the returned segment isn't exactly on this row,\n                // we don't want it, return a dummy instead\n                if (seg.getRow() === noteRow) {\n                    return seg;\n                }\n                const retSegment = DummySegments[tst];\n                if (retSegment === null) { throw new Error('FATAL: retSegment should never be null'); }\n                return retSegment;\n        }\n    }\n\n    /* The following functions were all preprocessor defined so this is a giant block\n       of code compared to what was in the C++. Unfortunate. Maybe we can clean this up\n       one day -Struz */\n    public getBpmSegmentAtRow(noteRow: number) {\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.BPM);\n        return (t as BPMSegment);\n    }\n    public getStopSegmentAtRow(noteRow: number) {\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.STOP);\n        return (t as StopSegment);\n    }\n    public getDelaySegmentAtRow(noteRow: number) {\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.DELAY);\n        return (t as DelaySegment);\n    }\n\n    /* convenience aliases (Set functions are deprecated) */\n    public getBpmAtRow(noteRow: number) { return this.getBpmSegmentAtRow(noteRow).getBpm(); }\n    public getStopAtRow(noteRow: number) { return this.getStopSegmentAtRow(noteRow).getPause(); }\n    public getDelayAtRow(noteRow: number) { return this.getDelaySegmentAtRow(noteRow).getPause(); }\n\n    public isWarpAtRow(noteRow: number) {\n        const warps = this.getTimingSegments(TimingSegmentType.WARP);\n        if (warps.length === 0) { return false; }\n\n        const i = this.getSegmentIndexAtRow(TimingSegmentType.WARP, noteRow);\n        if (i === -1) { return false; }\n\n        const s = warps[i] as WarpSegment;\n        const beatRow = NoteHelpers.noteRowToBeat(noteRow);\n        if (s.getBeat() <= beatRow && beatRow < (s.getBeat() + s.getLength())) {\n            // Allow stops inside warps to allow things like stop, warp, stop, warp, stop, and so on.\n            if (this.getTimingSegments(TimingSegmentType.STOP).length === 0 &&\n                this.getTimingSegments(TimingSegmentType.DELAY).length === 0) {\n                    return true;\n                }\n            if (this.getStopAtRow(noteRow) !== 0 || this.getDelayAtRow(noteRow) !== 0) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    public isWarpAtBeat(beat: number) { return this.isWarpAtRow(NoteHelpers.beatToNoteRow(beat)); }\n\n    public isFakeAtRow(noteRow: number) {\n        // We don't support fakes yet -Struz\n        return false;\n        // const fakes = this.getTimingSegments(TimingSegmentType.FAKE);\n        // if (fakes.length === 0) { return false; }\n\n        // const i = this.getSegmentIndexAtRow(TimingSegmentType.FAKE, noteRow);\n        // if (i === -1) { return false; }\n\n        // const s = fakes[i] as FakeSegment;\n    }\n    public isFakeAtBeat(beat: number) { return this.isFakeAtRow(NoteHelpers.beatToNoteRow(beat)); }\n\n    public isJudgableAtRow(row: number) { return !this.isWarpAtRow(row) && !this.isFakeAtRow(row); }\n    public isJudgableAtBeat(beat: number) { return this.isJudgableAtRow(NoteHelpers.beatToNoteRow(beat)); }\n\n    public adjustOffset(amount: number) {\n        this.setOffset(this.beat0OffsetInSecs + amount);\n    }\n\n    public setOffset(offset: number) {\n        if (offset !== this.beat0OffsetInSecs) {\n            this.beat0OffsetInSecs = offset;\n            // TODO: it's changed, we probably need to recompute the data for anything using it\n            // see: TimingData::set_offset in StepMania\n        }\n    }\n\n    public getOffset() {\n        return this.beat0OffsetInSecs;\n    }\n\n    public getTimingSegments(tst: TimingSegmentType) {\n        return this.timingSegments[tst];\n    }\n\n    public addSegment(seg: TimingSegment) {\n        // TODO: add debug logging flag and put a debug log here\n        const tst = seg.getType();\n        const segs = this.timingSegments[tst];\n\n        // Optimisation: if this is our first segment, push and return\n        if (segs.length === 0) {\n            // TODO: make sure this shallow copy actually works for all delay types\n            const cpy = Object.assign(Object.create(Object.getPrototypeOf(seg)), seg);\n            segs.push(cpy);\n            return;\n        }\n\n        const index = this.getSegmentIndexAtRow(tst, seg.getRow());\n        if (index === INVALID_INDEX) {\n            // TODO: make this error better\n            throw new Error('ASSERTION FAILED: index should not be INVALID_INDEX');\n        }\n        const cur: TimingSegment = segs[index];\n        const isNotable = seg.isNotable();\n        const onSameRow = seg.getRow() === cur.getRow();\n\n        // ignore changes that are zero and don't overwrite an existing segment\n        if (!isNotable && !onSameRow) {\n            return;\n        }\n\n        // TODO: all the splicing in here may have memory leaks if references remain - test this\n        switch (seg.getEffectType()) {\n            case SegmentEffectType.Row:\n            case SegmentEffectType.Range:\n                // if we're overwriting a change with a non-notable\n                // one, take it to mean deleting the existing segment\n                if (onSameRow && isNotable) {\n                    // Removes the element in-place\n                    segs.splice(index, 1);\n                    return;\n                }\n                break;\n            case SegmentEffectType.Indefinite:\n                let prev: TimingSegment = cur;\n\n                // get the segment before last; if we're on the same\n                // row, get the segment in effect before 'cur'\n                if (onSameRow && index > 0) {\n                    prev = segs[index - 1];\n                }\n                // If there is another segment after this one, it might become\n                // redundant when this one is inserted.\n                // If the next segment is redundant, we want to move its starting row\n                // to the row the new segment is being added at instead of erasing it\n                // and adding the new segment.\n                // If the new segment is also redundant, erase the next segment because\n                // that effectively moves it back to the prev segment. -Kyz\n                if (index < segs.length - 1) {\n                    const next: TimingSegment = segs[index + 1];\n                    if (seg.equals(next)) {\n                        // The segment after this new one is redundant\n                        if (seg.equals(prev)) {\n                            // This new segment is redundant.  Erase the next segment and\n                            // ignore this new one.\n                            segs.splice(index + 1, 1);\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\n                            // This seems to be shorthand for (onSameRow && index > 0) since that is the\n                            // only way I can see prev being !== cur based on above code.\n                            if (prev !== cur) {\n                                segs.splice(index, 1);\n                            }\n                            return;\n                        } else {\n                            // Move the next segment's start back to this row.\n                            next.setRow(seg.getRow());\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\n                            // See earlier comment about the shorthand this is for.\n                            if (prev !== cur) {\n                                segs.splice(index, 1);\n                            }\n                            return;\n                        }\n                    } else {\n                        // if true, this is redundant segment change\n                        if (prev.equals(seg)) {\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\n                            // See earlier comment about the shorthand this is for.\n                            if (prev !== cur) {\n                                segs.splice(index, 1);\n                            }\n                            return;\n                        }\n                    }\n                } else {\n                    // if true, this is redundant segment change\n                    if (prev.equals(seg)) {\n                        // NOTE: this is actual pointer math in StepMania, not object .equals\n                        if (prev !== cur) {\n                            segs.splice(index, 1);\n                        }\n                        return;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n\n        // the segment at or before this row is equal to the new one; ignore it\n        // NOTE: this is NOT pointer math - it's a .equals\n        if (onSameRow && (cur.equals(seg))) {\n            return;\n        }\n\n        // Copy() the segment (which allocates a new segment), assign it\n        // to the position of the old one, then delete the old pointer.\n        // TODO: probably not the best way to do this in js -Struz\n        const copy = Object.assign(Object.create(Object.getPrototypeOf(seg)), seg);\n        if (onSameRow) {\n            // TODO: check memory leaks\n            // delete the existing segment and replace it\n            segs[index] = copy;\n        } else {\n            // Find the first element that isn't comparatively less than `copy`\n            let i = segs.findIndex((ts) => !ts.lessThan(copy));\n            if (i === -1) {\n                // No element is < copy, insert at end to maintain ordering\n                i = segs.length;\n            }\n\n            segs.splice(i, 0, copy);\n        }\n    }\n\n    public noteRowToMeasureAndBeat(\n        noteRow: number, measureIndexOut: PassByRef<number>,\n        beatIndexOut: PassByRef<number>, rowsRemainder: PassByRef<number>) {\n            // TODO: this function could have some weirdness given it was all with ints in\n            // C++ and we're using number here. If anything goes wrong try more Math.truncs\n            measureIndexOut.value = 0;\n            const tSigs = this.getTimingSegments(TimingSegmentType.TIME_SIG);\n            for (let i = 0; i < tSigs.length; i++) {\n                const curSig = (tSigs[i] as TimeSignatureSegment);\n                const segmentEndRow = (i + 1 === tSigs.length) ? Number.MAX_SAFE_INTEGER : curSig.getRow();\n\n                const rowsPerMeasureThisSegment = curSig.getNoteRowsPerMeasure();\n                // Usage of this variable fixes a bug from StepMania: https://github.com/stepmania/stepmania/issues/1080\n                const rowsPerBeatThisSegment = curSig.getNoteRowsPerBeat();\n\n                if (noteRow >= curSig.getRow()) {\n                    // noteRow lands in this segment\n                    const numRowsThisSegment = noteRow - curSig.getRow();\n                    // don't round up (below)\n                    const numMeasuresThisSegment = Math.trunc(numRowsThisSegment / rowsPerMeasureThisSegment);\n                    measureIndexOut.value += numMeasuresThisSegment;\n                    // These are all integers so we need to trunc for our callers benefit\n                    beatIndexOut.value = Math.trunc(numRowsThisSegment / rowsPerBeatThisSegment);\n                    rowsRemainder.value = numRowsThisSegment % rowsPerMeasureThisSegment;\n                    return;\n                } else {\n                    // noteRow lands after this segment\n                    const numRowsThisSegment = segmentEndRow - curSig.getRow();\n                    const numMeasuresThisSegment = Math.trunc(\n                        (numRowsThisSegment + rowsPerMeasureThisSegment - 1) / rowsPerMeasureThisSegment); // Round up\n                    measureIndexOut.value += numMeasuresThisSegment;\n                }\n            }\n            throw new Error('Failed to get measure and beat for note row');\n        }\n\n    public getSegmentIndexAtRow(tst: TimingSegmentType, row: number) {\n        const segs = this.timingSegments[tst];\n        if (segs.length === 0) {\n            return INVALID_INDEX;\n        }\n\n        // TODO: this not working? Not finding correct segment\n        // BECAUSE ITS ORDERED IN REVERSE\n\n        const min = 0;\n        const max = segs.length - 1;\n        let l = min;\n        let r = max;\n        // Do a binary search to find the row, if any\n        while ( l <= r ) {\n            const m = Math.trunc((l + r) / 2); // int\n            if ( ( m === min || segs[m].getRow() <= row ) && ( m === max || row < segs[m + 1].getRow() ) ) {\n                return m;\n            } else if (segs[m].getRow() <= row) {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        // row is before first segment of type tst\n        return INVALID_INDEX;\n    }\n    public getSegmentIndexAtBeat(tst: TimingSegmentType, beat: number) {\n        return this.getSegmentIndexAtRow(tst, NoteHelpers.beatToNoteRow(beat));\n    }\n\n    public getNextSegmentBeatAtRow(tst: TimingSegmentType, row: number) {\n        const segs = this.getTimingSegments(tst);\n        for (const seg of segs) {\n            if (seg.getRow() <= row) { continue; }\n            return seg.getBeat();\n        }\n        return NoteHelpers.noteRowToBeat(row);\n    }\n    public getNextSegmentBeatAtBeat(tst: TimingSegmentType, beat: number) {\n        return this.getNextSegmentBeatAtRow(tst, NoteHelpers.beatToNoteRow(beat));\n    }\n\n    public getPreviousSegmentBeatAtRow(tst: TimingSegmentType, row: number) {\n        let backup = -1;\n        const segs = this.getTimingSegments(tst);\n        for (const seg of segs) {\n            if (seg.getRow() >= row) { break; }\n            backup = seg.getBeat();\n        }\n        return (backup > -1) ? backup : NoteHelpers.noteRowToBeat(row);\n    }\n    public getPreviousSegmentBeatAtBeat(tst: TimingSegmentType, beat: number) {\n        return this.getPreviousSegmentBeatAtRow(tst, NoteHelpers.beatToNoteRow(beat));\n    }\n\n    public getBeatFromElapsedTime(elapsedTime: number): number {\n        const args = new GetBeatArgs();\n        args.elapsedTime = elapsedTime;\n        this.getBeatAndBpsFromElapsedTime(args);\n        return args.beat;\n    }\n\n    public getBeatFromElapsedTimeNoOffset(second: number): number {\n        // We don't support offset yet so this function does the same. Pass through. -Struz\n        return this.getBeatFromElapsedTime(second);\n    }\n\n    public getElapsedTimeFromBeatNoOffset(beat: number): number {\n        let start = new GetBeatStarts();\n        start.lastTime = -this.beat0OffsetInSecs;\n        const lookedUpStart = TimingData.findEntryInLookup(this.timeStartLookup, beat);\n        if (lookedUpStart !== undefined) {\n            // Make sure to use a copy so we don't modify it again and again in getBeatInternal()\n            start = Object.assign(Object.create(Object.getPrototypeOf(lookedUpStart[1])), lookedUpStart[1]);\n        }\n        this.getElapsedTimeInternal(start, beat, Number.MAX_SAFE_INTEGER);\n        return start.lastTime;\n    }\n\n    public getElapsedTimeFromBeat(beat: number): number {\n        return this.getElapsedTimeFromBeatNoOffset(beat);\n        // The C++ code handles hasted music rate here but we don't implement that -Struz\n    }\n\n    public getBeatAndBpsFromElapsedTime(args: GetBeatArgs) {\n        // The C++ code handles hasted music rate here but we don't implement that -Struz\n        this.getBeatAndBpsFromElapsedTimeNoOffset(args);\n    }\n\n    public getBeatAndBpsFromElapsedTimeNoOffset(args: GetBeatArgs): void {\n        let start = new GetBeatStarts();\n        start.lastTime = -this.beat0OffsetInSecs;\n        const lookedUpStart = TimingData.findEntryInLookup(this.beatStartLookup, args.elapsedTime);\n        if (lookedUpStart !== undefined) {\n            // Make sure to use a copy so we don't modify it again and again in getBeatInternal()\n            start = Object.assign(Object.create(Object.getPrototypeOf(lookedUpStart[1])), lookedUpStart[1]);\n        }\n        this.getBeatInternal(start, args, Number.MAX_SAFE_INTEGER);\n    }\n\n    public getDisplayedSpeedPercent(songBeat: number, musicSeconds: number) {\n        const speeds = this.getTimingSegments(TimingSegmentType.SPEED);\n        if (speeds.length === 0) { return 1; }\n        return 1;\n\n        // TODO: finish me when we implement SpeedSegment\n\n        // const index = this.getSegmentIndexAtBeat(TimingSegmentType.SPEED, songBeat);\n\n        // const seg = (speeds[index] as SpeedSegment);\n    }\n\n    public tidyUpData(allowEmpty: boolean) {\n        if (allowEmpty && this.empty()) {\n            return;  // Steps with empty timing data revert to song timing\n        }\n\n        // If there are no BPM segments, provide a default.\n        if (this.timingSegments[TimingSegmentType.BPM].length === 0) {\n            console.warn('Song has no BPM segments, default 60 provided.');\n            this.addSegment(new BPMSegment(0, 60));\n        }\n\n        // Make sure the first BPM segment starts at beat 0.\n        if (this.timingSegments[TimingSegmentType.BPM][0].getRow() !== 0) {\n            this.timingSegments[TimingSegmentType.BPM][0].setRow(0);\n        }\n\n        // If no time signature specified, assume default time for the whole song.\n        if (this.timingSegments[TimingSegmentType.TIME_SIG].length === 0) {\n            this.addSegment(new TimeSignatureSegment(0));\n        }\n\n        // Likewise, if no tickcount signature is specified, assume 4 ticks\n        // per beat for the entire song. The default of 4 is chosen more\n        // for compatibility with the main Pump series than anything else.\n        // (TickcountSegment's constructor handles that now. -- vyhd)\n        if (this.timingSegments[TimingSegmentType.TICKCOUNT].length === 0) {\n            this.addSegment(new TickcountSegment(0));\n        }\n\n        // Have a default combo segment of one just in case.\n        // if (this.timingSegments[TimingSegmentType.COMBO].length === 0) {\n        //     this.addSegment(new ComboSegment(0));\n        // }\n        // TODO: uncomment when we implement combo segments\n\n        // Have a default label segment just in case.\n        // if (this.timingSegments[TimingSegmentType.LABEL].length === 0) {\n        //     this.addSegment(new LabelSegment(0));\n        // }\n        // TODO: uncomment when we implement label segments\n\n        // Always be sure there is a starting speed.\n        // if (this.timingSegments[TimingSegmentType.SPEED].length === 0) {\n        //     this.addSegment(new SpeedSegment(0));\n        // }\n        // IMPORTANT: uncomment when we implement speed segments\n\n        // Always be sure there is a starting scrolling factor.\n        // if (this.timingSegments[TimingSegmentType.SCROLL].length === 0) {\n        //     this.addSegment(new ScrollSegment(0));\n        // }\n        // IMPORTANT: uncomment when we implement speed segments\n    }\n}\nexport default TimingData;\n","import hrtime from 'browser-process-hrtime';\n\n/** Seconds per microsecond. */\nconst TIMESTAMP_RESOLUTION = 1000000;\nconst NANOSECONDS_PER_MICROSECOND = 1000;\n\n/** A way to keep track of time in a way that shouldn't overflow. */\ninterface PreciseTime {\n    secs: number; /** Seconds */\n    us: number;   /** Microseconds */\n}\n\n/** A mirror of RageTimer */\nexport class GameTimer {\n    /** Returns the number of seconds and microseconds since init. */\n    public static getTime() {\n        const time = hrtime();\n        const secs = time[0];\n        const us = Math.trunc(time[1] / NANOSECONDS_PER_MICROSECOND);\n        if (GameTimer.initTimeSecs === 0) {\n            GameTimer.initTimeSecs = secs;\n            GameTimer.initTimeUs = us;\n        }\n\n        let deltaSecs = secs - GameTimer.initTimeSecs;\n        let deltaUs = us - GameTimer.initTimeUs;\n        if (deltaUs < 0) {\n            deltaUs += TIMESTAMP_RESOLUTION;\n            --deltaSecs;\n        }\n        return { secs: deltaSecs, us: deltaUs };\n    }\n\n    private static initTimeSecs = 0;\n    private static initTimeUs = 0;\n\n    /** Adds a number of seconds to a GameTimer\n     *  and returns a GameTimer that contains the added time.\n     */\n    private static sum(lhs: GameTimer, tm: number): GameTimer {\n        /* tm == 5.25  -> secs =  5, us = 5.25  - ( 5) = .25\n\t     * tm == -1.25 -> secs = -2, us = -1.25 - (-2) = .75 */\n        // From what I can gather, tm is a float representing seconds - Struz\n        const seconds = Math.trunc(tm); // Int\n        const us = Math.trunc( (tm - seconds) * TIMESTAMP_RESOLUTION ); // Int\n\n        const ret = new GameTimer(0, 0); // Prevent unnecessarily checking the time via .touch()\n        ret.secs = seconds + lhs.secs;\n        ret.us = us + lhs.us;\n\n        if (ret.us >= TIMESTAMP_RESOLUTION) {\n            ret.us -= TIMESTAMP_RESOLUTION;\n            ++ret.secs;\n        }\n        return ret;\n    }\n    /** The difference between two GameTimers in seconds, as a float. */\n    private static difference(lhs: GameTimer, rhs: GameTimer) {\n        let secs = lhs.secs - rhs.secs;\n        let us = lhs.us - rhs.us;\n\n        if (us < 0) {\n            us += TIMESTAMP_RESOLUTION;\n            --secs;\n        }\n        return secs + us / TIMESTAMP_RESOLUTION;\n    }\n\n    public secs: number;\n    public us: number;\n\n    constructor(secs?: number, us?: number) {\n        // Constructor: (secs, us)\n        if (secs !== undefined && us !== undefined) {\n            this.secs = secs;\n            this.us = us;\n            return;\n        }\n        // Constructor: ()\n        this.secs = 0;\n        this.us = 0;\n        this.touch();\n        return;\n    }\n\n    public ago(): number {\n        const now = new GameTimer();\n        return now.subtract(this);\n    }\n    public touch(): void {\n        const time = GameTimer.getTime();\n        this.secs = time.secs;\n        this.us = time.us;\n    }\n    public isZero(): boolean { return this.secs === 0 && this.us === 0; }\n    public setZero() { this.secs = 0; this.us = 0; }\n\n    /** Time between last call to GetDeltaTime() (Ago() + Touch()): */\n    public getDeltaTime() {\n        const now = new GameTimer();\n        const diff = GameTimer.difference(now, this);\n        // This is just .touch() but saves us a call to getTime()\n        this.secs = now.secs;\n        this.us = now.us;\n        return diff;\n    }\n    /* (alias) */\n    public peekDeltaTime() { return this.ago(); }\n\n    /*\n    * Get a timer representing half of the time ago as this one.  This is\n    * useful for averaging time.  For example,\n    *\n    * GameTimer tm;\n    * ... do stuff ...\n    * GameTimer AverageTime = tm.Half();\n    * printf( \"Something happened approximately %f seconds ago.\\n\", tm.Ago() );\n    */\n    public half() {\n        const probableDelay = this.ago() / 2;\n        return this.add(probableDelay);\n    }\n\n    // TODO operators\n    /** Add a number of seconds to this game timer. */\n    public add(tm: number) {\n        return GameTimer.sum(this, tm);\n    }\n    public subtract(rhs: GameTimer) {\n        return GameTimer.difference(this, rhs);\n    }\n    public lessThan(rhs: GameTimer) {\n        if (this.secs !== rhs.secs) { return this.secs < rhs.secs; }\n        return this.us < rhs.us;\n    }\n}\nexport default GameTimer;\n\nexport const gZeroTimer = new GameTimer(0, 0);\n","// tslint:disable: max-line-length\n\nexport const EXPECTED_FPS = 60;\n\n// The different game categories available to play.\n// Taken from commit b95e49216eb2974b8e0f69b6603595df1c698ccd\nexport enum StepsTypeCategory {\n    Single, // One person plays on one side.\n    Double, // One person plays on both sides.\n    Couple, // Two players play on their own side.\n    Routine, // Two players share both sides together.\n}\n\n// The different steps types for playing.\n// Taken from commit b95e49216eb2974b8e0f69b6603595df1c698ccd\nexport enum StepsType {\n    dance_single = 0,\n    dance_double,\n    dance_couple,\n    dance_solo,\n    dance_threepanel,\n    dance_routine,\n    pump_single,\n    pump_halfdouble,\n    pump_double,\n    pump_couple,\n    pump_routine,\n    kb7_single,\n    ez2_single,\n    ez2_double,\n    ez2_real,\n    para_single,\n    ds3ddx_single,\n    beat_single5,\n    beat_versus5,\n    beat_double5,\n    beat_single7,\n    beat_versus7,\n    beat_double7,\n    maniax_single,\n    maniax_double,\n    techno_single4,\n    techno_single5,\n    techno_single8,\n    techno_double4,\n    techno_double5,\n    techno_double8,\n    popn_five,\n    popn_nine,\n    lights_cabinet,\n    kickbox_human,\n    kickbox_quadarm,\n    kickbox_insect,\n    kickbox_arachnid,\n    NUM, \t// leave this at the end\n    Invalid,\n}\n\n// The collective information about a Steps' type\nexport class StepsTypeInfo {\n    // The name of the step type\n    public stepTypeName: string;\n    // The number of tracks, or columns, of this type.\n    public numTracks: number;\n    // A flag to determine if we allow this type to be autogen'ed to other types.\n    public allowAutogen: boolean;\n    // The most basic StyleType that this StpesTypeInfo is used with.\n    public stepsTypeCategory: StepsTypeCategory;\n\n    constructor(stepTypeName: string, numTracks: number,\n                allowAutogen: boolean, stepsTypeCategory: StepsTypeCategory) {\n        this.stepTypeName = stepTypeName;\n        this.numTracks = numTracks;\n        this.allowAutogen = allowAutogen;\n        this.stepsTypeCategory = stepsTypeCategory;\n    }\n\n    public toString(): string {\n        return this.stepTypeName;\n    }\n}\n\n// Information about all the step types we support. Taken from StepMania\n// GameManager.cpp at line 50, commit b95e49216eb2974b8e0f69b6603595df1c698ccd\n// The indexes here must match the indexes in the enum.\n// TODO: this is really ugly without the full enum names linked here - Fix when have time.\nexport const StepsTypeInfos: StepsTypeInfo[] = [\n    // dance\n    new StepsTypeInfo('dance-single', 4, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('dance-double', 8, true, StepsTypeCategory.Double),\n    new StepsTypeInfo('dance-couple', 8, true, StepsTypeCategory.Couple),\n    new StepsTypeInfo('dance-solo', 6, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('dance-threepanel', 3, true, StepsTypeCategory.Single), // thanks to kurisu\n    new StepsTypeInfo('dance-routine', 8, false, StepsTypeCategory.Routine),\n    // pump\n    new StepsTypeInfo('pump-single', 5, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('pump-halfdouble', 6, true, StepsTypeCategory.Double),\n    new StepsTypeInfo('pump-double', 10, true, StepsTypeCategory.Double),\n    new StepsTypeInfo('pump-couple', 10, true, StepsTypeCategory.Couple),\n    // uh, dance-routine has that one bool as false... wtf? -aj\n    new StepsTypeInfo('pump-routine', 10, true, StepsTypeCategory.Routine),\n    // kb7\n    new StepsTypeInfo('kb7-single', 7, true, StepsTypeCategory.Single),\n    // new StepsTypeInfo('kb7-small', 7, true, StepsTypeCategory.Single),\n    // ez2dancer\n    new StepsTypeInfo('ez2-single', 5, true, StepsTypeCategory.Single), // Single: TL,LHH,D,RHH,TR\n    new StepsTypeInfo('ez2-double', 10, true, StepsTypeCategory.Double), // Double: Single x2\n    new StepsTypeInfo('ez2-real', 7, true, StepsTypeCategory.Single), // Real: TL,LHH,LHL,D,RHL,RHH,TR\n    // parapara paradise\n    new StepsTypeInfo('para-single', 5, true, StepsTypeCategory.Single),\n    // ds3ddx\n    new StepsTypeInfo('ds3ddx-single', 8, true, StepsTypeCategory.Single),\n    // beatmania\n    new StepsTypeInfo('bm-single5', 6, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\n    new StepsTypeInfo('bm-versus5', 6, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\n    new StepsTypeInfo('bm-double5', 12, true, StepsTypeCategory.Double), // called \"bm\" for backward compat\n    new StepsTypeInfo('bm-single7', 8, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\n    new StepsTypeInfo('bm-versus7', 8, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\n    new StepsTypeInfo('bm-double7', 16, true, StepsTypeCategory.Double), // called \"bm\" for backward compat\n    // dance maniax\n    new StepsTypeInfo('maniax-single', 4, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('maniax-double', 8, true, StepsTypeCategory.Double),\n    // technomotion\n    new StepsTypeInfo('techno-single4', 4, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('techno-single5', 5, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('techno-single8', 8, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('techno-double4', 8, true, StepsTypeCategory.Double),\n    new StepsTypeInfo('techno-double5', 10, true, StepsTypeCategory.Double),\n    new StepsTypeInfo('techno-double8', 16, true, StepsTypeCategory.Double),\n    // pop'n music\n    new StepsTypeInfo('pnm-five', 5, true, StepsTypeCategory.Single), // called \"pnm\" for backward compat\n    new StepsTypeInfo('pnm-nine', 9, true, StepsTypeCategory.Single), // called \"pnm\" for backward compat\n    // cabinet lights and other fine StepsTypes that don't exist lol\n    new StepsTypeInfo('lights-cabinet', 6, false, StepsTypeCategory.Single), // XXX disable lights autogen for now\n    // kickbox mania\n    new StepsTypeInfo('kickbox-human', 4, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('kickbox-quadarm', 4, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('kickbox-insect', 6, true, StepsTypeCategory.Single),\n    new StepsTypeInfo('kickbox-arachnid', 8, true, StepsTypeCategory.Single),\n];\n\n// TODO: pull difficulty stuff into another file\n// Player number stuff\nexport enum Difficulty {\n    Beginner,\n    Easy,\n    Medium,\n    Hard,\n    Challenge,\n    Edit,\n    NUM,\n    Invalid,\n}\n\nconst OldStyleStringToDifficultyMap: Map<string, Difficulty> = new Map([\n    ['beginner', Difficulty.Beginner],\n    ['easy', Difficulty.Easy],\n    ['basic', Difficulty.Easy],\n    ['light', Difficulty.Easy],\n    ['medium', Difficulty.Medium],\n    ['another', Difficulty.Medium],\n    ['trick', Difficulty.Medium],\n    ['standard', Difficulty.Medium],\n    ['difficult', Difficulty.Medium],\n    ['hard', Difficulty.Hard],\n    ['ssr', Difficulty.Hard],\n    ['maniac', Difficulty.Hard],\n    ['heavy', Difficulty.Hard],\n    ['smaniac', Difficulty.Challenge],\n    ['challenge', Difficulty.Challenge],\n    ['expert', Difficulty.Challenge],\n    ['oni', Difficulty.Challenge],\n    ['edit', Difficulty.Edit],\n]);\n\n// Define the mininum and maximum chart difficulty value allowed.\nconst MIN_METER = 1;\nconst MAX_METER = 35;\n\n/** Hacky way to pass things by reference without too much overhead. */\nexport interface PassByRef<T> {\n    value: T;\n}\n\n// Disabled so we can group collective things up in this file\n// tslint:disable-next-line: max-classes-per-file\nexport class Helpers {\n    public static stringToStepsType(stepsType: string): StepsType {\n        for (let i = 0; i < StepsTypeInfos.length; i++) {\n            if (StepsTypeInfos[i].stepTypeName === stepsType) {\n                return i;\n            }\n        }\n        return StepsType.Invalid;\n    }\n\n    public static getStepsTypeInfo(st: StepsType) {\n        if (st >= StepsType.NUM) {\n            throw new Error(`getStepsTypeInfo(): Invalid steps type index ${st}`);\n        }\n        return StepsTypeInfos[st];\n    }\n\n    public static oldStyleStringToDifficulty(oldDifficulty: string): Difficulty {\n        const difficulty = OldStyleStringToDifficultyMap.get(oldDifficulty.toLowerCase());\n        if (difficulty === undefined) {\n            return Difficulty.Invalid;\n        }\n        return difficulty;\n    }\n\n    public static HHMMSSToSeconds(HHMMSS: string) {\n        const arrayBits = HHMMSS.split(':');\n        while (arrayBits.length < 3) {\n            arrayBits.splice(0, 0, '0'); // pad missing bits\n        }\n        let seconds = 0;\n        seconds += this.stringToInt(arrayBits[0]) * 60 * 60;\n        seconds += this.stringToInt(arrayBits[1]) * 60;\n        seconds += this.stringToFloat(arrayBits[2]);\n        return seconds;\n    }\n\n    /**\n     * Return a list of values for the enum, not including Invalid.\n     * Enum must have a .NUM element for this to work.\n     *\n     * Uses some any magic, but we expect to only return numbers.\n     */\n    public static forEachEnum(gameEnum: { NUM: number }): number[] {\n        const iterator: number[] = [];\n        const keys = Object.keys(gameEnum);\n        const values = keys.map((k) => {\n            if (k === 'NUM') { return; }\n            const value = (gameEnum as any)[k as any];\n            if (value < gameEnum.NUM) {\n                iterator.push(value);\n            }\n        });\n        return iterator;\n    }\n\n    /** Clamp a number to be between min and max. */\n    public static clamp(num: number, min: number, max: number): number {\n        return Math.min(Math.max(num, min), max);\n    }\n\n    // StringToInt and StringToFloat are wrappers around std::stoi and std::stof\n    // which handle the exception by returning 0.  Reporting the exception would\n    // be cumbersome, and there are probably a million things that rely on an\n    // \"invalid\" string being silently converted to 0.  This includes cases where\n    // someone uses an empty string and expects it to come out 0, probably\n    // frequently used in metrics. -Kyz\n\n    /** Like parseInt(x, 10) but instead of NaN it returns 0. */\n    public static stringToInt(str: string) {\n        const int = parseInt(str, 10);\n        if (isNaN(int)) {\n            return 0;\n        }\n        return int;\n    }\n    /** Like parseFloat(x) but instead of NaN it returns 0. */\n    public static stringToFloat(str: string) {\n        const float = parseFloat(str);\n        if (isNaN(float)) {\n            return 0.0;\n        }\n        return float;\n    }\n\n    /** Interpolate within the ranges and interlopant. */\n    public static lerp(x: number, l: number, h: number) {\n        return (h - l) * x + l;\n    }\n\n    /** Scale the target number so that the two targets match.\n     *\n     * This does not modify x, so it MUST assign the result to something!\n     * Do the multiply before the divide so that integer scales have more precision.\n     *\n     * One such example: scale(x, 0, 1, L, H); interpolate between L and H.\n     */\n    public static scale(x: number, l1: number, h1: number, l2: number, h2: number) {\n        return ( l1 === 0 && h1 === 1 ) ? Helpers.lerp(x, l2, h2) : (x - l1) * (h2 - l2) / (h1 - l1) + l2;\n    }\n}\nexport default Helpers;\n","import { Howl } from 'howler';\nimport { debug } from 'util';\n\n// Simple wrapper for a playable song. This is so we can\n// extend the functionality if we need to, for example\n// by padding silence.\nclass SongSound {\n    /** The actual song sound bytes. */\n    protected sound: Howl;\n\n    constructor(sound: Howl) {\n        this.sound = sound;\n    }\n\n    public play(at?: number) {\n        if (at !== undefined) {\n            this.seek(at);\n        }\n        this.sound.play();\n    }\n\n    public pause() {\n        this.sound.pause();\n    }\n\n    public seek(time: number) {\n        this.sound.seek(time);\n    }\n\n    public getSound() { return this.sound; }\n    public getTimeElapsed() {\n        const timeElapsed = this.sound.seek() as number;\n        return timeElapsed;\n    }\n}\nexport default SongSound;\n","import GAMESTATE from './GameState';\nimport NoteHelpers, { ROWS_PER_BEAT } from './NoteTypes';\nimport TimingData from './TimingData';\nimport { BPMSegment } from './TimingSegments';\nimport { EXPECTED_FPS } from './GameConstantsAndTypes';\nimport { DebugTools } from './Debug';\nimport SongSound from './SongSound';\n\n/** The amount of time in seconds that is allowable to drift from\n * the playing music.\n */\nconst MAX_TOLERATED_DRIFT_SECS = (1 / EXPECTED_FPS) * 2; // 2 frames @ 60fps\nconst DRIFT_SECS_BEFORE_UPDATE = 0.05;\n\nexport class MusicPlaying {\n    public music: SongSound;\n    public timing: TimingData;\n\n    public hasTiming = false;\n    public applyMusicRate = false;\n\n    // Anything else we need to sync up things\n\n    constructor(music: Howl, timing: TimingData) {\n        this.music = new SongSound(music);\n        this.timing = timing;\n    }\n\n    public hasMusic() {\n        return this.music !== undefined;\n    }\n}\n\nexport class MusicToPlay {\n    public hasTiming = false;\n    public timing: TimingData | undefined;\n\n    public startSeconds = 0;\n    public lengthSeconds = 0;\n    public fadeInLengthSeconds = 0;\n    public fadeOutLengthSeconds = 0;\n    public forceLoop = false;\n    public alignBeat = false;\n    public applyMusicRate = false;\n\n    // Unlike StepMania we pass in a preloaded, ready-to-play, bit of music\n    public music: Howl | undefined;\n}\n\nexport class GameSoundManager {\n    // Singleton\n    public static getInstance() {\n        if (!GameSoundManager.instance) {\n            GameSoundManager.instance = new GameSoundManager();\n        }\n        return GameSoundManager.instance;\n    }\n    private static instance: GameSoundManager;\n\n    /** The music we're currently playing, if any. */\n    private musicPlaying: MusicPlaying | undefined;\n    /** Whether we are currently updating the song timer. When false we can pause / seek without\n     * things going wonky.\n     */\n    private updatingTimer = false;\n\n    /** The last processed beat that was crossed. An integer. */\n    private beatLastCrossed = 0;\n\n    /** Tracks the number of seconds we've been out of sync with the song for. If it\n     * exceeds a threshold then we will forcibly resync.\n     * This is necessary because the song timing updates are not frame-frequent.\n     */\n    private outOfSyncSecs = 0;\n\n    // Private constructor for singleton pattern\n    private constructor() {\n        // Nothing to do here\n    }\n\n    public pauseMusic() {\n        if (this.musicPlaying !== undefined) {\n            this.musicPlaying.music.pause();\n        }\n    }\n\n    public resumeMusic() {\n        if (this.musicPlaying !== undefined) {\n            this.musicPlaying.music.play();\n        }\n    }\n\n    public musicSeek(seekTimeSeconds: number) {\n        if (this.musicPlaying !== undefined) {\n            this.musicPlaying.music.seek(seekTimeSeconds);\n        }\n    }\n\n    public musicSkipforwards(seekTimeSeconds: number) {\n        if (this.musicPlaying !== undefined) {\n            const currentTimeSeconds = this.musicPlaying.music.getTimeElapsed();\n            this.musicPlaying.music.seek(currentTimeSeconds + seekTimeSeconds);\n        }\n    }\n\n    public getMusicTimeSeconds() {\n        if (this.musicPlaying !== undefined) {\n            return this.musicPlaying.music.getTimeElapsed();\n        }\n        return 0;\n    }\n\n    public getMusicTiming() {\n        if (this.musicPlaying !== undefined) {\n            return this.musicPlaying.timing;\n        }\n        return new TimingData();\n    }\n\n    public startMusic(toPlay: MusicToPlay) {\n        // TODO: have a gate at the top that stops us playing the same file twice\n\n        // Loading of music is taken care of elsewhere - it's already in memory\n        if (toPlay.music === undefined || toPlay.music.state() !== 'loaded') {\n            throw new Error('toPlay.music must be provided and loaded');\n        }\n        if (toPlay.timing === undefined) { throw new Error('toPlay.timing must be provided'); }\n        const newMusic = new MusicPlaying(toPlay.music, toPlay.timing);\n\n        // Omitted loop stuff from StepMania for now - we will need this eventually -Struz\n        // Currently stuff like 24h crapyard scent streams won't render\n\n        // If we have an active timer try to start on the next update. Otherwise, start now.\n        // TODO ^\n\n        newMusic.hasTiming = toPlay.hasTiming;\n        newMusic.music.seek(toPlay.startSeconds);\n        // TODO: support toPlay.lengthSeconds somehow\n        // TODO: support fade in / fade out\n        // TODO: support start times in the future which would be buffered with silence aka not playing.\n        //       see RageSoundDriver_Generic_Software.cpp:88\n        if (toPlay.forceLoop) {\n            newMusic.music.getSound().loop(true);\n        }\n\n        newMusic.music.play();\n        this.musicPlaying = newMusic;\n    }\n\n    public handleSongTimer(on: boolean) {\n        this.updatingTimer = on;\n    }\n    public isHandlingSongTimer() { return this.updatingTimer; }\n\n    // The idea here is to fake the sounds playing for now and just move the song position along\n    public update(deltaTime: number) {\n        if (!this.updatingTimer) { return; }\n\n        const playbackRate = 1.0;\n        // If we have some timing data then we can update the song position\n        // TODO: once we're past the end of the song probably stop doing this\n        if (GAMESTATE.curSong !== undefined) {\n            GAMESTATE.updateSongPosition(GAMESTATE.position.musicSeconds + deltaTime\n                    * playbackRate, GAMESTATE.curSong.songTiming);\n        }\n        // NOTE: the above is fudging and hoping, when actually playing music we *may* need to sync\n        // by getting the seconds from the song.\n\n        // Send crossed messages\n        if (GAMESTATE.curSong !== undefined) {\n            const songBeat = GAMESTATE.position.songBeat;\n            let rowNow = NoteHelpers.beatToNoteRowNotRounded(songBeat);\n            rowNow = Math.max(0, rowNow);\n\n            const beatNow = Math.trunc(rowNow / ROWS_PER_BEAT);  // int\n\n            for (let beat = this.beatLastCrossed + 1; beat <= beatNow; beat++) {\n                // TODO: Broadcast \"CrossedBeat\" message for all beats crossed since the last update\n                // Need some kind of message queue system but it's single threaded ...\n                // Will fire multiple itmes if multiple beats have been crossed due to lag.\n            }\n\n            this.beatLastCrossed = beatNow;\n        }\n\n        this.resyncSongTimingWithMusicPosition(deltaTime);\n    }\n\n    public resyncSongTimingWithMusicPosition(deltaTime: number, updateIfMusicNotPlaying = false) {\n        // If we've drifted too far from the song we need to speed up or slow down to meet it.\n        // Because nobody is actually playing the song we can just teleport forwards or backwards.\n        // If at any point people are actually playing we will need a more elegant method to sync\n        // back up.\n\n        // We don't want to do this unless the drift is signifiant or it could cause a lot of\n        // teleporting arrows.\n\n        // If we don't have anything to sync, bail out\n        if (GAMESTATE.curSong === undefined || this.musicPlaying === undefined) { return; }\n        // If the music isn't playing and we don't want to update if it's not playing, bail out\n        if (!this.musicPlaying.music.getSound().playing() && !updateIfMusicNotPlaying) { return; }\n\n        // TODO: work out if we should be using visible or regular here. I say regular because\n        // we do modifications on that to work out what to show with global offset etc etc -Struz\n        const musicPlayingPosSeconds = this.musicPlaying.music.getTimeElapsed();\n        const drift = Math.abs(musicPlayingPosSeconds - GAMESTATE.position.musicSeconds);\n        if (drift > MAX_TOLERATED_DRIFT_SECS) {\n            // console.log(`drifted: ${drift * 1000}ms`);\n            this.outOfSyncSecs += drift;\n\n            // If we've been drifted for too long, resync\n            if (this.outOfSyncSecs > DRIFT_SECS_BEFORE_UPDATE) {\n                this.outOfSyncSecs = 0;\n                // Always sync to the music rather than the other way around. It's less jarring.\n                GAMESTATE.updateSongPosition(musicPlayingPosSeconds, this.musicPlaying.timing);\n                console.log('resynced song to music');\n                // DebugTools.PAUSE();\n            }\n        } else {\n            this.outOfSyncSecs = 0;\n        }\n        // TODO: use averaging across update cycles to get the \"real\" song timing\n        // since the timing reported by media objects is not particularly accurate.\n        // We could also use literal timestamps i.e. Date, or resync from the startup\n        // GameTimer.\n    }\n}\nconst SOUNDMAN = GameSoundManager.getInstance();\nexport default SOUNDMAN;\n","import GAMESTATE from './GameState';\nimport SOUNDMAN from './GameSoundManager';\nimport { EXPECTED_FPS } from './GameConstantsAndTypes';\n\n// Debug helpers\n\n// Ideally we find a way to completely compile this out in certain builds\nexport function DEBUG_ASSERT(cond: boolean) {\n    if (!cond) {\n// tslint:disable-next-line: no-debugger\n        debugger;\n        console.debug('Debug assert failed.');\n        console.trace();\n    }\n}\n\nexport function ASSERT(cond: boolean, message: string) {\n    if (!cond) {\n        throw new Error(message);\n    }\n}\n\n// How to use the debug tools:\n// 1. Put a DebugTools.PAUSE() call where you would normally want a breakpoint.\n// 2. Use window.debugTools.FRAME_ADVANCE() to move forwards as you wish.\n// 3. Use breakpoints via the debugger to place a breakpoint before advancing.\nexport class DebugTools {\n    public static PAUSE() {\n        GAMESTATE.pause();\n        SOUNDMAN.pauseMusic();\n// tslint:disable-next-line: no-debugger\n        debugger;\n    }\n    public static PLAY() {\n        GAMESTATE.play();\n        SOUNDMAN.resumeMusic();\n    }\n    public static FRAME_ADVANCE(numFrames = 1) {\n        const timeAdvanceSeconds = numFrames * (1 / EXPECTED_FPS);\n        SOUNDMAN.musicSkipforwards(timeAdvanceSeconds);\n        GAMESTATE.updateSongPosition(SOUNDMAN.getMusicTimeSeconds(), SOUNDMAN.getMusicTiming());\n// tslint:disable-next-line: no-debugger\n        debugger;\n    }\n}\n","import TimingData, { GetBeatArgs } from './TimingData';\nimport { GameTimer } from './GameTimer';\nimport { ASSERT } from './Debug';\n\n// TODO: support delays and offsets?\nconst gVisualDelaySeconds = 0;\n\n/** Tracks how far through the song we are.\n *  Is basically a struct rather than a class.\n */\nexport class SongPosition {\n    public musicSeconds = 0;\n    public songBeat = 0;\n    public songBeatNoOffset = 0;\n    public curBps = 0;\n    /** A flag to determine if we're in the middle of a freeze/stop. */\n    public freeze = false;\n    /** A flag to determine if we're in the middle of a delay (Pump style stop). */\n    public delay = false;\n    /** The row used to start a warp. */\n    public warpBeginRow = 0;\n    /** The beat to warp to afterwards. */\n    public warpDestination = 0;\n    public lastBeatUpdate = new GameTimer(); // time of last this.songBeat etc. update\n    public musicSecondsVisible = -1;\n    public songBeatVisible = -1;\n\n    public reset() {\n        this.musicSecondsVisible = 0;\n        this.songBeatVisible = 0;\n\n        this.musicSeconds = 0;\n        // todo: move me to FOREACH_EnabledPlayer( p ) after [NUM_PLAYERS]ing\n        this.songBeat = 0;\n        this.songBeatNoOffset = 0;\n        this.curBps = 0;\n        this.freeze = false;\n        this.delay = false;\n        this.warpBeginRow = -1; // Set to -1 because some song may want to warp to row 0. -aj\n        this.warpDestination = -1; // Set when a warp is encountered. also see above. -aj\n    }\n\n    public updateSongPosition(positionSeconds: number, timing: TimingData, timestamp: GameTimer) {\n        if (!timestamp.isZero()) {\n            this.lastBeatUpdate = timestamp;\n        } else {\n            this.lastBeatUpdate.touch();\n        }\n\n        const beatInfo = new GetBeatArgs();\n        beatInfo.elapsedTime = positionSeconds;\n        timing.getBeatAndBpsFromElapsedTime(beatInfo);\n        this.songBeat = beatInfo.beat;\n        this.curBps = beatInfo.bpsOut;\n        this.freeze = beatInfo.freezeOut;\n        this.delay = beatInfo.delayOut;\n        this.warpBeginRow = beatInfo.warpBeginOut;\n        this.warpDestination = beatInfo.warpDestOut;\n\n        ASSERT(this.songBeat > -2000, `Song beat ${this.songBeat} at ${positionSeconds} is less than -2000`);\n\n        this.musicSeconds = positionSeconds;\n        // ignore light beat - we don't support lights -Struz\n        this.songBeatNoOffset = timing.getBeatFromElapsedTimeNoOffset(this.musicSecondsVisible);\n\n        // we don't support visual delay yet, clone the values -Struz\n        this.musicSecondsVisible = this.musicSeconds;\n        this.songBeatVisible = this.songBeat;\n    }\n}\nexport default SongPosition;\n","import SongPosition from './SongPosition';\nimport GAMESTATE from './GameState';\nimport { PlayerNumber } from './PlayerNumber';\n\n/** The player's individual state. */\nexport class PlayerState {\n    public playerNumber = PlayerNumber.PLAYER_1;\n    // Music statistics:\n    public position = new SongPosition();\n    // Stores the bpm that was picked for reading the chart if the player is using an mmod.\n    public readBPM = 0;\n\n    /** Update the player state based on the present time.\n     * @param delta The current time.\n     */\n    public update(delta: number) {\n        // This is all attack and mods stuff. We don't need it - Struz\n    }\n\n    public getDisplayedPosition() {\n        if (GAMESTATE.isUsingStepTiming) { return this.position; }\n        return GAMESTATE.position;\n    }\n\n    public getDisplayedTiming() {\n        const steps = GAMESTATE.curSteps[this.playerNumber];\n        // C++ code checked for undefined but we don't allow that here\n        return steps.timingData;\n    }\n}\nexport default PlayerState;\n","// Various errors that we throw\n\nexport class NotImplementedError extends Error {\n    constructor() {\n        super('Not yet implemented');\n    }\n}\n","import { PlayerNumber } from './PlayerNumber';\nimport TimingData from './TimingData';\nimport SongPosition from './SongPosition';\nimport { PlayerState } from './PlayerState';\nimport Helpers from './GameConstantsAndTypes';\nimport { GameTimer, gZeroTimer } from './GameTimer';\nimport { Steps } from './Steps';\nimport Song from './Song';\nimport { NotImplementedError } from './Error';\nimport SOUNDMAN, { MusicToPlay } from './GameSoundManager';\n\n\n/** Holds all the state about the game. A singleton. */\nexport class GameState {\n    // Global state from Actors.h, might need moving to another place\n    public static currentBgmTime = 0;\n    public static currentBgmBeat = 0;\n\n    public static currentBgmTimeNoOffset = 0;\n    public static currentBgmBeatNoOffset = 0;\n\n    public static currentBgmBeatPlayer: number[] = []; // Max entries is PlayerNumber.NUM\n    public static currentBgmBeatPlayerNoOffset: number[] = []; // Max entries is PlayerNumber.NUM\n    // End global state from Actors\n\n    // public static MUSIC_SECONDS_INVALID = -5000;\n\n    // Singleton\n    public static getInstance() {\n        if (!GameState.instance) {\n            GameState.instance = new GameState();\n        }\n        return GameState.instance;\n    }\n    private static instance: GameState;\n\n    // The currently playing song, if any\n    public curSong: Song | undefined;\n    // curSong.songTiming has the timing data we care about\n\n    // Stuff used in gameplay, they mean nothing if curSong is undefined\n    public curSteps: Steps[]; // One index per player; A broadcast on change pointer in C++\n    public position: SongPosition = new SongPosition();\n\n    public hasteRate: number;\n\n    // Options stuff (mods)\n    // public songOptions: SongOptions;\n\n    // PlayerState\n    /** Allow access to each player's PlayerState. */\n    public playerState: PlayerState[];\n\n    /**\n     * Is the game right now using Song timing or Steps timing?\n     * Different options are available depending on this setting.\n     */\n    // Default to the song timing UNLIKE STEPMANIA. This is because\n    // we haven't perfected the pass through chain to steps yet. -Struz\n    public isUsingStepTiming = false;\n\n\n    // Timing position corrections\n    private lastPositionTimer = new GameTimer();\n    private lastPositionSeconds = 0;\n    private paused = false;\n\n    private constructor() {\n        this.curSteps = [];\n\n        this.playerState = [];\n        for (const pn of Helpers.forEachEnum(PlayerNumber)) {\n            this.playerState[pn] = new PlayerState();\n            // this.playerState[pn].setPlayerNumber(pn);\n        }\n        this.hasteRate = 1.0;\n\n        this.reset();\n    }\n\n    /** Reset the game state. */\n    public reset() {\n        this.paused = false;\n    }\n\n    /** All the logic involved with loading a new song. */\n    public loadNextSong(newSong: Song | undefined) {\n        this.pause();\n        SOUNDMAN.pauseMusic();\n        this.resetMusicStatistics();\n        if (newSong === undefined) {\n            return;\n        }\n\n        this.setCurSong(newSong);\n        // IMPORTANT: make the primitives and stuff?\n        // Screen.setupSong()\n        // Sets steps display\n    }\n\n    /** Change the current song. */\n    public setCurSong(newSong: Song | undefined) {\n        if (this.curSong !== undefined) {\n            // TODO: release lookup data for the old song\n            this.curSong.songTiming.releaseLookup();\n        }\n        console.log('changed song!');\n        this.curSong = newSong;\n        // TODO: broadcast song has changed.\n        if (this.curSong !== undefined) {\n            // TODO: request lookup data for the new song\n            this.curSong.songTiming.prepareLookup();\n        }\n    }\n\n    public play() { SOUNDMAN.handleSongTimer(true); }\n\n    public pause() { SOUNDMAN.handleSongTimer(false); }\n    public isPaused() { return !SOUNDMAN.isHandlingSongTimer(); }\n\n    /** Update the game state.\n     * @param delta The time that has passed since the last update.\n     */\n    public update(delta: number) {\n        // FOREACH_PlayerNumber\n        // TODO: fix this, just p1 for now\n        this.playerState[0].update(delta);\n    }\n\n    public resetMusicStatistics() {\n        this.position.reset();\n        this.lastPositionTimer.touch();\n        this.lastPositionSeconds = 0;\n\n        this.setBgmTime(0, 0, 0, 0);\n        // FOREACH_PlayerNumber\n        // TODO: fix\n        this.playerState[0].position.reset();\n    }\n\n    public getSongPercent(beat: number) {\n        throw new NotImplementedError();\n    }\n\n    public setBgmTime(time: number, beat: number, timeNoOffset: number, beatNoOffset: number) {\n        GameState.currentBgmTime = time;\n        GameState.currentBgmBeat = beat;\n\n        /* This timer is generally only used for effects tied to the background music\n         * when GameSoundManager is aligning music beats.  Alignment doesn't handle\n         * g_fVisualDelaySeconds. */\n        GameState.currentBgmTimeNoOffset = timeNoOffset;\n        GameState.currentBgmBeatNoOffset = beatNoOffset;\n    }\n\n    public setPlayerBgmBeat(pn: PlayerNumber, beat: number, beatNoOffset: number) {\n        GameState.currentBgmBeatPlayer[pn] = beat;\n        GameState.currentBgmBeatPlayerNoOffset[pn] = beatNoOffset;\n    }\n\n    public updateSongPosition(positionSeconds: number, timing: TimingData, timestamp: GameTimer = gZeroTimer) {\n        /* It's not uncommon to get a lot of duplicated positions from the sound\n         * driver, like so: 13.120953,13.130975,13.130975,13.130975,13.140998,...\n         * This causes visual stuttering of the arrows. To compensate, keep a\n         * RageTimer since the last change. */\n        if (positionSeconds === this.lastPositionSeconds && !this.paused) {\n            positionSeconds += this.lastPositionTimer.ago();\n        } else {\n            this.lastPositionTimer.touch();\n            this.lastPositionSeconds = positionSeconds;\n        }\n\n        // If we were paused then positionSeconds will be the same as before, so the following\n        // updateSongPosition calls will be a no-op\n        this.position.updateSongPosition(positionSeconds, timing, timestamp);\n\n        // TODO: fixme to be a FOREACH_EnabledPlayer\n        // Just do p1 for now\n        const pn = 0;\n        if (this.curSteps.length) {\n            this.playerState[pn].position.updateSongPosition(positionSeconds,\n                this.curSteps[pn].timingData, timestamp);\n            this.setPlayerBgmBeat(pn, this.playerState[pn].position.songBeatVisible,\n                this.playerState[pn].position.songBeatNoOffset);\n        }\n        this.setBgmTime(GAMESTATE.position.musicSecondsVisible,\n            this.position.songBeatVisible,\n            positionSeconds,\n            this.position.songBeatNoOffset);\n    }\n\n    /**\n     * Takes an already created Song and Howl and sets up the game ready to play them.\n     * @param songData the Song to play.\n     * @param songMusic the created Howl representing the sound file.\n     * @param seek number of seconds to start playing at.\n     */\n    public loadSong(songData: Song, songMusic: Howl, seek?: number) {\n        // TODO: IMPORTANT: write functions to ensure that a Song is loaded before we play the Music\n        // See PlayMusic() in C++ for an example.\n        this.loadNextSong(songData);\n\n        const toPlay = new MusicToPlay();\n        toPlay.music = songMusic;\n        toPlay.hasTiming = true;\n        toPlay.timing = songData.songTiming;\n        if (seek !==  undefined) {\n            toPlay.startSeconds = seek;\n        }\n        GAMESTATE.play();\n        // TODO: don't always immediately start the song, have an init function instead\n        SOUNDMAN.startMusic(toPlay);\n    }\n}\nconst GAMESTATE = GameState.getInstance();\nexport default GAMESTATE;\n","import SongPosition from './SongPosition';\nimport GAMESTATE from './GameState';\nimport { PassByRef } from './GameConstantsAndTypes';\n\ninterface CacheDisplayedBeat {\n    beat: number;\n    displayedBeat: number;\n    velocity: number;\n}\n\ninterface CacheNoteStat {\n    beat: number;\n    notesLower: number; // int\n    notesUpper: number; // int\n}\n\n// Not quite sure what this does but it seems theme related -Struz\nconst ARROW_SPACING = 1;\n\n/** Functions that return properties of arrows based on Style and PlayerOptions. */\nclass ArrowEffects {\n    /**\n     * Holds a vector sorted by real beat, the beat that would be displayed\n     * in the NoteField (because they are affected by scroll segments), and\n     * also the velocity.\n     * This vector will be populated on Player::Load() be used a lot in\n     * ArrowEffects to determine the target beat in O(log N).\n     */\n    public static displayedBeatCache: CacheDisplayedBeat[] = [];\n    /** Holds a vector sorted by beat, the cumulative number of notes from\n     * the start of the song.\n     */\n    public static noteStatCache: CacheNoteStat[] = [];\n\n    // OPTIONS - may need to move these to another class later\n    /* All floats have a corresponding speed setting, which determines how fast\n    * PlayerOptions::Approach approaches. */\n    /** timeSpacing of 0 means cmod, mmod as we are using beat instead of time. */\n    public static timeSpacing = 0;\n    public static maxScrollBpm = 0;  // What happens if we set this > 0? -Struz\n    // next two used if !timeSpacing (xMods)\n    public static scrollSpeed = 220;  // This seems to have an overcentralising effect. FIXME: -Struz\n    public static speedScrollSpeed = 1;\n    // next two used it timeSpacing (CMod)\n    public static scrollBpm = 1000;\n    public static speedScrollBpm = 1;\n\n    // Next one was on PlayerState for some reason\n    /** Stores the bpm that was picked for reading the chart if the player is using an mmod. */\n    public static readBpm = 400;\n\n    /* For visibility testing: if bAbsolute is false, random modifiers must return\n     * the minimum possible scroll speed. */\n    public static getYOffset(\n        noteBeat: number, peakYOffsetOut: PassByRef<number>,\n        isPastPeakOut: PassByRef<boolean>) {\n\n        // Fail fast if no song\n        if (GAMESTATE.curSong === undefined) { return 0; }\n\n        peakYOffsetOut.value = Number.MAX_VALUE;\n        isPastPeakOut.value = true;\n\n        let yOffset = 0;\n        const position = GAMESTATE.position; // TODO: get position from args\n\n        const songBeat = position.songBeatVisible;\n        const curSteps = GAMESTATE.curSong.getSteps(0); // TODO: use a proper index\n        // curSteps is unused for now as we're just relying on song timing\n        const timingData = GAMESTATE.curSong.songTiming;\n\n        /* Usually, timeSpacing is 0 or 1, in which case we use entirely beat spacing or\n         * entirely time spacing (respectively). Occasionally, we tween between them. */\n        if (this.timeSpacing !== 1) {\n            // !== 1 means cmod, mmod\n            // No editor, no constant spacing\n            yOffset = ArrowEffects.getDisplayedBeat(noteBeat) - ArrowEffects.getDisplayedBeat(songBeat);\n            yOffset *= timingData.getDisplayedSpeedPercent(position.songBeatVisible, position.musicSecondsVisible);\n            yOffset *= 1 - this.timeSpacing;\n        }\n\n        if (this.timeSpacing !== 0) {\n            // !== 0 means xmod\n            const songSeconds = GAMESTATE.position.musicSecondsVisible;\n            const noteSeconds = timingData.getElapsedTimeFromBeat(noteBeat);\n            // DEBUGGING: the song is literally ahead of the beat here, hence why we have the weird shit\n            // happening. Why is it not looking ahead properly?\n            const secondsUntilStep = noteSeconds - songSeconds;\n            const bpm = this.scrollBpm;\n            const bps = (bpm / 60); // If we support music rate we need to divide by it here\n            const yOffsetTimeSpacing = secondsUntilStep * bps;\n            yOffset += yOffsetTimeSpacing * this.timeSpacing;\n        }\n        yOffset *= ARROW_SPACING;\n\n        // Factor in scroll speed\n        let scrollSpeed = this.scrollSpeed;\n        if (this.maxScrollBpm !== 0) {\n            scrollSpeed = this.maxScrollBpm / (this.readBpm * 1); // If we support music rate change the 1 here\n        }\n\n        if (yOffset < 0) {\n            return yOffset * scrollSpeed;\n        }\n        yOffset *= scrollSpeed;\n        peakYOffsetOut.value *= scrollSpeed;\n        return yOffset;\n        // Below here was special options for mods, ignored\n    }\n\n    public static getDisplayedBeat(beat: number) {\n        // binary search\n        const data = ArrowEffects.displayedBeatCache;\n        const max = data.length - 1;\n        let l = 0;\n        let r = max;\n        while (l <= r) {\n            const m = Math.trunc((l + r) / 2); // int\n            if ((m === 0 || data[m].beat <= beat) && (m === max || beat < data[m + 1].beat)) {\n                return data[m].displayedBeat + data[m].velocity * (beat - data[m].beat);\n            } else if (data[m].beat <= beat) {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        return beat;\n    }\n}\nexport default ArrowEffects;\n","import NoteHelpers, { NoteType } from '../NoteTypes';\nimport { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN, directionToLaneIndex } from './EntitiesConstants';\nimport RESOURCEMAN, { DOWN_TAP_NOTE_SHEET_NAME } from '../ResourceManager';\nimport AnimatedGameSprite from './AnimatedGameSprite';\nimport ArrowEffects from '../ArrowEffects';\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\nimport GameSprite from './GameSprite';\n\nconst NOTESKIN = 'USWCelETT';\n\nclass TapNoteSprite extends AnimatedGameSprite {\n    private direction: TapNoteDirection;\n    private noteType: NoteType;\n    private noteBeat: number;\n\n\n    /** Create a new tap note sprite.\n     * @param direction the direction the arrow should go in.\n     * @param noteBeat the beat the note lands on.\n     */\n    constructor(direction: TapNoteDirection, noteBeat: number) {\n        GameSprite.checkDependencies();\n        let noteType = NoteHelpers.beatToNoteType(noteBeat);\n        if (noteType === NoteType.N_192ND) {\n            // 192nd notes use the same sprite as 64th notes anyway\n            noteType = NoteType.N_64TH;\n        }\n        super(RESOURCEMAN.getSpriteInfo(DOWN_TAP_NOTE_SHEET_NAME), noteType);\n\n        this.direction = direction;\n        this.noteType = noteType;\n        this.noteBeat = noteBeat;\n\n        // Set the rotation based on the direction, using the down arrow as a reference\n        this.sprite.rotation = (90 * this.direction) * (Math.PI / 180);\n\n        // Set the x based on the note track\n        const laneIndex = directionToLaneIndex(this.direction);\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\n        this.setYPosBasedOnBeat();\n\n        // Ensure it starts animated\n        this.sprite.play();\n    }\n\n    public getDirection() { return this.direction; }\n    public getNoteType() { return this.noteType; }\n    public getBeat() { return this.noteBeat; }\n\n    public update(deltaTime: number) {\n        // // 1 / 60 = 0.016 is when we move 3 px per frame. More than this and we move more, less and we move less.\n        // // Multiply by FPS (60) to get the amount to move (more or less).\n        // const movement = 3 * (deltaTime * 60);\n        // this.sprite.y += movement;\n        // this.sprite.y = 400; // TODO: base this off the beat the note is on so we can just create notes @ beats\n        this.setYPosBasedOnBeat();\n        return this;\n    }\n\n    private setYPosBasedOnBeat() {\n        const peakYOffset = {value: 0};\n        const isPastPeakOut = {value: false};\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\n        // and we want it synced to the receptors.\n        this.sprite.y = ArrowEffects.getYOffset(this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\n    }\n}\nexport default TapNoteSprite;\n","import { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN, directionToLaneIndex } from './EntitiesConstants';\nimport RESOURCEMAN, { TAP_MINE_SHEET_NAME } from '../ResourceManager';\nimport AnimatedGameSprite from './AnimatedGameSprite';\nimport ArrowEffects from '../ArrowEffects';\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\nimport GameSprite from './GameSprite';\n\nconst NOTESKIN = 'USWCelETT';\n\nclass TapMineSprite extends AnimatedGameSprite {\n    private direction: TapNoteDirection;  // Used for x position\n    private noteBeat: number;\n\n\n    /** Create a new mine sprite.\n     * @param direction the direction the arrow should go in.\n     * @param noteBeat the beat the mine lands on.\n     */\n    constructor(direction: TapNoteDirection, noteBeat: number) {\n        GameSprite.checkDependencies();\n        super(RESOURCEMAN.getSpriteInfo(TAP_MINE_SHEET_NAME), 0);\n\n        this.direction = direction;\n        this.noteBeat = noteBeat;\n\n        // Set the x based on the note track\n        const laneIndex = directionToLaneIndex(this.direction);\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\n        this.setYPosBasedOnBeat();\n\n        // Ensure it starts animated\n        this.sprite.play();\n    }\n\n    public getDirection() { return this.direction; }\n    public getBeat() { return this.noteBeat; }\n\n    public update(deltaTime: number) {\n        // // 1 / 60 = 0.016 is when we move 3 px per frame. More than this and we move more, less and we move less.\n        // // Multiply by FPS (60) to get the amount to move (more or less).\n        // const movement = 3 * (deltaTime * 60);\n        // this.sprite.y += movement;\n        // this.sprite.y = 400; // TODO: base this off the beat the note is on so we can just create notes @ beats\n        this.setYPosBasedOnBeat();\n        return this;\n    }\n\n    // TODO: find a way to generalise this beat pos stuff across everything\n    // that needs it\n\n    // TODO: mines look silly when they disappear at the arrows - fix this\n\n    private setYPosBasedOnBeat() {\n        const peakYOffset = {value: 0};\n        const isPastPeakOut = {value: false};\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\n        // and we want it synced to the receptors.\n        this.sprite.y = ArrowEffects.getYOffset(this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\n    }\n}\nexport default TapMineSprite;\n","import * as PIXI from 'pixi.js';\nimport Entity from './Entity';\n\nimport GameSprite, { Drawable } from './GameSprite';\nimport { TapNoteDirection, directionToLaneIndex,\n    LANE_MARGIN, TAPNOTE_WIDTH_PX, HOLD_BOTTOM_CAP_HEIGHT_PX } from './EntitiesConstants';\nimport { GameSpriteInfo } from '../ResourceManager';\nimport ArrowEffects from '../ArrowEffects';\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\n\n// Base class for long note types like holds & rolls.\n// Represents the tail portion of a long note. The head is still a TapNote.\n// It is an entity of its own, with sub-entities that are sprites.\nclass BodyAndCapNote extends Entity implements Drawable {\n    /** The direction of the arrow at the head of the long note. */\n    protected direction: TapNoteDirection;\n    /** The beat the head of this long note lands on. */\n    protected noteBeat: number;\n    /** The duration of this long note in beats. */\n    protected duration: number;\n\n    /** The sprite showing the tiling area of really long notes. */\n    protected bodyTilingSprite: GameSprite[] | undefined;\n    /** The sprite showing the beginning of the body of the long note. */\n    protected bodySprite: GameSprite;\n    /** The sprite showing the bottom of the long note. */\n    protected bottomCapSprite: GameSprite;\n\n    /** Are we a candidate for rendering? */\n    private onStage: boolean;\n    /** The Y height of the long note. */\n    private height: number;\n\n    /**\n     * @param direction the direction of the arrow at the head of the long note.\n     * @param noteBeat the beat the head of this long note lands on.\n     * @param duration the duration of the long note in beats.\n     */\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number,\n                       bodySpriteInfo: GameSpriteInfo, capSpriteInfo: GameSpriteInfo) {\n        super();\n        this.direction = direction;\n        this.noteBeat = noteBeat;\n        this.duration = duration;\n        this.onStage = false;\n\n        // We anchor to the top of the hold, but the middle of the cap, so do some maths\n        // to make them line up. This height does not include to the tip of the cap.\n        this.height = this.calculateLongNoteHeight();\n\n        // Work out the dimensions for the first segment of the long note. Often this\n        // will be all we need to display it fully. This segment is special because\n        // it starts drawing the texture from part way down, so that it will always\n        // line up with the texture of the bottom cap.\n        let firstBodySegmentTexStartY = 0;\n        let firstBodySegmentTexHeight = 0;\n        firstBodySegmentTexStartY = bodySpriteInfo.height - (this.height % bodySpriteInfo.height);\n        firstBodySegmentTexHeight = bodySpriteInfo.height - firstBodySegmentTexStartY;\n\n        // If we can't fit the long note entirely into the first section then we need a tiling section.\n        if (this.height > bodySpriteInfo.height) {\n            this.bodyTilingSprite = [];\n\n            let remainingHeight = this.height - firstBodySegmentTexHeight;\n            while (remainingHeight > 0) {\n                const segmentHeight = Math.min(remainingHeight, bodySpriteInfo.height);\n                let bodySegmentTex: PIXI.Texture;\n                if (segmentHeight === bodySpriteInfo.height) {\n                    bodySegmentTex = bodySpriteInfo.textures[0][0];\n                } else {\n                    // Only create new textures for custom dimensions\n                    bodySegmentTex = new PIXI.Texture(\n                        bodySpriteInfo.textures[0][0].baseTexture,\n                        new PIXI.Rectangle(0, 0, bodySpriteInfo.width, segmentHeight),\n                    );\n                }\n                const bodySegmentSprite = new PIXI.Sprite(bodySegmentTex);\n                this.bodyTilingSprite.push(new GameSprite(bodySegmentSprite));\n\n                remainingHeight -= segmentHeight;\n            }\n        }\n\n        // Create the first (and sometimes only) segment of the body sprite\n        const bodySpriteTex = new PIXI.Texture(\n            bodySpriteInfo.textures[0][0].baseTexture,\n            new PIXI.Rectangle(\n                0, firstBodySegmentTexStartY,\n                bodySpriteInfo.width, firstBodySegmentTexHeight,\n            ));\n        const bodySprite = new PIXI.Sprite(bodySpriteTex);\n        this.bodySprite = new GameSprite(bodySprite);\n        // Create the cap\n        const bottomCapSprite = new PIXI.Sprite(capSpriteInfo.textures[0][0]);\n        this.bottomCapSprite = new GameSprite(bottomCapSprite);\n\n        // Configure the sprite positions after creating the GameSprites in case their\n        // constructor does anything funky to the sprites.\n\n        // Set the x based on the note track\n        const laneIndex = directionToLaneIndex(this.direction);\n        const laneX = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\n        bodySprite.x = laneX;\n        if (this.bodyTilingSprite !== undefined) {\n            this.bodyTilingSprite.forEach((gs) => gs.getSprite().x = laneX);\n        }\n        bottomCapSprite.x = laneX;\n\n        // Make sure we anchor the Y to the top of each component so we have an easy time\n        // with maths.\n        bodySprite.anchor.y = 0;\n        if (this.bodyTilingSprite !== undefined) {\n            this.bodyTilingSprite.forEach((gs) => gs.getSprite().anchor.y = 0);\n        }\n        bottomCapSprite.anchor.y = 0;\n\n        this.updateSprites();\n    }\n\n    public destroy() {\n        this.removeFromStage();\n        super.destroy();\n    }\n\n    public isOnStage() { return this.onStage; }\n    public addToStage() {\n        if (this.onStage) { return this; }\n\n        this.onStage = true;\n        // It is very important that the bottom cap is added first\n        // If Z indexing is disabled this is the only way to ensure it draws below.\n        this.bottomCapSprite.addToStage();\n        if (this.bodyTilingSprite !== undefined) {\n            this.bodyTilingSprite.forEach((gs) => gs.addToStage());\n        }\n        this.bodySprite.addToStage();\n        return this;\n    }\n    public removeFromStage() {\n        if (!this.onStage) { return this; }\n\n        this.onStage = false;\n        this.bottomCapSprite.removeFromStage();\n        if (this.bodyTilingSprite !== undefined) {\n            this.bodyTilingSprite.forEach((gs) => gs.removeFromStage());\n        }\n        this.bodySprite.removeFromStage();\n        return this;\n    }\n\n    public update(deltaTime: number): this {\n        this.updateSprites();\n        return this;\n    }\n\n    private calculateLongNoteHeight() {\n        const peakYOffset = {value: 0};\n        const isPastPeakOut = {value: false};\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\n        // and we want it synced to the receptors.\n        const headYPos = ArrowEffects.getYOffset(\n            this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\n        const capYPos = ArrowEffects.getYOffset(\n            this.noteBeat + this.duration,\n            peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\n        // Because we anchor to the top of the bottom cap we need to subtract half the height\n        // to get it to line up with where it should be placed.\n        return capYPos - headYPos - (HOLD_BOTTOM_CAP_HEIGHT_PX / 2);\n    }\n\n    private updateSprites() {\n        const peakYOffset = {value: 0};\n        const isPastPeakOut = {value: false};\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\n        // and we want it synced to the receptors.\n        const headYPos = ArrowEffects.getYOffset(\n            this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\n\n        // Add the non tiling part of the sprite directly at the top\n        const bodySprite = this.bodySprite.getSprite();\n        bodySprite.y = headYPos;\n\n        // If applicable, update the tiling portion\n        if (this.bodyTilingSprite !== undefined) {\n            let tilingPosY = headYPos + bodySprite.height;\n            this.bodyTilingSprite.forEach((gs) => {\n                gs.getSprite().y = tilingPosY;\n                tilingPosY += gs.getSprite().height;\n            });\n        }\n\n        this.bottomCapSprite.setPosY(headYPos + this.height);\n    }\n}\nexport default BodyAndCapNote;\n","import BodyAndCapNote from './BodyAndCapNote';\nimport { TapNoteDirection } from './EntitiesConstants';\nimport RESOURCEMAN, {\n    DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME,\n    DOWN_HOLD_BODY_INACTIVE_SHEET_NAME } from '../ResourceManager';\n\nclass HoldTailSprite extends BodyAndCapNote {\n    /**\n     * @param direction the direction of the arrow at the head of the hold.\n     * @param noteBeat the beat the head of this hold tail lands on.\n     * @param duration the duration of the hold in beats.\n     */\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number) {\n        const bodySpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_HOLD_BODY_INACTIVE_SHEET_NAME);\n        const capSpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME);\n        super(direction, noteBeat, duration, bodySpriteInfo, capSpriteInfo);\n    }\n}\nexport default HoldTailSprite;\n","import BodyAndCapNote from './BodyAndCapNote';\nimport { TapNoteDirection } from './EntitiesConstants';\nimport RESOURCEMAN, {\n    DOWN_ROLL_BODY_INACTIVE_SHEET_NAME,\n    DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME} from '../ResourceManager';\n\n// This is different from HoldTailSprite because when we add the active portions\n// it will need to be animated.\n// The current plan is to do this by quick switching the visibility of the 4 sprites.\n// .destroy() will need to be overloaded to cleanup the non active sprites, but the\n// active ones can be left to the parent.\nclass RollTailSprite extends BodyAndCapNote {\n    /**\n     * @param direction the direction of the arrow at the head of the hold.\n     * @param noteBeat the beat the head of this hold tail lands on.\n     * @param duration the duration of the hold in beats.\n     */\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number) {\n        // TODO: for some reason the roll body has an extra pixel at the bottom. Cut it off.\n        // TODO: also, we can't use the same trick as with the holds to flip the Y index because\n        //       this one actually needs to point up. We need to find a way to anchor at the bottom and\n        //       draw up.\n        // Might have to go back to calculating the size and then hiding the top part.\n        // So what is drawing in reverse actually doing?\n        // - Flips UVs\n        // - So that drawing happens.\n\n        // If the roll/hold is < the height of the original, we need to set the UVs such that we\n        // start drawing midway down. We can do that by clamping the texture at creation.\n        // If the roll/hold is > the height of the original, we do some very slight scale adjustments\n        // to get them to line up without needing to do weird UV stuff on the final leg.\n        // UV stuff on the final tile would be the best solution, of course.\n\n        // What we could do is use tiling sprite for multiples of the height then do the UV\n        // adjustment for the final piece. This is probably the best overall solution, but\n        // the most code change.\n        const bodySpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_ROLL_BODY_INACTIVE_SHEET_NAME);\n        const capSpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME);\n        super(direction, noteBeat, duration, bodySpriteInfo, capSpriteInfo);\n    }\n}\nexport default RollTailSprite;\n","import Entity from './Entity';\nimport GAMESTATE from '../GameState';\nimport ArrowEffects from '../ArrowEffects';\nimport NoteHelpers, { TapNoteType, TapNoteSubType } from '../NoteTypes';\nimport TapNoteSprite from './TapNoteSprite';\nimport { laneIndexToDirection } from './EntitiesConstants';\nimport TapMineSprite from './TapMineSprite';\nimport GameSprite, { Drawable } from './GameSprite';\nimport HoldTailSprite from './HoldTailSprite';\nimport RollTailSprite from './RollTailSprite';\n\n// The note tracks can hold any drawable note\ntype DrawableNoteSprite = Drawable;\n\nclass NoteTrackData {\n    /** The tap notes and the note rows they land on. */\n    public tapNotes: Map<number, DrawableNoteSprite>;\n    /** The end points of holds. Required so we can cull holds when they end. */\n    public holdCaps: Map<number, DrawableNoteSprite>;\n\n    constructor() {\n        this.tapNotes = new Map();\n        this.holdCaps = new Map();\n    }\n}\n\n/** The note field. Doesn't inherently draw anything itself\n *  but controls other entities which are drawn.\n */\nclass NoteField extends Entity {\n    // TODO: Eventually optimise this into a genericized vesion of TrackMap.\n    // Map is keyed as noteRow=>TapNoteSprite\n    /** One map of note rows to the sprites they draw for each note track. */\n    private noteTracks: NoteTrackData[];\n\n    constructor() {\n        super();\n        this.noteTracks = [];\n        this.resetTracks(4);\n    }\n\n    public resetTracks(numTracks: number) {\n        // Cleanup any old notes\n        for (const track of this.noteTracks) {\n            for (const tn of track.tapNotes) {\n                tn[1].destroy();\n            }\n            for (const tn of track.holdCaps) {\n                tn[1].destroy();\n            }\n        }\n\n        // Reset the tracks\n        this.noteTracks = [];\n        for (let i = 0; i < numTracks; i++) {\n            this.noteTracks.push(new NoteTrackData());\n        }\n    }\n\n    public findFirstDisplayedBeat(drawDistanceAfterTargetsPixels: number) {\n        const songBeat = GAMESTATE.position.songBeat;\n\n        let low = 0;\n        let high = songBeat;\n\n        // I'm not sure what the cache does. TODO: work it out -Struz\n        const hasCache = ArrowEffects.noteStatCache.length !== 0;\n        if (!hasCache) {\n            low = high - 4;  // Only scan one measure of 4/4 for performance?? -Struz\n        }\n\n        const NUM_ITERATIONS = 24;\n        const MAX_NOTES_AFTER = 64;\n\n        let firstBeatToDraw = low;\n\n        // This looks like some kind of beat-and-iteration-bounded binary search -Struz\n        for (let i = 0; i < NUM_ITERATIONS; i++) {\n            const mid = (low + high) / 2; // float (because it's a beat)\n\n            const isPastPeakYOffset = {value: false};\n            const peakYOffset = {value: 0};\n            const yOffset = ArrowEffects.getYOffset(mid, peakYOffset, isPastPeakYOffset);\n\n            if (yOffset < drawDistanceAfterTargetsPixels ||\n                (hasCache && this.getNumNotesRange(mid, songBeat) > MAX_NOTES_AFTER)) {\n\n                // off screen / too many notes\n                firstBeatToDraw = mid; // move towards songBeat\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n        return firstBeatToDraw;\n    }\n\n    public findLastDisplayedBeat(drawDistanceBeforeTargetsPixels: number) {\n        // Fail fast if no song timing\n        if (GAMESTATE.curSong === undefined) { return 0; }\n\n        const displayedPosition = GAMESTATE.position;\n        const displayedTiming = GAMESTATE.curSong.songTiming;\n        // Probe for last note to draw. Worst case is 0.25x + boost.\n        // Adjust search distance so that notes don't pop onto the screen.\n        let searchDistance = 10;\n        let lastBeatToDraw = displayedPosition.songBeat + searchDistance;\n        const speedMultiplier = displayedTiming.getDisplayedSpeedPercent(\n            displayedPosition.songBeatVisible, displayedPosition.musicSecondsVisible);\n\n        const NUM_ITERATIONS = 20;\n\n        for (let i = 0; i < NUM_ITERATIONS; i++) {\n            const isPastPeakYOffset = {value: false};\n            const peakYOffset = {value: 0};\n            const yOffset = ArrowEffects.getYOffset(lastBeatToDraw, peakYOffset, isPastPeakYOffset);\n\n            if (yOffset > drawDistanceBeforeTargetsPixels) { // off screen\n                lastBeatToDraw -= searchDistance;\n            } else { // on screen\n                lastBeatToDraw += searchDistance;\n            }\n            searchDistance /= 2;\n        }\n\n        if (speedMultiplier < 0.75) {\n            lastBeatToDraw = Math.min(lastBeatToDraw, displayedPosition.songBeat + 16);\n        }\n        return lastBeatToDraw;\n    }\n\n    public getNumNotesFromBeginning(beat: number) {\n        // binary search\n        const data = ArrowEffects.noteStatCache;\n        const max = data.length - 1;\n        let l = 0;\n        let r = max;\n        while (l <= r) {\n            const m = Math.trunc((l + r) / 2); // int\n            if ((m === 0 || data[m].beat <= beat) && (m === max || beat < data[m + 1].beat)) {\n                return data[m];\n            } else if (data[m].beat <= beat) {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n        return {beat: 0, notesLower: 0, notesUpper: 0};\n    }\n\n    public getNumNotesRange(low: number, high: number) {\n        const noteStatLow = this.getNumNotesFromBeginning(low);\n        const noteStatHigh = this.getNumNotesFromBeginning(high);\n        return noteStatHigh.notesUpper - noteStatLow.notesLower;\n    }\n\n    public updateNotes(deltaTime: number) {\n        // Fail fast if no song\n        if (GAMESTATE.curSong === undefined) { return this; }\n        const songBeat = GAMESTATE.position.songBeatVisible;\n\n        const PIXELS_TO_DRAW_OFFSCREEN = 1000;\n        const firstBeatToDraw = this.findFirstDisplayedBeat(PIXELS_TO_DRAW_OFFSCREEN);\n        const lastBeatToDraw = this.findLastDisplayedBeat(PIXELS_TO_DRAW_OFFSCREEN);\n\n        const firstRow = NoteHelpers.beatToNoteRow(firstBeatToDraw);\n        const lastRow = NoteHelpers.beatToNoteRow(lastBeatToDraw);\n\n        // TODO: draw beat bars?\n\n        // We use a direct loop here so we can access the data immediately but the abstraction\n        // is lost. Build a generic version of this efficient abstraction somewhere.\n\n        // TODO: fix steps index below and replace with actual steps index when we have it later\n        const nd = GAMESTATE.curSong.getSteps(0).getNoteData();\n        for (let t = 0; t < nd.tapNotes.length; t++) {\n            for (const tnEntry of nd.tapNotes[t]) {\n                // IMPORTANT: this array MUST be ordered or this continue/break logic won't work.\n                if (tnEntry[0] < firstRow) { continue; }\n                if (tnEntry[0] > lastRow) { break; }\n                if (tnEntry[1].type !== TapNoteType.Tap &&\n                    tnEntry[1].type !== TapNoteType.HoldHead &&\n                    tnEntry[1].type !== TapNoteType.Mine) { continue; }\n\n                // If we don't have the note already, create it\n                if (this.noteTracks[t].tapNotes.has(tnEntry[0])) { continue; }\n\n                const beat = NoteHelpers.noteRowToBeat(tnEntry[0]);\n                const direction = laneIndexToDirection(t);\n                let tnSprite: GameSprite;\n                switch (tnEntry[1].type) {\n                    case TapNoteType.Tap:\n                        tnSprite = new TapNoteSprite(\n                            direction,\n                            beat,\n                        );\n                        break;\n\n                    case TapNoteType.HoldHead:\n                        tnSprite = new TapNoteSprite(\n                            direction,\n                            beat,\n                        );\n                        let tailSprite: HoldTailSprite | RollTailSprite | undefined;\n                        if (tnEntry[1].subType === TapNoteSubType.Hold) {\n                            tailSprite = new HoldTailSprite(\n                                direction,\n                                beat,\n                                NoteHelpers.noteRowToBeat(tnEntry[1].duration),\n                            );\n                        } else {\n                            tailSprite = new RollTailSprite(\n                                direction,\n                                beat,\n                                NoteHelpers.noteRowToBeat(tnEntry[1].duration),\n                            );\n                        }\n                        this.noteTracks[t].holdCaps.set(tnEntry[0], tailSprite.addToStage());\n                        break;\n\n                    case TapNoteType.Mine:\n                        tnSprite = new TapMineSprite(\n                            direction,\n                            beat,\n                        );\n                        break;\n                    default:\n                        throw new Error(`Unprocessable TapNoteType encountered: ${tnEntry[1].type}`);\n                }\n                this.noteTracks[t].tapNotes.set(tnEntry[0], tnSprite.setZIndex(-tnEntry[0]).addToStage());\n            }\n        }\n\n        // Clean up the notes that are out of range\n        // We could do the cleanup in the same loop above but we might end up doing too many .has() lookups\n        // Instead, do a separate loop\n        const toDestroy: Array<[number, DrawableNoteSprite, Map<number, DrawableNoteSprite>]> = [];\n        for (const track of this.noteTracks) {\n            for (const tnsEntry of track.tapNotes) {\n                if (tnsEntry[0] < firstRow || tnsEntry[0] > lastRow) {\n                    // The sprite is out of our valid window for management, destroy it\n                    // Avoid doing it in here in case it changes the internals and ruins\n                    // iteration.\n                    toDestroy.push([tnsEntry[0], tnsEntry[1], track.tapNotes]);\n                }\n            }\n            for (const tnsEntry of track.holdCaps) {\n                // We only cull holds based on their end since the start note is often off-screen\n                if (tnsEntry[0] > lastRow) {\n                    toDestroy.push([tnsEntry[0], tnsEntry[1], track.holdCaps]);\n                }\n            }\n        }\n        toDestroy.forEach((tnsAndTrackEntry) => {\n            tnsAndTrackEntry[2].delete(tnsAndTrackEntry[0]);\n            tnsAndTrackEntry[1].destroy(); // destroy the entity\n        });\n    }\n\n    public update(deltaTime: number) {\n        this.updateNotes(deltaTime);\n        return this;\n    }\n}\nexport default NoteField;\n","import * as PIXI from 'pixi.js';\n\nimport RESOURCEMAN from './ResourceManager';\nimport TapNoteReceptorSprite from './entities/TapNoteReceptorSprite';\nimport { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN } from './entities/EntitiesConstants';\nimport NoteField from './entities/NoteField';\n\ninterface ScreenManagerOptions {\n    renderCanvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n}\n\n/** Responsible for drawing to the screen.\n * We only allow one ScreenManager and it gets initialised with\n * a canvas and PIXI hook later.\n */\nexport class ScreenManager {\n    /** Get the desired FPS of the application. */\n    public static desiredFps() { return 60; }\n\n    // Singleton\n    public static getInstance() {\n        if (!ScreenManager.instance) {\n            ScreenManager.instance = new ScreenManager();\n        }\n        return ScreenManager.instance;\n    }\n    private static instance: ScreenManager;\n\n    /** The Aplication object used to interact with PIXI */\n    private pixiApp: PIXI.Application | null = null;\n    /** Created sprites, stored by name. */\n    private sprites: Map<string, PIXI.Sprite> = new Map();\n\n    private receptorsVisible = false;\n    private receptorSprites: TapNoteReceptorSprite[] = [];\n\n    private noteField: NoteField | undefined;\n\n    // Private constructor for singleton\n    private constructor() {}\n\n    public initPixi(options: ScreenManagerOptions) {\n        console.log('initpixi');\n        // Create a new PIXI app.\n        this.pixiApp = new PIXI.Application({\n            width: options.width,\n            height: options.height,\n            view: options.renderCanvas,\n            backgroundColor: 0x000000,\n        });\n        // TODO: switch this to using pixi-display for performance\n        // Uncomment next line to reverse Z ordering if desired\n        // this.pixiApp.stage.sortableChildren = true;\n        // Tell the resource manager it can load things now\n        RESOURCEMAN.loadSprites();\n        // Start the tick loop for animations and other such things\n        this.pixiApp.ticker.maxFPS = ScreenManager.desiredFps();\n        this.pixiApp.ticker.start();\n    }\n\n    public isInit() { return this.pixiApp !== null; }\n    public isReadyToDraw() { return this.isInit() && RESOURCEMAN.isDoneLoading(); }\n    public getPixiApp() {\n        if (this.pixiApp === null) {\n            throw new Error('Tried to get null pixiApp. Use isInit() first to ensure it exists.');\n        }\n        return this.pixiApp;\n    }\n\n    public setBgColor(color: number) { this.getPixiApp().renderer.backgroundColor = color; }\n\n    // TODO: move receptors into NoteField\n    /** Draw the receptors to the screen. If they're already there do nothing. */\n    public showReceptors() {\n        // TODO: loop over numTracks\n        if (this.receptorsVisible) { return; }\n        if (this.receptorSprites.length === 0) {\n            // Initialise them in arrow order <- v ^ ->\n            const initOrder = [\n                TapNoteDirection.LEFT,\n                TapNoteDirection.DOWN,\n                TapNoteDirection.UP,\n                TapNoteDirection.RIGHT,\n            ];\n            for (const direction of initOrder) {\n                this.receptorSprites.push(\n                    new TapNoteReceptorSprite(direction)\n                    .addToStage());\n            }\n        }\n        for (const receptor of this.receptorSprites) {\n            receptor.getSprite().visible = true;\n        }\n\n        // const secondBeat = 2;\n        // new TapNoteSprite(TapNoteDirection.LEFT, NoteType.N_4TH, secondBeat).addToStage();\n        // new TapNoteSprite(TapNoteDirection.DOWN, NoteType.N_8TH, secondBeat).addToStage();\n        // new TapNoteSprite(TapNoteDirection.UP, NoteType.N_12TH, secondBeat).addToStage();\n        // new TapNoteSprite(TapNoteDirection.RIGHT, NoteType.N_16TH, secondBeat).addToStage();\n        this.noteField = new NoteField();\n        this.receptorsVisible = true;\n    }\n\n    /** Hide the receptors from the screen. */\n    public hideReceptors() {\n        if (!this.receptorsVisible || this.receptorSprites.length === 0) { return; }\n        for (const receptor of this.receptorSprites) {\n            receptor.getSprite().visible = false;\n        }\n        this.receptorsVisible = false;\n    }\n}\nconst SCREENMAN = ScreenManager.getInstance();\nexport default SCREENMAN;\n","\n\n\n\n\n\n\n\n\nimport Vue from 'vue';\nimport { Component } from 'vue-property-decorator';\n\nimport SCREENMAN, { ScreenManager } from '@/lib/ScreenManager';\n\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\n@Component\nclass Screen extends Vue {\n  public $refs!: {\n    renderCanvas: HTMLCanvasElement,\n  };\n\n  public data() {\n    return {};\n  }\n  public provide() {\n    return {};\n  }\n\n  public mounted() {\n    console.log('mounted');\n    // Determine the width and height of the renderer wrapper element.\n    const renderCanvas = this.$refs.renderCanvas;\n    const width = renderCanvas.offsetWidth;\n    const height = renderCanvas.offsetHeight;\n\n    // Add us to the ScreenManager if we haven't been already.\n    if (!SCREENMAN.isInit()) {\n      SCREENMAN.initPixi({\n        renderCanvas,\n        width,\n        height,\n      });\n    }\n  }\n}\nexport default Screen;\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Screen.vue?vue&type=template&id=5f8721bc&scoped=true&\"\nimport script from \"./Screen.vue?vue&type=script&lang=ts&\"\nexport * from \"./Screen.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Screen.vue?vue&type=style&index=0&id=5f8721bc&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"5f8721bc\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"chart-picker\"},[_c('v-select',{attrs:{\"items\":_vm.packs,\"item-text\":\"name\",\"item-value\":\"name\",\"label\":\"Pack\"},on:{\"change\":function($event){return _vm.changePackEvent()}},model:{value:(_vm.selectedPack),callback:function ($$v) {_vm.selectedPack=$$v},expression:\"selectedPack\"}}),_c('v-select',{attrs:{\"items\":_vm.charts,\"item-text\":\"name\",\"item-value\":\"name\",\"label\":\"Chart\"},on:{\"change\":function($event){return _vm.changeChartEvent()}},model:{value:(_vm.selectedChart),callback:function ($$v) {_vm.selectedChart=$$v},expression:\"selectedChart\"}})],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from 'vue';\nimport { Component } from 'vue-property-decorator';\nimport axios from 'axios';\nimport { Pack, ChartURLs, Chart } from '@/lib/ChartPicker';\n\nconst PACK_INDEX_FILENAME = process.env.VUE_APP_PACK_INDEX_FILENAME || 'packs.json';\nconst DEFAULT_SELECTED_CHART = {name: '<Select a chart>', oggFilename: '', simFilename: ''};\n\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\n@Component\nclass ChartPicker extends Vue {\n  public selectedPack = 'Loading';\n  public packs: Pack[] = [\n    {\n      name: 'Loading',\n      charts: [],\n    },\n  ];\n\n  public selectedChart = 'Loading';\n  public charts: Chart[] = [\n    {\n      name: 'Loading',\n      oggFilename: 'Loading',\n      simFilename: 'Loading',\n    },\n  ];\n\n  public provide() {\n    return {};\n  }\n\n  public mounted() {\n    // Fetch and return the pack data\n    axios.get(`${process.env.BASE_URL}${PACK_INDEX_FILENAME}`).then((response) => {\n      this.packs = response.data;\n      // Insert default/dummy charts\n      this.packs.forEach((pack) => {\n        pack.charts.unshift(DEFAULT_SELECTED_CHART);\n      });\n      // Set default pack\n      this.selectedPack = this.packs[0].name;\n      // Set default chart from default pack\n      this.charts = this.packs[0].charts;\n      this.selectedChart = DEFAULT_SELECTED_CHART.name;\n    }).catch((error) => {\n      console.error(`failed to get pack info from url: ${error}`);\n    });\n  }\n\n  private findPack(name: string): Pack {\n    const foundPack = this.packs.find((pack) => pack.name === name);\n    if (foundPack === undefined) {\n      throw new Error(`Could not find pack with name ${name}`);\n    }\n    return foundPack;\n  }\n\n  private findChart(name: string): Chart {\n    const foundChart = this.charts.find((chart) => chart.name === name);\n    if (foundChart === undefined) {\n      throw new Error(`Could not find chart with name ${name}`);\n    }\n    return foundChart;\n  }\n\n  private changePackEvent(event: any) {\n    this.charts = this.findPack(this.selectedPack).charts;\n    this.selectedChart = this.charts[0].name;\n  }\n\n  private changeChartEvent(event: any) {\n    const packName = this.selectedPack;\n    const chart = this.findChart(this.selectedChart);\n\n    if (chart === DEFAULT_SELECTED_CHART) { return; } // nothing to load\n\n    const ogg = chart.oggFilename === null ? null : `${packName}/${chart.name}/${chart.oggFilename}`;\n    const simFile = `${packName}/${chart.name}/${chart.simFilename}`;\n    const urls: ChartURLs = {ogg, simFile};\n    this.$emit('changeChart', urls);\n  }\n\n}\nexport default ChartPicker;\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ChartPicker.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ChartPicker.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ChartPicker.vue?vue&type=template&id=65bde944&scoped=true&\"\nimport script from \"./ChartPicker.vue?vue&type=script&lang=ts&\"\nexport * from \"./ChartPicker.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"65bde944\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!/atlassian-home/src/private/simfile-viewer/node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VSelect } from 'vuetify/lib'\ninstallComponents(component, {VSelect})\n","// tslint:disable: max-classes-per-file\n\nimport { TapNote, TapNoteSubType, TapNotes, MAX_NOTE_ROW } from './NoteTypes';\nimport TimingData from './TimingData';\nimport { TapNoteType } from './NoteTypes';\nimport { NotImplementedError } from './Error';\nimport { ASSERT, DEBUG_ASSERT } from './Debug';\nimport { PassByRef } from './GameConstantsAndTypes';\n\n// NoteData is organized by:\n//   track - corresponds to different columns of notes on the screen\n//   row/index - corresponds to subdivisions of beats\n\n// C++ code used this type, we need a better type since in C++ maps are sorted.\n// Without sorting, iteration over tracks becomes a problem. - Struz\n// type TrackMap = Map<number, TapNote>;\n\nexport class TrackMap {\n    // Shut tslint up about functions that may not exist until .proxy() runs\n    [x: string]: any;\n\n    private static skipOverride = ['set', 'entries', 'values', 'keys', 'constructor'];\n    private static sortNumbersAsc(a: [number, TapNote], b: [number, TapNote]) {\n        return a[0] - b[0];\n    }\n    // TODO: write tests for me to ensure I stay ordered\n    // TODO: iterators - forward and backwards, and specific ranges\n\n    public size: number;\n    private map: Map<number, TapNote>;        /** The map object backing this. */\n    private mapReverse: Map<number, TapNote>; /** Required for backwards iteration. */\n    private isSorted: boolean;\n\n\n    constructor() {\n        this.map = new Map();\n        this.mapReverse = new Map();\n        this.size = 0;\n        this.isSorted = true;\n        this.proxy();\n    }\n\n    // Iterator wrappers\n    /** Wrapper for map.entries() that ensures that entries are looped in ascending order. */\n    public entries(startAt?: number, endAt?: number) {\n        this.sort();\n        return new TrackMapIterator(this.map, IteratorDirection.Forwards, startAt, endAt);\n    }\n    public keys() {\n        this.sort();\n        return this.map.keys();\n    }\n    public values() {\n        this.sort();\n        return this.map.values();\n    }\n    public [Symbol.iterator](): IterableIterator<[number, TapNote]> {\n        this.sort();\n        return this.map[Symbol.iterator]();\n    }\n    // Reverse iterators. The reason behind using a reversed map to do reverse\n    // iteration is that ES6 maps use hashing and internal [[MapData]] slots.\n    // If we were to implement the reverse iteration using arrays we would lose\n    // some efficiency, so we take the hit in terms of memory to store a\n    // second copy of the map.\n    public reverseEntries(startAt?: number, endAt?: number) {\n        this.sort();\n        return new TrackMapIterator(this.mapReverse, IteratorDirection.Backwards, startAt, endAt);\n    }\n    public reverseKeys() {\n        this.sort();\n        return this.mapReverse.keys();\n    }\n    public reverseValues() {\n        this.sort();\n        return this.mapReverse.values();\n    }\n\n    // TODO: when we delete we need to mirror the delete to the\n    // other map. They will stay sorted this way! Otherwise we need to\n    // invalidate and sort again.\n\n    /** Wrapper for map.set() that sets some extra state. */\n    public set(key: number, value: TapNote) {\n        this.map.set(key, value);\n        this.isSorted = false;\n        this.size = this.map.size;\n        return this;\n    }\n\n    /**\n     * Sort the map - relatively expensive operation as it must create a new map.\n     * Ideally we won't be using this much as we shouldn't be inserting mid-gameplay.\n     */\n    private sort() {\n        if (this.isSorted) { return; }\n\n        const sortedEntriesAsc = [...this.map.entries()].sort(TrackMap.sortNumbersAsc);\n        // shallow copy with .slice() then reverse it. Possibly not necessary.\n        const sortedEntriesDesc = sortedEntriesAsc.slice().reverse();\n\n        this.map = new Map(sortedEntriesAsc);\n        this.mapReverse = new Map(sortedEntriesDesc);\n        this.isSorted = true;\n        this.proxy();\n    }\n\n    /**\n     * Proxy the inner map's functions to the outside of this class.\n     * This is so we can use all the map's features with very little work.\n     * Each time we change the inner map we need to re-proxy.\n     */\n    private proxy() {\n        const mapProps = Object.getOwnPropertyNames(Object.getPrototypeOf(this.map));\n        // For each property of map that's a function and that we don't\n        // want to override ourselves, proxy that function directly via a bound function.\n        mapProps.forEach((prop) => {\n            if (TrackMap.skipOverride.indexOf(prop) !== -1 ||\n                typeof (this.map as any)[prop] !== 'function') {\n                return;\n            }\n            const mapFunc = (this.map as any)[prop].bind(this.map);\n            const reverseMapFunc = (this.mapReverse as any)[prop].bind(this.mapReverse);\n            // We have to wrap the func rather than assign it directly to\n            // ensure our .size method works.\n            const wrapFunc = (...args: any) => {\n                const retVal = mapFunc(...args);\n                reverseMapFunc(...args);\n                this.size = this.map.size;  // stay in sync\n                // We're primarily concerned with the ascending map, so we return that\n                return retVal;\n            };\n            this[prop] = wrapFunc;\n        });\n    }\n}\n\nenum IteratorDirection {\n    Forwards,\n    Backwards,\n}\n\n/**\n * Iterator over a TrackMap that keeps state about where in the track it is.\n */\nclass TrackMapIterator implements IterableIterator<[number, TapNote]> {\n    /* Depending on the direction we need different comparisons for using\n     * startAt and endAt. */\n    private static compare(value1: number, value2: number, direction: IteratorDirection) {\n        if (direction === IteratorDirection.Forwards) {\n            return value1 >= value2;\n        }\n        return value1 <= value2;\n    }\n\n    private it: Iterator<[number, TapNote]>;\n    // We need to store the last next() result as we internally need next() to\n    // set up the iterator.\n    private lastNextResult: IteratorResult<[number, TapNote]> | undefined;\n    private direction: IteratorDirection;\n    private start: number | undefined;\n    private end: number | undefined;\n\n    // TODO: make the startAt version of this as performant as the possible implementations\n    // at https://en.cppreference.com/w/cpp/algorithm/lower_bound\n    constructor(map: Map<number, TapNote>, direction: IteratorDirection,\n                startAt?: number, endAt?: number) {\n        this.it = map.entries();\n        this.direction = direction;\n        this.start = startAt;\n        this.end = endAt;\n        if (this.start === undefined) { return; }\n\n        // Set the iterator to start at the given index\n        // We need to use this.it.next() rather than this.next() so that\n        // we get fine grained control over how we store lastNextResult and don't\n        // skip too far ahead with extra this.it.next() calls.\n        let result = this.it.next();\n        while (!result.done) {\n            if (TrackMapIterator.compare(result.value[0], this.start, this.direction)) {\n                this.lastNextResult = result;\n                return;\n            }\n            result = this.it.next();\n        }\n    }\n\n    public next(): IteratorResult<[number, TapNote]> {\n        if (this.lastNextResult === undefined) {\n            this.lastNextResult = this.it.next();\n        }\n        const ret = this.lastNextResult;\n\n        // If we've been told to end at a certain point and we're at that point\n        // then send a done IteratorResult and stop iterating.\n        if (this.end !== undefined) {\n            if (TrackMapIterator.compare(ret.value[0], this.end, this.direction)) {\n                return {value: ret.value, done: true};\n            }\n        }\n\n        // Otherwise keep iterating as usual\n        this.lastNextResult = this.it.next();\n        return ret;\n    }\n\n    public [Symbol.iterator](): IterableIterator<[number, TapNote]> {\n        return this;\n    }\n\n    // /** Peek the iterator without going anywhere.\n    //  * Useful for assessing whether we start at the end of a range already.\n    //  */\n    // public peek(): IteratorResult<[number, TapNote]> {\n    //     if (this.lastNextResult === undefined) {\n    //         this.lastNextResult = this.it.next();\n    //     }\n    //     return this.lastNextResult;\n    // }\n\n    public track(): number {\n        throw new NotImplementedError();\n    }\n\n    public row(): number {\n        throw new NotImplementedError();\n    }\n\n    public finished(): boolean {\n        // We can't know if we're finished if we haven't gone anywhere\n        if (this.lastNextResult === undefined) {\n            return false;\n        }\n        return this.lastNextResult.done;\n    }\n\n    // TODO: fill this out when I understand more about the use cases\n}\n\n// Helper functions that were #defined in C++. Translated with the same format for clarity.\n/** Act on each non empty row in the specific track. */\nexport function FOREACH_NONEMPTY_ROW_IN_TRACK(\n    nd: NoteData, track: number, row: PassByRef<number>,\n    fn: (row: PassByRef<number>) => void) {\n        // Takes row in so that it can pass it back out again if necessary\n        for (row.value = -1; nd.getNextTapNoteRowForTrack(track, row); row.value++) {\n            fn(row);\n        }\n    }\n/** Act on each non empty row in the specified track within the specified range. */\n\n/** Act on each non empty row in the specified track within the specified range, going in reverse order. */\n/** Act on each non empty row for all of the tracks. */\nexport function FOREACH_NONEMPTY_ROW_ALL_TRACKS(\n    nd: NoteData, row: PassByRef<number>, fn: (row: PassByRef<number>) => void) {\n        for (row.value = -1; nd.getNextTapNoteRowForAllTracks(row); row.value++) {\n            fn(row);\n        }\n    }\n/** Act on each non empty row for all of the tracks within the specified range. */\n// I'm not sure why but this loop is 1-indexed while the array is 0-indexed, so it translates between.\n// TODO: make it all 0 indexed since the users add 1 to their values just to get them subtracted again here.\nexport function FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE(\n    nd: NoteData, row: PassByRef<number>, start: number,\n    last: number, fn: (row: PassByRef<number>) => void) {\n        for (row.value = start - 1; nd.getNextTapNoteRowForAllTracks(row) && row.value < last;) {\n            fn(row);\n        }\n    }\n\n/** Holds data about the notes that the player is supposed to hit. */\nexport class NoteData {\n    // IMPORTANT: this is one hell of a class.....needs doing asap!\n    // We need all track iterators and shit, it's wild\n\n    // There's no point in inserting empty notes into the map.\n    // Any blank space in the map is defined to be empty.\n    public tapNotes: TrackMap[] = []; // TODO: make this private once we have a standard way of iterating over it\n    public loaded: boolean = false;\n\n    public setOccurranceTimeForAllTaps(timingData: TimingData) { throw new NotImplementedError(); }\n    public countNotesInColumn(\n        timingData: TimingData,\n        noteCounts: Array<Map<TapNoteType, number>>,\n        holdDurations: Array<Map<TapNoteSubType, number>>) { throw new NotImplementedError(); }\n\n    public getNumTracks() { return this.tapNotes.length; }\n    public setNumTracks(newNumTracks: number) {\n        this.tapNotes.length = newNumTracks;\n        for (let i = 0; i < newNumTracks; i++) {\n            // If we extended it then make sure we create the new maps)\n            this.tapNotes[i] = (this.tapNotes[i] === undefined ? new TrackMap() : this.tapNotes[i]);\n        }\n    }\n    public isComposite() { throw new NotImplementedError(); }\n    public equals(other: NoteData) { return this.tapNotes === other.tapNotes; }\n\n    public getTapNote(track: number, row: number): TapNote {\n        // TODO: I think I can improve the original application's performance by not\n        // doing ANOTHER .get() here, but instead just returning the TapNote()\n        // out of the function. Or keeping a constant iterator which can straight return the value.\n        // Optimise later, only if performance suffers.\n        const trackMap = this.tapNotes[track];\n        const noteRow = trackMap.get(row);\n        // The distinction betwen this and findTapNote is that this returns an empty note\n        // if the note doesn't explicitly exist.\n        return (noteRow === undefined) ? TapNotes.newEmpty() : noteRow;\n    }\n\n    public findTapNote(track: number, row: number): TapNote | undefined { return this.tapNotes[track].get(row); }\n    public removeTapNote(track: number, row: number) { this.tapNotes[track].delete(row); }\n\n    // I wonder if we'll need this - Struz\n    /**\n     * Return an iterator range for [rowBegin,rowEnd).\n     *\n     * This can be used to efficiently iterate trackwise over a range of notes.\n     * It's like FOREACH_NONEMPTY_ROW_IN_TRACK_RANGE, except it only requires\n     * two map searches (iterating is constant time), but the iterators will\n     * become invalid if the notes they represent disappear, so you need to\n     * pay attention to how you modify the data.\n     * @param iTrack the column to use.\n     * @param iStartRow the starting point.\n     * @param iEndRow the ending point.\n     * @param begin the eventual beginning point of the range.\n     * @param end the eventual end point of the range.\n     */\n    public getTapNoteRange(track: number, startRow: number, endRow: number,\n                           iterator: undefined, constIterator: undefined) { throw new NotImplementedError(); }\n    // Omitted overloaded getTapNoteRange()\n\n    // Omitted all the iterator funcs - need to work out how I'll handle this\n\n    public getTapNoteRangeInclusive() { throw new NotImplementedError(); }\n    // Omitted overloaded getTapNoteRangeInclusive()\n\n    public getTapNoteRangeExclusive() { throw new NotImplementedError(); }\n    // Omitted overloaded getTapNoteRangeExclusive()\n\n    /* Returns the row of the first TapNote on the track that has a row greater than rowInOut. */\n    public getNextTapNoteRowForTrack(track: number, rowInAndOut: PassByRef<number>, ignoreAutoKeysounds = false) {\n        const mapTrack = this.tapNotes[track];\n        const iter = mapTrack.entries(rowInAndOut.value + 1); // \"find the first note for which row+1 < key == false\"\n        let entry = iter.next();\n        if (entry.done) { return false; }\n\n        DEBUG_ASSERT(entry.value[0] > rowInAndOut.value);\n\n        if (ignoreAutoKeysounds) {\n            while (entry.value[1].type === TapNoteType.AutoKeysound) {\n                entry = iter.next();\n                if (entry.done) { return false; }\n            }\n        }\n        rowInAndOut.value = entry.value[0];\n        return true;\n    }\n\n    public getNextTapNoteRowForAllTracks(rowInAndOut: PassByRef<number>) {\n        let closestNextRow = MAX_NOTE_ROW;\n        let anyHaveNextNote = false;\n        for (let t = 0; t < this.getNumTracks(); t++) {\n            const newRowThisTrack = {value: rowInAndOut.value};\n            if (this.getNextTapNoteRowForTrack(t, newRowThisTrack)) {\n                anyHaveNextNote = true;\n                ASSERT(newRowThisTrack.value < MAX_NOTE_ROW, 'Row should never exceed MAX_NOTE_ROW');\n                closestNextRow = Math.min(closestNextRow, newRowThisTrack.value);\n            }\n        }\n\n        if (anyHaveNextNote) {\n            rowInAndOut.value = closestNextRow;\n            return true;\n        }\n        return false;\n    }\n\n    public getPrevTapNoteRowForTrack(track: number, rowInAndOut: PassByRef<number>) {\n        const mapTrack = this.tapNotes[track];\n\n        // Find the first note >= rowInOut.\n        const iter = mapTrack.reverseEntries(rowInAndOut.value);\n\n        // If we're at the beginning, we can't move back any more.\n        const entry = iter.next();\n        if (entry.done) { return false; }\n\n        // Move back by one\n        DEBUG_ASSERT(entry.value[0] < rowInAndOut.value);\n        rowInAndOut.value = entry.value[0];\n        return true;\n    }\n\n    public getPrevTapNoteRowForAllTracks(rowInAndOut: PassByRef<number>) {\n        let closestPrevRow = 0;\n        let anyHavePrevNote = false;\n        for (let t = 0; t < this.getNumTracks(); t++) {\n            const newRowThisTrack = {value: rowInAndOut.value};\n            if (this.getPrevTapNoteRowForTrack(t, newRowThisTrack)) {\n                anyHavePrevNote = true;\n                DEBUG_ASSERT(newRowThisTrack.value < MAX_NOTE_ROW);\n                closestPrevRow = Math.max(closestPrevRow, newRowThisTrack.value);\n            }\n        }\n\n        if (anyHavePrevNote) {\n            rowInAndOut.value = closestPrevRow;\n            return true;\n        }\n        return false;\n    }\n\n    public moveTapNoteTrack(dest: number, src: number) { throw new NotImplementedError(); }\n    public setTapNote(track: number, row: number, tn: TapNote) {\n        DEBUG_ASSERT(track >= 0 && track < this.getNumTracks());\n\n        if (row < 0) {\n            return;\n        }\n        // There's no point in inserting empty notes into the map.\n        // Any blank space in the map is defined to be empty.\n        // If we're trying to insert an empty at a spot where another note\n        // already exists, then we're really deleting from the map.\n        if (tn.equals(TapNotes.EMPTY)) {\n            const trackMap = this.tapNotes[track];\n            // remove the element at this position (if any).\n            // This will return either true or false.\n            trackMap.delete(row);\n        } else {\n            this.tapNotes[track].set(row, tn);\n        }\n    }\n    /**\n     * @brief Add a hold note, merging other overlapping holds and destroying\n     * tap notes underneath.\n     * @param iTrack the column to work with.\n     * @param iStartRow the starting row.\n     * @param iEndRow the ending row.\n     * @param tn the tap note.\n     */\n    public addHoldNote(track: number, startRow: number, endRow: number, tn: TapNote) {\n        throw new NotImplementedError();\n    }\n\n    public clearRangeForTrack(rowBegin: number, rowEnd: number, track: number) { return new NotImplementedError(); }\n    public clearRange(rowBegin: number, rowEnd: number) { return new NotImplementedError(); }\n    public clearAll() {\n        for (const track of this.tapNotes) {\n            track.clear();\n        }\n    }\n    public copyRange() { return new NotImplementedError(); }\n    public copyAll() { return new NotImplementedError(); }\n\n    public isRowEmpty(row: number) { return new NotImplementedError(); }\n    /* Determine if a hold note lies on the given spot. Return true if so.  If\n     * pHeadRow is non-nullptr, return the row of the head. (Note that this returns\n     * false if a hold head lies on iRow itself.) */\n    public isHoldNoteAtRow(track: number, row: number, headRow: PassByRef<number>) {\n        /* Starting at iRow, search upwards. If we find a TapNoteType_HoldHead, we're within\n         * a hold. If we find a tap, mine or attack, we're not--those never lie\n         * within hold notes. Ignore autoKeysound. */\n        for (const rowPbr = {value: row}; this.getPrevTapNoteRowForTrack(track, rowPbr) && rowPbr.value >= 0;) {\n            const tn = this.getTapNote(track, rowPbr.value);\n            switch (tn.type) {\n                case TapNoteType.HoldHead:\n                    if (tn.duration + rowPbr.value < row) {\n                        return false;\n                    }\n                    headRow.value = rowPbr.value;\n                    return true;\n\n                case TapNoteType.Tap:\n                case TapNoteType.Mine:\n                case TapNoteType.Attack:\n                case TapNoteType.Lift:\n                case TapNoteType.Fake:\n                    return false;\n\n                case TapNoteType.Empty:\n                case TapNoteType.AutoKeysound:\n                    // ignore\n                    continue;\n                default:\n                    throw new Error(`Unknwon TapNoteType: ${tn.type}`);\n            }\n        }\n\n        return false;\n    }\n\n    public isThereATapAtRow(row: number) {\n        return this.getFirstTrackWithTap(row) !== -1;\n    }\n\n    public isThereATapOrHoldHeadAtRow(row: number) {\n        return this.getFirstTrackWithTapOrHoldHead(row) !== -1;\n    }\n\n    /**\n     * In the given row return the first track with a tap type.\n     * Returns -1 if no track has a tap type note.\n     */\n    public getFirstTrackWithTap(row: number) {\n        for (let t = 0; t < this.getNumTracks(); t++) {\n            const tn = this.getTapNote(t, row);\n            if (tn.type === TapNoteType.Tap || tn.type === TapNoteType.Lift) {\n                return t;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * In the given row return the first track with a tap or hold-head type.\n     * Returns -1 if no track has a tap or hold-head type.\n     */\n    public getFirstTrackWithTapOrHoldHead(row: number) {\n        for (let t = 0; t < this.getNumTracks(); t++) {\n            const tn = this.getTapNote(t, row);\n            if (tn.type === TapNoteType.Tap ||\n                tn.type === TapNoteType.Lift ||\n                tn.type === TapNoteType.HoldHead) {\n                return t;\n            }\n        }\n        return -1;\n    }\n    // TODO: finish me off sometime from NoteData.h\n}\nexport default NoteData;\n","import NoteHelpers from './NoteTypes';\nimport GAMESTATE from './GameState';\nimport { FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE } from './NoteData';\nimport { Howl } from 'howler';\nimport clapOgg from '../assets/sounds/assist_clap.ogg';\n\nexport class RhythmAssist {\n    public static rowLastCrossed = -1;\n    public static clapSound = new Howl({\n        src: [clapOgg],\n        volume: 0.6,  // TODO: make this a setting\n    });\n\n    public static playTicks() {\n        const metronome = false;\n        const clap = true;\n\n        // TODO: make this player position rather than overall song position\n        // if things don't work properly\n        const position = GAMESTATE.position;\n        const positionSeconds = position.musicSeconds;\n\n        // This next line is for playing sounds early so they come out on time.\n        // Worry about that later. -Struz\n        // positionSeconds += SOUNDMAN->GetPlayLatency() + (float)CommonMetrics::TICK_EARLY_SECONDS + 0.250f;\n\n        const song = GAMESTATE.curSong;\n        if (song === undefined) { return; }\n        const timing = song.songTiming;\n        // TODO: don't just use getSteps(0), use an actual value\n        const nd = song.getSteps(0).getNoteData();\n\n        // const timing = GAMESTATE.curSteps[0].timingData;  // TODO: use player number if ever applicable\n        const songBeat = timing.getBeatFromElapsedTimeNoOffset(positionSeconds);\n        const songRow = Math.max(0, NoteHelpers.beatToNoteRowNotRounded(songBeat));\n        if (songRow < RhythmAssist.rowLastCrossed) {\n            this.rowLastCrossed = songRow;\n        }\n\n        if (clap) {\n            let clapRow = -1;\n            // FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE\n            // IMPORTANT:\n            // for each index crossed since the last update\n            // TODO: reverse arguments to this function so it looks nicer when chaining in\n            const row = {value: 0};\n            FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE(nd, row, this.rowLastCrossed + 1, songRow + 1, (r) => {\n                if (nd.isThereATapOrHoldHeadAtRow(r.value)) {\n                    clapRow = r.value;\n                }\n            });\n            if (clapRow !== -1 && timing.isJudgableAtRow(clapRow)) {\n                const tickBeat = NoteHelpers.noteRowToBeat(clapRow);\n                const tickSecond = timing.getElapsedTimeFromBeatNoOffset(tickBeat);\n                const secondsUntil = tickSecond - position.musicSeconds;\n                // TODO: if we implement music rate, /= secondsUntil by the music rate\n                // TODO: when playing the sound use the magic formulae to play in time\n                // console.log(`clap @ beat=${tickBeat}`);\n                this.clapSound.play();\n            }\n        }\n\n        if (metronome && this.rowLastCrossed !== -1) {\n            const lastCrossedMeasureIndex = {value: 0};\n            const lastCrossedBeatIndex = {value: 0};\n            const lastCrossedRowsRemainder = {value: 0};\n            timing.noteRowToMeasureAndBeat(RhythmAssist.rowLastCrossed, lastCrossedMeasureIndex,\n                lastCrossedBeatIndex, lastCrossedRowsRemainder);\n\n            const currentMeasureIndex = {value: 0};\n            const currentBeatIndex = {value: 0};\n            const currentRowsRemainder = {value: 0};\n            timing.noteRowToMeasureAndBeat(songRow, currentMeasureIndex,\n                currentBeatIndex, currentRowsRemainder);\n\n            let metronomeRow = -1;\n            let changedMeasure = false;\n\n            // If we crossed a measure or a beat, we need to make the metronome sound\n            if (lastCrossedMeasureIndex.value !== currentMeasureIndex.value ||\n                lastCrossedBeatIndex.value !== currentBeatIndex.value) {\n                    metronomeRow = songRow - currentRowsRemainder.value;\n                    changedMeasure = currentMeasureIndex.value - lastCrossedMeasureIndex.value > 0;\n            }\n\n            if (metronomeRow !== -1) {\n                const tickBeat = NoteHelpers.noteRowToBeat(metronomeRow);\n                const tickSecond = timing.getElapsedTimeFromBeatNoOffset(tickBeat);\n                const secondsUntil = tickSecond - position.musicSeconds;\n                // TODO: if we implement music rate, /= secondsUntil by the music rate\n\n                // TODO: synchronisation / \"play at time\"\n                if (changedMeasure) {\n                    console.log('metronome measure');\n                } else {\n                    console.log('metronome beat');\n                }\n            }\n        }\n        RhythmAssist.rowLastCrossed = songRow;\n    }\n}\nexport default RhythmAssist;\n","import GameTimer from './GameTimer';\nimport SOUNDMAN from './GameSoundManager';\nimport GAMESTATE from './GameState';\nimport RhythmAssist from './RhythmAssist';\nimport SCREENMAN from './ScreenManager';\nimport ENTITYMAN from './entities/EntityManager';\n\nexport const gGameplayTimer = new GameTimer();\n\n/** Main rendering and update loop. */\nclass GameLoop {\n    public static drawnArrow = false;\n    public static drawnFrames = 0;\n    public static totalTime = 0;\n    public static gameLoop(outsideDeltaTime: number) {\n        // TODO: do some comparisons to work out which is better\n        // Seems like our deltaTime is more realistic. Theirs caps at 6 (100ms) due to minFPS?\n        // We don't actually have a minFPS - will this be a problem? -Struz\n        // For sound stuff our clock is better as it will give the real time elapsed (or closer to).\n        GameLoop.drawnFrames++;\n        const deltaTime = gGameplayTimer.getDeltaTime();\n        GameLoop.totalTime += deltaTime;\n        if (GameLoop.totalTime > 1) {\n            GameLoop.totalTime = 0;\n            GameLoop.drawnFrames = 0;\n        }\n\n        // Update SOUNDMAN early (before any RageSound::GetPosition calls), to flush position data.\n        SOUNDMAN.update(deltaTime);\n\n        GAMESTATE.update(deltaTime);\n        RhythmAssist.playTicks();\n\n        if (SCREENMAN.isReadyToDraw() && !this.drawnArrow) {\n            // TODO: not sure where to put this\n            SCREENMAN.showReceptors();\n\n            this.drawnArrow = true;\n        }\n\n        ENTITYMAN.update(deltaTime);\n\n        // TODO: process input if we get that far\n        // TODO: draw screen based on state\n    }\n}\nexport default GameLoop;\n","import NoteData from './NoteData';\nimport Helpers, { StepsType, Difficulty } from './GameConstantsAndTypes';\nimport TimingData from './TimingData';\nimport { NoteDataUtil } from './NoteDataUtil';\nimport Song from './Song';\n\n/**\n * Enforce a limit on the number of chars for the description.\n *\n * In In The Groove, this limit was 12: we do not need such a limit now.\n */\nexport const MAX_STEPS_DESCRIPTION_LENGTH = 255;\n\n/** The different ways of displaying the BPM. */\nexport enum DisplayBPM {\n    ACTUAL, /** Display the song's actual BPM. */\n    SPECIFIED, /** Display a specified value or values. */\n    RANDOM, /** Display a random selection of BPMs. */\n    NUM,\n    Invalid,\n}\n\n/**\n * Holds note information for a Song.\n * A Song may have one or more Notes.\n */\nexport class Steps {\n    /**\n     * The TimingData used by the Steps.\n     * This is required to allow Split Timing.\n     */\n    public timingData: TimingData = new TimingData();\n    // Type info for these steps\n    public stepsType: StepsType = StepsType.Invalid;\n    /** The string form of the StepsType, for dealing with unrecognized styles. */\n    public stepsTypeName: string = '';\n    /** The Song these Steps are associated with */\n    public song: Song;\n\n    // The name of the edit, or some other useful description.\n    // This used to also contain the step author's name.\n    public description: string = '';\n    // The style of the chart. (e.g. \"Pad\", \"Keyboard\")\n    public chartStyle: string = '';\n    // The difficulty that these steps are assigned to.\n    public difficulty: Difficulty = Difficulty.Invalid;\n    // The numeric difficulty of the Steps, ranging from MIN_METER to MAX_METER.\n    public meter: number = -1;\n    // NOTE: omitted radar values - I do not know what these are\n    // The name of the person who created the Steps\n    public credit: string = '';\n    // The name of the chart\n    public chartName: string = '';\n    // How is the BPM displayed for the chart?\n    public displayBPMType: number = DisplayBPM.ACTUAL;\n    // What is the minimum specified BPM?\n    public specifiedBpmMin: number = 0;\n    // What is the maximum specified BPM?\n    // If this is a range then min should not be equal to max\n    public specifiedBpmMax: number = 0;\n\n    // Note data for the song\n    private noteData: NoteData = new NoteData();\n    // Compressed note data for the song\n    private noteDataCompressed: string;\n    private noteDataIsFilled: boolean = false;\n\n    constructor(noteData: string, song: Song) {\n        this.noteDataCompressed = noteData;\n        this.song = song;\n    }\n\n    public getNoteData() { return this.noteData; }\n    public getCompressedNoteData() { return this.noteDataCompressed; }\n    public isNoteDataFilled() { return this.noteDataIsFilled; }\n    public getTimingData() { return this.timingData.empty() ? this.song.songTiming : this.timingData; }\n\n    public decompress() {\n        if (this.noteDataIsFilled) {\n            return; // already decompressed\n        }\n\n        // load from compressed\n        // Omitted composite - not supporting (for now) - Struz\n        this.noteDataIsFilled = true;\n        this.noteData.setNumTracks(Helpers.getStepsTypeInfo(this.stepsType).numTracks);\n        NoteDataUtil.loadFromSmNoteDataString(this.noteData, this.noteDataCompressed);\n    }\n\n    public tidyUpData(): void {\n        // Don't set the StepsType to dance single if it's invalid.  That just\n        // causes unrecognized charts to end up where they don't belong.\n        // Leave it as StepsType_Invalid so the Song can handle it specially.  This\n        // is a forwards compatibility feature, so that if a future version adds a\n        // new style, editing a simfile with unrecognized Steps won't silently\n        // delete them. -Kyz\n        if (this.stepsType === StepsType.Invalid) {\n            const stepsTypeString = this.stepsTypeName;\n            console.warn(`Detected steps with unknown style '${stepsTypeString}' in sm data`);\n        } else if (this.stepsTypeName === '') {\n            // TODO: lookup the StepsTypeInfo for the stepsType and set the typeName using it\n        }\n\n        if (this.difficulty === Difficulty.Invalid) {\n            // TODO: something about setting the difficulty based on the description\n        }\n\n        if (this.difficulty === Difficulty.Invalid) {\n            if (this.meter === 1) {\n                this.difficulty = Difficulty.Beginner;\n            } else if (this.meter <= 3) {\n                this.difficulty = Difficulty.Easy;\n            } else if (this.meter <= 6) {\n                this.difficulty = Difficulty.Medium;\n            } else {\n                this.difficulty = Difficulty.Hard;\n            }\n        }\n\n        if (this.meter < 1) {\n            // meter is invalid!\n            // TODO: translate prediction function, if it ever seems useful - Struz\n            // this.meter = this.predictMeter()\n        }\n    }\n}\nexport default Steps;\n","// The class that reads the various .SSC and .SM files\n\nexport class MsdFile {\n    // Each value has multiple parameters\n    private values: string[][] = [];\n\n    constructor(data: string) {\n        this.readBuffer(data, true);\n    }\n\n    // Get a param by index\n    public getParam(valueIndex: number, paramIndex: number): string {\n        return this.values[valueIndex][paramIndex];\n    }\n\n    // Get a value by index\n    public getValue(valueIndex: number) {\n        return this.values[valueIndex];\n    }\n\n    public getNumValues() {\n        return this.values.length;\n    }\n\n    public getNumParams(valueIndex: number) {\n        return this.values[valueIndex].length;\n    }\n\n    // Transcribed from StepMania source code to ensure it was done right\n    // This could definitely be done in a more \"JavaScript-ey\" way\n    private readBuffer(buf: string, unescape: boolean): void {\n        let readingValue: boolean = false;\n        let i: number = 0;\n        let currentParam: string[] = [];\n\n        while (i < buf.length) {\n            // Detect and skip comments - from // onwards in a line\n            if (i + 1 < buf.length && buf[i] === '/' && buf[i + 1] === '//') {\n                do {\n                    i++;\n                }\n                while (i < buf.length && buf[i] !== '\\n');\n                continue;\n            }\n\n            // TODO: files missing ';'s\n            // stretch goal\n\n            // Start reading a new value\n            if (!readingValue && buf[i] === '#') {\n                this.addValue();\n                readingValue = true;\n            }\n\n            if (!readingValue) {\n                if (unescape && buf[i] === '\\\\') {\n                    i += 2;\n                } else {\n                    ++i;\n                }\n                continue; // Nothing else is meaningful outside of a value\n            }\n\n            // : and ; end the current param, if any\n            // NOTE: the C++ code has an extra `iProcessedLen != -1` guard which we have removed\n            if (buf[i] === ':' || buf[i] === ';') {\n                this.addParam(currentParam);\n            }\n\n            // # and : begin new params\n            if (buf[i] === '#' || buf[i] === ':') {\n                ++i;\n                currentParam = [];\n                continue;\n            }\n\n            // ; ends the current value\n            if (buf[i] === ';') {\n                readingValue = false;\n                ++i;\n                continue;\n            }\n\n            // We've gone through all the control characters.\n            // All that is left is either an escaped character,\n            // ie \\#, \\\\, \\:, etc., or a regular character.\n            if (unescape && i < buf.length && buf[i] === '\\\\') {\n                ++i;\n            }\n            if (i < buf.length) {\n                currentParam.push(buf[i++]);\n            }\n        }\n\n        // Add any unterminated value at the end\n        if (readingValue) {\n            this.addParam(currentParam);\n        }\n    }\n\n    // Add a parameter to the last added value\n    private addParam(param: string[]): void {\n        this.values[this.values.length - 1].push( param.join('').trim() );\n    }\n\n    // Add a new value\n    private addValue(): void {\n        this.values.push([]);\n    }\n}\nexport default MsdFile;\n","import NoteData from './NoteData';\nimport { PLAYER_INVALID, PlayerNumber } from './PlayerNumber';\nimport NoteHelpers, { TapNote, TapNotes, MAX_NOTE_ROW, TapNoteType, BEATS_PER_MEASURE } from './NoteTypes';\n\n/**\n * Utility functions that deal with NoteData.\n *\n * Things should go in here if they can be (cleanly and efficiently)\n * implemented using only NoteData's primitives; this improves abstraction\n * and makes it much easier to change NoteData internally in the future.\n */\nexport class NoteDataUtil {\n// tslint:disable-next-line: variable-name\n    public static loadFromSmNoteDataString(out: NoteData, smNoteData_: string): void {\n        // Load note data\n        let smNoteData: string = '';\n        let indexCommentStart = 0;\n        let indexCommentEnd = 0;\n        let index = 0;\n\n        // Remove comments from the passed in note data\n// tslint:disable-next-line: no-conditional-assignment\n        while ( (indexCommentStart = smNoteData_.indexOf('//', indexCommentEnd)) !== -1 ) {\n            // Append the data in between the last comment and this comment\n            smNoteData += smNoteData_.substr(index, indexCommentStart - indexCommentEnd);\n            index += indexCommentStart - indexCommentEnd;\n            // Move forward to the end of the comment\n            indexCommentEnd = smNoteData_.indexOf('\\n', indexCommentStart);\n            indexCommentEnd = (indexCommentEnd === -1 ? smNoteData_.length : indexCommentEnd + 1);\n            index += indexCommentEnd - indexCommentStart;\n        }\n        smNoteData += smNoteData_.substr(index, smNoteData_.length - indexCommentEnd);\n\n        // Clear notes, but keep the same number of tracks.\n        const numTracks = out.getNumTracks();\n        out.clearAll();\n        out.setNumTracks(numTracks);\n\n        // We don't support composite yet so ignore composite logic - Struz\n        this.loadFromSmNoteDataStringWithPlayer(out, smNoteData, PLAYER_INVALID, numTracks);\n    }\n\n    public static loadFromSmNoteDataStringWithPlayer(\n        out: NoteData, smNoteData: string, pn: PlayerNumber, numTracks: number): void {\n        // The code in StepMania is very careful about allocations when doing this,\n        // probably because they're dealing with entire full libraries of charts.\n        // We do one at a time, we don't care. - Struz\n\n        // General algorithm is:\n        // Split notedata on ',' to get measures\n        // Split each measure on '\\n' to get rows (still as lists of char)\n        //    Seems to be logic to end the line when encountering \\n \\r \\t and ' '\n        //    Ignore empty lines - ones that have only those characters\n        // For each line in a measure parse the characters into the data structures\n\n        // Then cleanup by ensuring no leftover hold notes\n\n        const emptyFilter = (x: string) => {\n            return x.length !== 0;\n        };\n        // Split the song into measures and filter out any empty entries\n        const measures = smNoteData.split(',')\n            .map((x) => x.trim())\n            .filter(emptyFilter);\n        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {\n            const measure = measures[measureIndex];\n\n            // Split the measure into lines, trim them all, and remove any empty entries\n            // This emulates the StepMania \"find whitespace start & end and line is between that\" logic\n            const measureLines = measure.split('\\n')\n                .map((x) => x.trim())\n                .filter(emptyFilter);\n            for (let lineIndex = 0; lineIndex < measureLines.length; lineIndex++) {\n                const line = measureLines[lineIndex];\n\n                // Some calculations for placing data\n                const percentIntoMeasure = lineIndex / measureLines.length;\n                const beat = (measureIndex + percentIntoMeasure) * BEATS_PER_MEASURE;\n                const noteRow = NoteHelpers.beatToNoteRow(beat);\n\n                // Now for the fun stuff\n                for (let trackIndex = 0; trackIndex < numTracks; trackIndex++) {\n                    const noteChar = line.charAt(trackIndex);\n                    const tn = this.parseTapNoteData(noteChar, out, trackIndex, noteRow);\n\n                    // Optimization: if we pass TAP_EMPTY, NoteData will do a search\n                    // to remove anything in this position.  We know that there's nothing\n                    // there, so avoid the search.\n                    if (tn.type !== TapNoteType.Empty && noteChar !== '3') {\n                        tn.pn = pn;\n                        out.setTapNote(trackIndex, noteRow, tn);\n                    }\n                }\n            }\n        }\n\n        // Make sure we don't have any hold notes that didn't find a tail.\n        for (let t = 0; t < out.getNumTracks(); t++) {\n            // TODO: create a class-standard way of iterating through tracks\n            // preferably keeping the track variable private.\n            const track = out.tapNotes[t];\n            for (const [row, tn] of track) {\n                if (tn.type === TapNoteType.HoldHead && tn.duration === MAX_NOTE_ROW) {\n                    const beat = NoteHelpers.noteRowToBeat(row);\n                    console.log(`While loading .sm/.ssc note data, there was an unmatched 2 at beat ${beat}`);\n                    out.removeTapNote(t, row);\n                }\n            }\n        }\n        // We don't use Advanced Type Iterators so we don't need to revalidate ATIs\n    }\n\n    /** Parse a single character into a TapNote.\n     * @param noteChar the text character defining the qualities of the note.\n     * @param nd the NoteData to parse the note into. This is required for finding hold starts.\n     * @param track the track that we're parsing.\n     * @param noteRow the note row this note is on.\n     * @returns A new TapNote.\n     */\n    public static parseTapNoteData(noteChar: string,\n                                   nd: NoteData,\n                                   track: number,\n                                   noteRow: number): TapNote {\n        let tn: TapNote = TapNotes.newEmpty();\n\n        switch (noteChar) {\n            case '0': tn = TapNotes.newEmpty(); break;\n            case '1': tn = TapNotes.newOriginalTap(); break;\n            case '2':\n            case '4':\n                tn = (noteChar === '2') ? TapNotes.newOriginalHoldHead() : TapNotes.newOriginalRollHead();\n                // Set the hold note to have infinite length; We'll clamp it\n                // when we hit the tail.\n                tn.duration = MAX_NOTE_ROW;\n                break;\n            case '3':\n                // This is the end of a hold, search for the beginning\n                const headRow = {value: 0};\n                if (!nd.isHoldNoteAtRow(track, noteRow, headRow)) {\n                    console.warn(`Unmatched 3 in track=${track} for noteRow=${noteRow}`);\n                } else {\n                    const holdNote = nd.findTapNote(track, headRow.value);\n                    if (holdNote === undefined) {\n                        throw new Error(`holdNote should never be undefined: ${track}, ${headRow.value}`);\n                    }\n                    holdNote.duration = noteRow - headRow.value;\n                }\n                // This won't write tn, but keep parsing normally anyway.\n                break;\n            case 'M': tn = TapNotes.newOriginalMine(); break;\n            case 'K': tn = TapNotes.newOriginalAutoKeysound(); break;\n            case 'L': tn = TapNotes.newOriginalLift(); break;\n            case 'F': tn = TapNotes.newOriginalFake(); break;\n            default:\n                // Invalid data\n                tn = TapNotes.newEmpty();\n                break;\n        }\n\n        // Some optional checks for keysounds stuff. We don't support that yet - Struz\n        return tn;\n    }\n}\nexport default NoteDataUtil;\n","import Steps from './Steps';\nimport TimingData from './TimingData';\nimport { StepsType } from './GameConstantsAndTypes';\n\n// Holds all music metadata and steps for one song\nexport class Song {\n    // Probably not useful for my purposes - Struz\n    // See Song.h in StepMania for descriptions.\n    public fileName = '';\n    public groupName = '';\n\n    public mainTitle = '';\n    public subTitle = '';\n    public artist = '';\n    public mainTitleTranslit = '';\n    public subTitleTranslit = '';\n    public artistTranslit = '';\n\n    // Version of the song/file\n    public version = 0;\n    // Genre of the song/file\n    public genre = '';\n    public credit = '';\n    public origin = '';\n    // omitted musicFile, previewFile, instrumentTrackFile\n\n    public musicLengthSec = 0;\n    public musicSampleStartSec = 0;\n    public musicSampleLengthSec = 0;\n    public displayBpmType = 0;\n    public specifiedBpmMin = 0;\n    public specifiedBpmMax = 0;\n\n    // Omitted bannerFile, jacketFile, CDFile, DiscFile, LyricsFile,\n    // BackgroundFile, CDTitleFile, previewVidFile, attacks, attackString\n    // hasMusic, hasBanner, hasBackground\n\n    // Data for translating beats<->seconds\n    public songTiming: TimingData = new TimingData();\n\n    // These 3 were private in C++ but we've made them public here for now\n    // The first second that a note is hit\n    public firstSecond = 0;\n    // The last second that a note is hit\n    public lastSecond = 0;\n    // The last second of the song for playing purposes\n    public specifiedLastSecond = 0;\n\n    // The steps that belong to this Song\n    private steps: Steps[];\n    // The steps of a particular StepsType that belong to this Song\n    // Indexed by the enum of the step type\n    private stepsByType: Steps[][];\n    // The steps that are of unrecognised styles\n    private unknownStyleSteps = 'placeholder unknown style steps';\n\n    constructor() {\n        this.stepsByType = [];\n        for (let i = 0; i < StepsType.NUM; i++) {\n            this.stepsByType[i] = [];\n        }\n        this.steps = [];\n    }\n\n    public addSteps(steps: Steps): void {\n        // TODO: check that the steps type is valid?\n        this.steps.push(steps);\n        this.stepsByType[steps.stepsType].push(steps);\n    }\n\n    public hasSteps(): boolean {\n        return this.steps.length > 0;\n    }\n\n    public getSteps(index: number) {\n        return this.steps[index];\n    }\n\n    public tidyUpData() {\n        this.songTiming.tidyUpData(false);\n\n        for (const steps of this.steps) {\n            steps.timingData.tidyUpData(true);\n        }\n    }\n}\nexport default Song;\n","import MsdFile from './MsdFile';\nimport Steps, { DisplayBPM } from './Steps';\nimport Song from './Song';\nimport { Helpers, Difficulty } from './GameConstantsAndTypes';\nimport TimingData from './TimingData';\nimport { ROWS_PER_BEAT, NoteHelpers } from './NoteTypes';\nimport { TimeSignatureSegment, DelaySegment, BPMSegment,\n     WarpSegment, StopSegment, TickcountSegment } from './TimingSegments';\n\n/**\n * The highest allowable speed before Warps come in.\n *\n * This was brought in from StepMania 4's recent betas.\n */\nconst FAST_BPM_WARP = 9999999;\n\n/** The maximum file size for edits. */\nconst MAX_EDIT_STEPS_SIZE_BYTES\t= 60 * 1024; // 60KB\n\n// Functions used in function table below to set song data efficiently\ntype SongTimingInfo = Array<{[key: number]: number}>;\ntype SongParseFn = (info: SongTagInfo) => void;\n\ninterface SongTagInfo {\n    song: Song;\n    params: string[];\n    bpmChanges: SongTimingInfo;\n    stops: SongTimingInfo;\n}\n\nfunction SMSetTitle(info: SongTagInfo) {\n    info.song.mainTitle = info.params[1];\n}\n\nfunction SMSetSubtitle(info: SongTagInfo) {\n    info.song.subTitle = info.params[1];\n}\n\nfunction SMSetArtist(info: SongTagInfo) {\n    info.song.artist = info.params[1];\n}\n\nfunction SMSetTitleTranslit(info: SongTagInfo) {\n    info.song.mainTitleTranslit = info.params[1];\n}\n\nfunction SMSetSubtitleTranslit(info: SongTagInfo) {\n    info.song.subTitleTranslit = info.params[1];\n}\n\nfunction SMSetArtistTranslit(info: SongTagInfo) {\n    info.song.artistTranslit = info.params[1];\n}\nfunction SMSetGenre(info: SongTagInfo) {\n    info.song.genre = info.params[1];\n}\nfunction SMSetCredit(info: SongTagInfo) {\n    info.song.credit = info.params[1];\n}\nfunction SMSetBanner(info: SongTagInfo) {\n    console.debug('Skipping parsing banner');\n}\nfunction SMSetBackground(info: SongTagInfo) {\n    console.debug('Skipping parsing background file');\n}\nfunction SMSetLyricsPath(info: SongTagInfo) {\n    console.debug('Skipping parsing lyrics path');\n}\nfunction SMSetCDTitle(info: SongTagInfo) {\n    console.debug('Skipping parsing CD title');\n}\nfunction SMSetMusic(info: SongTagInfo) {\n    console.debug('Skipping parsing music file');\n}\nfunction SMSetOffset(info: SongTagInfo) {\n    info.song.songTiming.setOffset(Helpers.stringToFloat(info.params[1]));\n}\nfunction SMSetBPMs(info: SongTagInfo) {\n    info.bpmChanges = [];\n    info.bpmChanges = NoteLoaderSM.parseBpms(info.params[1]);\n}\nfunction SMSetStops(info: SongTagInfo) {\n    info.stops = [];\n    info.stops = NoteLoaderSM.parseStops(info.params[1]);\n}\nfunction SMSetDelays(info: SongTagInfo) {\n    NoteLoaderSM.processDelays(info.song.songTiming, info.params[1]);\n}\nfunction SMSetTimeSignatures(info: SongTagInfo) {\n    NoteLoaderSM.processTimeSignatures(info.song.songTiming, info.params[1]);\n}\nfunction SMSetTickCounts(info: SongTagInfo) {\n    NoteLoaderSM.processTickcounts(info.song.songTiming, info.params[1]);\n}\nfunction SMSetInstrumentTrack(info: SongTagInfo) {\n    // Implement this if it turns out to be important. It probably won't - Struz\n    // info.loader->ProcessInstrumentTracks(*info.song, (*info.params)[1]);\n}\nfunction SMSetSampleStart(info: SongTagInfo) {\n    info.song.musicSampleStartSec = Helpers.HHMMSSToSeconds(info.params[1]);\n}\nfunction SMSetSampleLength(info: SongTagInfo) {\n    info.song.musicSampleLengthSec = Helpers.HHMMSSToSeconds(info.params[1]);\n}\nfunction SMSetDisplayBPM(info: SongTagInfo) {\n    // #DISPLAYBPM:[xxx][xxx:xxx]|[*];\n    if (info.params[1] === '*') {\n        info.song.displayBpmType = DisplayBPM.RANDOM;\n    } else {\n        info.song.displayBpmType = DisplayBPM.SPECIFIED;\n        info.song.specifiedBpmMin = Helpers.stringToFloat(info.params[1]);\n        // No max specified\n        if (info.params.length < 3 || info.params[2] === '') {\n            info.song.specifiedBpmMax = info.song.specifiedBpmMin;\n        } else {\n            info.song.specifiedBpmMax = Helpers.stringToFloat(info.params[2]);\n        }\n    }\n}\nfunction SMSetSelectable(info: SongTagInfo) {\n    // Implement this if it turns out to be important. It probably won't - Struz\n}\nfunction SMSetBGChanges(info: SongTagInfo) {\n    // Implement this if it turns out to be important. It probably won't  - Struz\n    // info.loader->ProcessBGChanges(*info.song, (*info.params)[0], info.path, (*info.params)[1]);\n}\nfunction SMSetFGChanges(info: SongTagInfo) {\n   // Implement this if it turns out to be important. It probably won't - Struz\n}\nfunction SMSetKeysounds(info: SongTagInfo) {\n    // Seems pretty useless for an online viewer - Struz\n}\nfunction SMSetAttacks(info: SongTagInfo) {\n    // I don't even know what attacks are - Struz\n    // info.loader->ProcessAttackString(info.song->m_sAttackString, (*info.params));\n    // info.loader->ProcessAttacks(info.song->m_Attacks, (*info.params));\n}\n\n// Function table for setting song data efficiently\nconst songTagHandlers: Map<string, SongParseFn> = new Map([\n    ['TITLE', SMSetTitle],\n    ['SUBTITLE', SMSetSubtitle],\n    ['ARTIST', SMSetArtist],\n    ['TITLETRANSLIT', SMSetTitleTranslit],\n    ['SUBTITLETRANSLIT', SMSetSubtitleTranslit],\n    ['ARTISTTRANSLIT', SMSetArtistTranslit],\n    ['GENRE', SMSetGenre],\n    ['CREDIT', SMSetCredit],\n    ['BANNER', SMSetBanner],\n    ['BACKGROUND', SMSetBackground],\n    // Save \"#LYRICS\" for later, so we can add an internal lyrics tag.\n    ['LYRICSPATH', SMSetLyricsPath],\n    ['CDTITLE', SMSetCDTitle],\n    ['MUSIC', SMSetMusic],\n    ['OFFSET', SMSetOffset],\n    ['BPMS', SMSetBPMs],\n    ['STOPS', SMSetStops],\n    ['FREEZES', SMSetStops],\n    ['DELAYS', SMSetDelays],\n    ['TIMESIGNATURES', SMSetTimeSignatures],\n    ['TICKCOUNTS', SMSetTickCounts],\n    ['INSTRUMENTTRACK', SMSetInstrumentTrack],\n    ['SAMPLESTART', SMSetSampleStart],\n    ['SAMPLELENGTH', SMSetSampleLength],\n    ['DISPLAYBPM', SMSetDisplayBPM],\n    ['SELECTABLE', SMSetSelectable],\n    // It's a bit odd to have the tag that exists for backwards compatibility\n    // in this list and not the replacement, but the BGCHANGES tag has a\n    // number on the end, allowing up to NUM_BackgroundLayer tags, so it\n    // can't fit in the map. -Kyz\n    ['ANIMATIONS', SMSetBGChanges],\n    ['FGCHANGES', SMSetFGChanges],\n    ['KEYSOUNDS', SMSetKeysounds],\n    // Attacks loaded from file\n    ['ATTACKS', SMSetAttacks],\n    /* Tags that no longer exist, listed for posterity.  May their names\n        * never be forgotten for their service to Stepmania. -Kyz\n        * LASTBEATHINT: // unable to identify at this point: ignore\n        * MUSICBYTES: // ignore\n        * FIRSTBEAT: // cache tags from older SM files: ignore.\n        * LASTBEAT: // cache tags from older SM files: ignore.\n        * SONGFILENAME: // cache tags from older SM files: ignore.\n        * HASMUSIC: // cache tags from older SM files: ignore.\n        * HASBANNER: // cache tags from older SM files: ignore.\n        * SAMPLEPATH: // SamplePath was used when the song has a separate preview clip. -aj\n        * LEADTRACK: // XXX: Does anyone know what LEADTRACK is for? -Wolfman2000\n        * MUSICLENGTH: // Loaded from the cache now. -Kyz\n        */\n]);\n\n// Reads a song from a .sm file\nexport class NoteLoaderSM {\n    /**\n     * Convert a row value to the proper beat value.\n     * This is primarily used for assistance with converting SMA files.\n     * @param line The line that contains the value.\n     * @param rowsPerBeat the number of rows per beat according to the original file.\n     * @return the converted beat value.\n     */\n    public static rowToBeat(line: string, rowsPerBeat: number) {\n        // Trim r and R characters from the sides of the string\n// tslint:disable-next-line: max-line-length\n        // Modifies .trim() polyfill at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim\n        const backup = line.replace(/^[rR]+|[rR]+$/g, '');\n        // If r or R were present, there's multiple rows per beat\n        if (backup !== line) {\n            return Helpers.stringToFloat(line) / rowsPerBeat;\n        }\n        return Helpers.stringToFloat(line);\n    }\n\n    /**\n     * Process the different tokens we have available to get NoteData.\n     * @param stepsType The current StepsType.\n     * @param description The description of the chart.\n     * @param difficulty The difficulty (in words) of the chart.\n     * @param meter the difficulty (in numbers) of the chart.\n     * @param radarValues the calculated radar values.\n     * @param noteData the note data itself.\n     * @returns the Steps with parsed note data.\n     */\n    public static loadFromTokens(\n        stepsType: string,\n        description: string,\n        difficulty: string,\n        meter: string,\n        noteData: string,\n        song: Song,\n    ): Steps {\n        const steps = new Steps(noteData, song);\n\n        // Backwards compatibility hacks\n        switch (stepsType) {\n            case 'ez2-single-hard':\n                stepsType = 'ez2-single';\n                break;\n            case 'para':\n                stepsType = 'para-single';\n                break;\n        }\n\n        // TODO: string to steps type\n        steps.stepsType = Helpers.stringToStepsType(stepsType);\n        steps.stepsTypeName = stepsType;\n        steps.description = description;\n        steps.credit = description; // This is often used for both\n        steps.chartName = description; // One more for good measure\n        steps.difficulty = Helpers.oldStyleStringToDifficulty(difficulty);\n\n        // Handle hacks that originated back when StepMania didn't have\n        // Difficulty_Challenge. (At least v1.64, possibly v3.0 final...)\n        if (steps.difficulty === Difficulty.Hard) {\n            if (description === 'smaniac' || description === 'challenge') {\n                steps.difficulty = Difficulty.Challenge;\n            }\n        }\n        if (steps.difficulty === Difficulty.Invalid) {\n            steps.difficulty = Difficulty.Edit;\n        }\n        if (meter.length === 0) {\n            meter = '1';\n        }\n        steps.meter = Helpers.stringToInt(meter);\n\n        steps.tidyUpData();\n\n        return steps;\n    }\n\n    /**\n     * Parse BPM Changes data from a string.\n     * @param line the string in question.\n     * @param rowsPerBeat the number of rows per beat for this purpose.\n     * @returns a SongTimingInfo containing the data.\n     */\n    public static parseBpms(line: string, rowsPerBeat: number = -1): SongTimingInfo {\n        const songBpmInfo: SongTimingInfo = [];\n\n        const bpmChangeExpressions = line.split(',');\n        for (const expression of bpmChangeExpressions) {\n            const arrayBpmChangeValues = expression.split('=');\n            if (arrayBpmChangeValues.length !== 2) {\n                console.error(`.sm data has invalid #BPMs value \"${expression}\" (must have exactly one \"=\"), ignored`);\n                continue;\n            }\n\n            const beat = this.rowToBeat(arrayBpmChangeValues[0], rowsPerBeat);\n            const newBpm = Helpers.stringToFloat(arrayBpmChangeValues[1]);\n            if (newBpm === 0) {\n                console.error(`.sm file has a 0 BPM; ignored`);\n                continue;\n            }\n            songBpmInfo.push([beat, newBpm]);\n        }\n        return songBpmInfo;\n    }\n\n    /**\n     * Parse Stops data from a string.\n     * @param line the string in question.\n     * @param rowsPerBeat the number of rows per beat for this purpose.\n     * @returns a SongTimingInfo containing the data.\n     */\n    public static parseStops(line: string, rowsPerBeat: number = -1): SongTimingInfo {\n        const songStopInfo = [];\n\n        const arrayFreezeExpressions = line.split(',');\n        for (const expression of arrayFreezeExpressions) {\n            const arrayFreezeValues = expression.split('=');\n            if (arrayFreezeValues.length !== 2) {\n                console.error(`.sm data has invalid #STOPS value \"${expression}\" (must have exactly one \"=\"), ignored`);\n                continue;\n            }\n\n            const freezeBeat = this.rowToBeat(arrayFreezeValues[0], rowsPerBeat);\n            const freezeSeconds = Helpers.stringToFloat(arrayFreezeValues[1]);\n            if (freezeSeconds === 0) {\n                console.error(`.sm file has a zero-length stop; ignored`);\n                continue;\n            }\n            songStopInfo.push([freezeBeat, freezeSeconds]);\n        }\n        return songStopInfo;\n    }\n\n    /**\n     * Process the Delay Segments from the string.\n     * @param out the TimingData being modified.\n     * @param line the string in question.\n     * @param rowsPerBeat the number of rows per beat for this purpose.\n     */\n    public static processDelays(out: TimingData, line: string, rowsPerBeat: number = -1): void {\n        const arrayDelayExpressions = line.split(',');\n        for (const expression of arrayDelayExpressions) {\n            const arrayDelayValues = expression.split('=');\n            if (arrayDelayValues.length !== 2) {\n// tslint:disable-next-line: max-line-length\n                console.error(`.sm data has invalid #DELAYS value \"${expression}\" (must have exactly one \"=\"), ignored`);\n                continue;\n            }\n\n            const freezeBeat = this.rowToBeat(arrayDelayValues[0], rowsPerBeat);\n            const freezeSeconds = Helpers.stringToFloat(arrayDelayValues[1]);\n            if (freezeSeconds <= 0) {\n                console.error(`.sm file has an invalid dealy at beat ${freezeBeat}, length ${freezeSeconds}}; ignored`);\n                continue;\n            }\n            out.addSegment(new DelaySegment(NoteHelpers.beatToNoteRow(freezeBeat), freezeSeconds));\n        }\n    }\n\n    /**\n     * Process the Time Signature Segments from the string.\n     * @param out the TimingData being modified.\n     * @param line the string in question.\n     * @param rowsPerBeat the number of rows per beat for this purpose.\n     */\n    public static processTimeSignatures(out: TimingData, line: string, rowsPerBeat: number = -1): void {\n        const vs1 = line.split(',');\n        for (const s1 of vs1) {\n            const vs2 = s1.split('=');\n            if (vs2.length < 3) {\n                console.error(`.sm data has invalid time signature change with ${vs2.length} values, ignored`);\n                continue;\n            }\n\n            const beat = this.rowToBeat(vs2[0], rowsPerBeat);\n            const numerator = Helpers.stringToInt(vs2[1]);\n            const denominator = Helpers.stringToInt(vs2[2]);\n\n            if (beat < 0) {\n                console.error(`.sm data has invalid time signature change with beat ${beat}, ignored`);\n                continue;\n            }\n            if (numerator < 1) {\n// tslint:disable-next-line: max-line-length\n                console.error(`.sm data has invalid time signature change with beat ${beat}, numerator ${numerator}, ignored`);\n                continue;\n            }\n            if (denominator < 1) {\n// tslint:disable-next-line: max-line-length\n                console.error(`.sm data has invalid time signature change with beat ${beat}, denominator ${denominator}, ignored`);\n                continue;\n            }\n\n            out.addSegment(new TimeSignatureSegment(NoteHelpers.beatToNoteRow(beat), numerator, denominator));\n        }\n    }\n\n    /**\n     * Process the Tickcount Segments from the string.\n     * @param out the TimingData being modified.\n     * @param line the string in question.\n     * @param rowsPerBeat the number of rows per beat for this purpose.\n     */\n    public static processTickcounts(out: TimingData, line: string, rowsPerBeat: number = -1): void {\n        const arrayTickcountExpressions = line.split(',');\n        for (const expression of arrayTickcountExpressions) {\n            const arrayTickcountValues = expression.split('=');\n            if (arrayTickcountValues.length !== 2) {\n// tslint:disable-next-line: max-line-length\n                console.error(`.sm data has invalid #TICKCOUNTS value \"${expression}\" (must have exactly one \"=\"), ignored`);\n                continue;\n            }\n\n            const tickcountBeat = this.rowToBeat(arrayTickcountValues[0], rowsPerBeat);\n            // TODO: emulate try/catch stuff\n            // This parseInt is intended, as the source code used it and not the helper function here\n            const ticks = parseInt(arrayTickcountValues[1], 10);\n            if (isNaN(ticks)) {\n                continue;\n            }\n            const clampedTicks = Helpers.clamp(ticks, 0, ROWS_PER_BEAT);\n            out.addSegment(new TickcountSegment(NoteHelpers.beatToNoteRow(tickcountBeat), ticks));\n        }\n    }\n\n    /**\n     * Process BPM and stop segments from the data.\n     * @param out the TimingData being modified.\n     * @param vBPMs the vector of BPM changes.\n     * @param vStops the vector of stops.\n     */\n    public static processBpmsAndStops(out: TimingData, bpms: SongTimingInfo, stops: SongTimingInfo): void {\n        // Precondition: no BPM change or stop has 0 for its value (change.second).\n        //     (The ParseBPMs and ParseStops functions make sure of this.)\n        // Postcondition: all BPM changes, stops, and warps are added to the out\n        //     parameter, already sorted by beat.\n        // REMOVEME: Iterator declarations\n        // Current BPM (positive or negative)\n        let bpm = 0;\n        // Beat at which the previous timing change occurred\n        let prevbeat = 0;\n        // Start/end of current warp (-1 if not currently warping)\n        let warpstart = -1;\n        let warpend = -1;\n        // BPM prior to current warp, to detect if it has changed\n        let prewarpbpm = 0;\n        // How far off we have gotten due to negative changes\n        let timeofs = 0;\n\n        // Sort BPM changes and stops by beat. Order matters.\n        // TODO(StepMania): Make sorted lists a precondition rather than sorting them here.\n        // The caller may know that the lists are sorted already (e.g. if\n        // loaded from cache).\n        // It's a list of pairs so we sort by the first value (beat).\n        const compareFirst = (a: { [key: number]: number }, b: { [key: number]: number }): number => a[0] - b[0];\n        bpms.sort(compareFirst);\n        stops.sort(compareFirst);\n\n        // NOTE: the following code was done with iterators in C++. This is my ugly interpretation.\n        // TODO: once the tests are working change this to be more JavaScript-ey\n\n        // Convert stops that come before beat 0.  All these really do is affect\n        // where the arrows are with respect to the music, i.e. the song offset.\n        // Positive stops subtract from the offset, and negative add to it.\n        let stopIndex = 0;\n        const stopMax = stops.length;\n        for (const stopPair of stops) {\n            if (stopPair[0] >= 0) {\n                break;\n            }\n            out.adjustOffset(-stopPair[1]);\n            stopIndex++;\n        }\n\n        // Get rid of BPM changes that come before beat 0.  Positive BPMs before\n        // the chart don't really do anything, so we just ignore them.  Negative\n        // BPMs cause unpredictable behavior, so ignore them as well and issue a\n        // warning.\n        let bpmIndex = 0;\n        const bpmMax = bpms.length;\n        for (const bpmPair of bpms) {\n            if (bpmPair[0] >= 0) {\n                break;\n            }\n            bpm = bpmPair[1];\n            if (bpm < 0 && bpmPair[1] < 0) {\n                console.debug('.sm data has a negative BPM prior to beat 0. These cause problems; ignoring.');\n            }\n            bpmIndex++; // Keep track of where we got to in negative bpms\n        }\n\n        // It's beat 0.  Do you know where your BPMs are?\n        if (bpm === 0) {\n            // Nope.  Can we just use the next BPM value?\n            if (bpmIndex === bpmMax) {\n                // Nope.\n                bpm = 60;\n                console.debug('.sm data has no valid BPMs. Defaulting to 60.');\n            } else {\n                // Yep. Get the next BPM.\n                bpm = bpms[bpmIndex][1];\n                bpmIndex++;\n                console.debug('.sm data does not establish a BPM before beat 0. ' +\n                              'Using the value from the next BPM change');\n            }\n        }\n        // We always want to have an initial BPM.  If we start out warping, this\n        // BPM will be added later.  If we start with a regular BPM, add it now.\n        if (bpm > 0 && bpm <= FAST_BPM_WARP) {\n            out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(0), bpm));\n        }\n\n        // Iterate over all BPMs and stops in tandem\n        while (bpmIndex < bpmMax || stopIndex < stopMax) {\n            // Get the next change in order, with BPMs taking precedence\n            // when they fall on the same beat.\n            const changeIsBpm = (stopIndex === stopMax) ||\n                (bpmIndex < bpmMax && bpms[bpmIndex][0] <= stops[stopIndex][0]);\n            const change = changeIsBpm ? bpms[bpmIndex] : stops[stopIndex];\n\n            // Calculate the effects of time at the current BPM.  \"Infinite\"\n            // BPMs (SM4 warps) imply that zero time passes, so skip this\n            // step in that case.\n            if (bpm <= FAST_BPM_WARP) {\n                timeofs += (change[0] - prevbeat) * 60 / bpm;\n\n                // If we were in a warp and it finished during this\n                // timeframe, create the warp segment.\n                if (warpstart >= 0 && bpm > 0 && timeofs > 0) {\n                    // timeofs represents how far past the end we are\n                    warpend = change[0] - (timeofs * bpm / 60);\n                    // warpend and warpstart are floats in the StepMania code, use appropriate constructor\n                    out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\n                        warpend - warpstart, false));\n\n                    // If the BPM changed during the warp, put that\n                    // change at the beginning of the warp.\n                    if (bpm !== prewarpbpm) {\n                        out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(warpstart), bpm));\n                    }\n                    // No longer warping\n                    warpstart = -1;\n                }\n            }\n\n            // Save the current beat for the next round of calculations\n            prevbeat = change[0];\n\n            // Now handle the timing changes themselves\n            if (changeIsBpm) {\n                // Does this BPM change start a new warp?\n                if (warpstart < 0 && (change[1] < 0 || change[1] > FAST_BPM_WARP)) {\n                    // Yes.\n                    warpstart = change[0];\n                    prewarpbpm = bpm;\n                    timeofs = 0;\n                } else if (warpstart < 0) {\n                    // No, and we aren't currently warping either.\n                    // Just a normal BPM change.\n                    out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(change[0]), change[1]));\n                }\n                bpm = change[1];\n                bpmIndex++;\n            } else {\n                // Does this stop start a new warp?\n                if (warpstart < 0 && change[1] < 0) {\n                    // Yes.\n                    warpstart = change[0];\n                    prewarpbpm = bpm;\n                    timeofs = change[1];\n                } else if (warpstart < 0) {\n                    // No, and we aren't currently warping either.\n                    // Just a normal stop.\n                    out.addSegment(new StopSegment(NoteHelpers.beatToNoteRow(change[0]), change[1]));\n                } else {\n                    // We're warping already. Stops affect the time\n                    // offset directly.\n                    timeofs += change[1];\n\n                    // If a stop overcompensates for the time\n                    // deficit, the warp ends and we stop for the\n                    // amount it goes over.\n                    if (change[1] > 0 && timeofs > 0) {\n                        warpend = change[0];\n                        // warpend and warpstart are floats in the StepMania code, use appropriate constructor\n                        out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\n                            warpend - warpstart, false));\n                        out.addSegment(new StopSegment(NoteHelpers.beatToNoteRow(change[0]), timeofs));\n\n                        // Now, are we still warping because of\n                        // the BPM value?\n                        if (bpm < 0 || bpm > FAST_BPM_WARP) {\n                            // Yep.\n                            warpstart = change[0];\n                            // prewarpbpm remains the same\n                            timeofs = 0;\n                        } else {\n                            // Nope, warp is done.  Add any\n                            // BPM change that happened in\n                            // the meantime.\n                            if (bpm !== prewarpbpm) {\n                                // bpm is a float in the StepMania code, use appropriate constructor\n                                out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart), bpm, false));\n                            }\n                            warpstart = -1;\n                        }\n                    }\n                }\n                stopIndex++;\n            }\n        }\n\n        // If we are still warping, we now have to consider the time remaining\n        // after the last timing change.\n        if (warpstart >= 0) {\n            // Will this warp ever end?\n            if (bpm < 0 || bpm > FAST_BPM_WARP) {\n                // No, so it ends the entire chart immediately.\n                // XXX There must be a less hacky and more accurate way\n                // to do this.\n                warpend = 99999999;\n            } else {\n                // Yes. Figure out when it will end.\n                warpend = prevbeat - (timeofs * bpm / 60);\n            }\n            // warpend and warpstart are floats in the StepMania code, use appropriate constructor\n            out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\n                 warpend - warpstart, false));\n\n            // As usual, record any BPM change that happened during the warp\n            if (bpm !== prewarpbpm) {\n                out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(warpstart), bpm));\n            }\n        }\n    }\n\n    /**\n     * Attempt to load the specified sm data.\n     * @param msdFile: an MsdFile with the parsed fields for the data.\n     * @return a Song that has the song information.\n     */\n    public static loadFromSimfile(msdFile: MsdFile): Song {\n        const song = new Song();\n\n        const reusedSongInfo: SongTagInfo = {\n            song,\n            params: [],\n            bpmChanges: [],\n            stops: [],\n        };\n\n        for (let i = 0; i < msdFile.getNumValues(); i++) {\n            const numParams = msdFile.getNumParams(i);\n            const params = msdFile.getValue(i);\n            const valueName = params[0].toUpperCase();\n            reusedSongInfo.params = params; // Ensure we're passing params in\n\n            const handler = songTagHandlers.get(valueName);\n            if (handler !== undefined) {\n                handler(reusedSongInfo);\n                // We ignore #BGCHANGES.* because we don't care about backgrounds\n            } else if (valueName === 'NOTES' || valueName === 'NOTES2') {\n                if (numParams < 7) {\n                    throw new Error(`.sm file has ${numParams} fields in a #NOTES tag, but should have at least 7.`);\n                }\n\n                const steps = this.loadFromTokens(\n                    params[1],\n                    params[2],\n                    params[3],\n                    params[4],\n                    params[6],\n                    song,\n                );\n                steps.decompress();\n                song.addSteps(steps);\n            }\n        }\n        if (!song.hasSteps()) {\n            throw new Error('did not find step data for song');\n        }\n\n        // Turn negative time changes into warps\n        this.processBpmsAndStops(song.songTiming, reusedSongInfo.bpmChanges, reusedSongInfo.stops);\n\n        // Do a cascade through all our data structures to tidy up any edge cases or\n        // backwards compatibility issues that exist.\n        this.tidyUpData();\n        // In StepMania this is only called when adding the song to the cache.\n        // We have no cache so do it here. -Struz\n        song.tidyUpData();\n\n        // IMPORTANT: write my own cascade of tidyUpData() functions and call them here\n        // Cut out any things that aren't necessary.\n        // Line 633 in Song.cpp is the motherload.\n        // Read this file carefully! It has gems like not allowing multiple steps of the same StepsType and Difficulty.\n\n        return song;\n    }\n\n    /**\n     * Retrieve the relevant notedata from the simfile.\n     * @param msdFile the .sm file data.\n     * @returns the Steps we loaded the data into.\n     */\n    // NOTE: commented out because currently unused\n    // public static loadNoteDataFromSimfile(msdFile: MsdFile): Steps {\n    //     for (let i = 0; i < msdFile.getNumValues(); i++) {\n    //         const numParams = msdFile.getNumParams(i);\n    //         const params = msdFile.getValue(i);\n    //         const valueName = params[0].toUpperCase();\n\n    //         // The only tag we care about is the #NOTES tag.\n    //         if (valueName === 'NOTES' || valueName === 'NOTES2') {\n    //             if (numParams < 7) {\n    //                 throw new Error(`.sm file has ${numParams} fields in a #NOTES tag, but should have at least 7.`);\n    //             }\n\n    //             const stepsType: string = params[1].trim();\n    //             const description: string = params[2].trim();\n    //             let difficulty: string = params[3].trim();\n\n    //             // Hack - if this is a .edit file, fudge the difficulty\n    //             // TODO: we have no way to know this given the data pasted in,\n    //             // but StepMania does it by the .edit extension\n\n    //             // Old version difficulty changes\n    //             if (difficulty === 'smaniac') {\n    //                 difficulty = 'Challenge';\n    //             }\n    //             if (difficulty === 'hard') {\n    //                 if (description === 'smaniac' || description === 'challenge') {\n    //                     difficulty = 'Challenge';\n    //                 }\n    //             }\n\n    //             // OMITTED: if the stepsType, description, and difficulty match, don't load the\n    //             // data. Probably for performance reasons.\n\n\n    //             const noteData: string = params[6].trim();\n    //             const steps = new Steps(noteData);\n    //             steps.decompress();\n    //             steps.tidyUpData();\n    //             return steps;\n    //         }\n    //     }\n    //     throw new Error('could not find note data');\n    // }\n\n    /**\n     * @brief Perform some cleanup on the loaded song.\n     * @param song a reference to the song that may need cleaning up.\n     */\n    public static tidyUpData() {\n        // IGNORED: a bunch of background changes. First cut isn't going to support background / foreground gimmicks.\n        // IGNORED: we never load from cache so we shouldn't have to call song.tidyUpData() here\n    }\n}\nexport default NoteLoaderSM;\n","import axios from 'axios';\nimport { Howl } from 'howler';\n\nconst OGG_LOAD_TIMEOUT = 60000; // Milliseconds\nconst OGG_LOAD_POLL    = 200;   // Milliseconds\n\nclass FileOperations {\n    public static loadTextFile(uri: string) {\n        return axios.get(uri, {responseType: 'text'}).then((response) => {\n            return response.data;\n        });\n    }\n\n    public static loadOggFileAsHowl(uri: string): Promise<Howl> {\n        let loaded = false;\n        let error: Error | null = null;\n        const oggHowl = new Howl({\n            src: [uri],\n            onload: () => {\n                loaded = true;\n            },\n            onloaderror: (_, msg) => {\n                error = new Error(`error loading .ogg file at ${uri}: ${msg}`);\n            },\n        });\n\n        return new Promise((resolve, reject) => {\n            const startTime = Date.now();\n            const timeout = OGG_LOAD_TIMEOUT;\n            const checkLoaded = () => {\n                if (loaded) {\n                    console.log(`succesfully loaded .ogg file at ${uri}`);\n                    resolve(oggHowl);\n                } else if (error !== null) {\n                    throw error;\n                } else if (Date.now() > startTime + timeout) {\n                    throw new Error(`timed out after ${timeout}ms while loading .ogg file at ${uri}`);\n                } else {\n                    setTimeout(checkLoaded, OGG_LOAD_POLL);\n                }\n            };\n            checkLoaded();\n        });\n    }\n}\nexport default FileOperations;\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport Vue from 'vue';\nimport { Component } from 'vue-property-decorator';\n\nimport Screen from './components/Screen.vue';\nimport ChartPicker from './components/ChartPicker.vue';\n\nimport { Howl } from 'howler';\nimport GameLoop from './lib/GameLoop';\nimport SCREENMAN from '@/lib/ScreenManager.ts';\n\n// Register our main loop as soon as the page loads\n// TODO: work out why this is so much better for syncing claps\n// than the pixi ticker. It may just be that we want the audio\n// loops way faster than screen draws.\n// NOTE: very well might have been placebo from the two tries.\n// Had the best sync ever with the ticker. I think what happened\n// was that I didn't wait for the ticker to warm up - pressing test\n// too early on page load fucks the syncing.\n(() => {\n  function main() {\n    const stopMain = window.requestAnimationFrame( main );\n\n    // Your main loop contents\n    GameLoop.gameLoop(0);\n  }\n\n  main(); // Start the cycle\n})();\n\nimport GAMESTATE from '@/lib/GameState';\nimport MsdFile from '@/lib/MsdFile';\nimport NoteLoaderSM from '@/lib/NoteLoaderSM';\nimport Song from '@/lib/Song';\nimport SOUNDMAN, { MusicToPlay } from '@/lib/GameSoundManager';\nimport { DebugTools } from '@/lib/Debug';\nimport { ChartURLs } from './lib/ChartPicker';\nimport FileOperations from './lib/FileOperations';\n\n// This can be overridden with the process.env.VUE_APP_PACK_URL_PREFIX environment variable\nconst DEFAULT_PACK_URL_PREFIX = 'https://s3-us-west-2.amazonaws.com/struz.simfile-viewer/';\n\ndeclare global {\n  interface Window {\n    debugTools: any;\n    noteField: any;\n    GAMESTATE: any;\n    SOUNDMAN: any;\n  }\n}\n// For live debugging\nwindow.debugTools = DebugTools;\nwindow.GAMESTATE = GAMESTATE;\nwindow.SOUNDMAN = SOUNDMAN;\n\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\n@Component({\n  name: 'App',\n  components: {\n    Screen,\n    ChartPicker,\n  },\n})\nclass App extends Vue {\n  public seek = 0;\n  public packPathPrefix = process.env.VUE_APP_PACK_URL_PREFIX || DEFAULT_PACK_URL_PREFIX;\n\n  public seekTrack() {\n    SOUNDMAN.musicSeek(this.$data.seek);\n  }\n\n  public playPauseTrack() {\n    if (!GAMESTATE.isPaused()) {\n      GAMESTATE.pause();\n      SOUNDMAN.pauseMusic();\n    } else {\n      GAMESTATE.play();\n      SOUNDMAN.resumeMusic();\n    }\n  }\n\n  public changeChart(urls: ChartURLs) {\n    // Use GAMEMAN and other helpers to load the chart\n    // Use FileOperations to do the heavy lifting, use the onload to set something\n    // in GAMEMAN or this class that disables the loading bar and allows playing\n    if (urls.ogg === null) { throw new Error('no ogg not supported yet!'); }\n\n    let newSong: Song | null;\n    const absoluteSimURI = `${this.packPathPrefix}packs/${urls.simFile}`;\n    const p1 = FileOperations.loadTextFile(absoluteSimURI)\n      .then((smText) => {\n        const msdFile = new MsdFile(smText);\n        newSong = NoteLoaderSM.loadFromSimfile(msdFile);\n        console.log('loaded sm data');\n      })\n      .catch((error) => {\n        console.error(`failed to load .sm file at '${absoluteSimURI}': ${error}`);\n      });\n\n    let newHowl: Howl | null;\n    const absoluteHowlURI = `${this.packPathPrefix}packs/${urls.ogg}`;\n    const p2 = FileOperations.loadOggFileAsHowl(absoluteHowlURI)\n      .then((howl) => {\n        newHowl = howl;\n        console.log('loaded music');\n      })\n      .catch((error) => {\n        console.error(`failed to load .ogg file at '${absoluteHowlURI}': ${error}`);\n      });\n\n    // Once both parts have been loaded, tee up the new song\n    Promise.all([p1, p2])\n      .then(() => {\n        if (newSong === null) { throw new Error('song did not load properly'); }\n        if (newHowl === null) { throw new Error('howl did not load properly'); }\n        GAMESTATE.loadSong(newSong, newHowl, this.$data.seek);\n      })\n      .catch((error) => {\n        console.error(`failed to load song into game: ${error}`);\n      });\n    console.log('chart changed: ' +  urls.ogg);\n  }\n}\nexport default App;\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vuetify-loader/lib/loader.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vuetify-loader/lib/loader.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=50d27166&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!/atlassian-home/src/private/simfile-viewer/node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VApp } from 'vuetify/lib'\nimport { VBtn } from 'vuetify/lib'\nimport { VContainer } from 'vuetify/lib'\nimport { VContent } from 'vuetify/lib'\nimport { VFlex } from 'vuetify/lib'\nimport { VLayout } from 'vuetify/lib'\nimport { VSpacer } from 'vuetify/lib'\nimport { VTextField } from 'vuetify/lib'\nimport { VToolbar } from 'vuetify/lib'\nimport { VToolbarTitle } from 'vuetify/lib'\ninstallComponents(component, {VApp,VBtn,VContainer,VContent,VFlex,VLayout,VSpacer,VTextField,VToolbar,VToolbarTitle})\n","import Vue from 'vue';\nimport './plugins/vuetify';\nimport App from './App.vue';\n\nVue.config.productionTip = false;\n\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app');\n","module.exports = __webpack_public_path__ + \"media/assist_clap.131e5c1e.ogg\";"],"sourceRoot":""}