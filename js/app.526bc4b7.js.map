{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/assets/noteskins/USWCelETT/_Down_Tap_Note_16x8.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_Body_Active.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_Body_Inactive.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_BottomCap_active.png","webpack:///./src/components/Screen.vue?fd05","webpack:///./src/assets/noteskins/USWCelETT/Down_Roll_BottomCap_Inactive.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Hold_BottomCap_inactive.png","webpack:///./src/assets/noteskins/common/Fallback_Tap_Mine_8x1.png","webpack:///./src/assets/noteskins/USWCelETT/_Down_Receptor_Go_4x1.png","webpack:///./src/assets/noteskins/USWCelETT/Down_Roll_Body_Inactive.png","webpack:///./src/plugins/vuetify.ts","webpack:///./src/App.vue?8cb9","webpack:///./src/lib/entities/EntitiesConstants.ts","webpack:///./src/components/Screen.vue?bcd9","webpack:///./src/lib/PlayerNumber.ts","webpack:///./src/lib/ResourceManager.ts","webpack:///./src/lib/entities/EntityManager.ts","webpack:///./src/lib/entities/Entity.ts","webpack:///./src/lib/entities/GameSprite.ts","webpack:///./src/lib/entities/AnimatedGameSprite.ts","webpack:///./src/lib/entities/TapNoteReceptorSprite.ts","webpack:///./src/lib/NoteTypes.ts","webpack:///./src/lib/TimingSegments.ts","webpack:///./src/lib/TimingData.ts","webpack:///./src/lib/GameTimer.ts","webpack:///./src/lib/GameConstantsAndTypes.ts","webpack:///./src/lib/SongSound.ts","webpack:///./src/lib/GameSoundManager.ts","webpack:///./src/lib/Debug.ts","webpack:///./src/lib/SongPosition.ts","webpack:///./src/lib/PlayerState.ts","webpack:///./src/lib/Error.ts","webpack:///./src/lib/GameState.ts","webpack:///./src/lib/ArrowEffects.ts","webpack:///./src/lib/entities/TapNoteSprite.ts","webpack:///./src/lib/entities/TapMineSprite.ts","webpack:///./src/lib/entities/BodyAndCapNote.ts","webpack:///./src/lib/entities/HoldTailSprite.ts","webpack:///./src/lib/entities/RollTailSprite.ts","webpack:///./src/lib/entities/NoteField.ts","webpack:///./src/lib/ScreenManager.ts","webpack:///./src/components/Screen.vue?08f1","webpack:///./src/lib/NoteData.ts","webpack:///./src/components/Screen.vue?9bde","webpack:///./src/components/Screen.vue","webpack:///./src/components/ChartPicker.vue?106e","webpack:///./src/lib/FileOperations.ts","webpack:///./src/lib/Steps.ts","webpack:///./src/lib/NoteDataUtil.ts","webpack:///./src/lib/Song.ts","webpack:///./src/lib/NoteLoaderSM.ts","webpack:///./src/lib/MsdFile.ts","webpack:///./src/components/ChartPicker.vue?33d0","webpack:///./src/components/ChartPicker.vue?16f8","webpack:///./src/components/ChartPicker.vue","webpack:///./src/lib/RhythmAssist.ts","webpack:///./src/lib/GameLoop.ts","webpack:///./src/App.vue?5dd0","webpack:///./src/App.vue?aea5","webpack:///./src/App.vue","webpack:///./src/main.ts","webpack:///./src/assets/sounds/assist_clap.ogg"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","app","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Screen_vue_vue_type_style_index_0_id_1165683c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_vuetify_loader_lib_loader_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Screen_vue_vue_type_style_index_0_id_1165683c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default","vue_runtime_esm","use","lib","iconfont","TapNoteDirection","Appvue_type_template_id_8d3d7042_render","_vm","this","_h","$createElement","_c","_self","attrs","dark","staticClass","_v","flat","href","target","row","md6","on","click","playPauseTrack","seekTrack","type","model","callback","$$v","seek","_n","expression","staticRenderFns","Screenvue_type_template_id_1165683c_scoped_true_render","ref","_t","Screenvue_type_template_id_1165683c_scoped_true_staticRenderFns","TAPNOTE_WIDTH_PX","TAPNOTE_HEIGHT_PX","HOLD_BOTTOM_CAP_HEIGHT_PX","directionToLaneIndex","direction","DOWN","LEFT","UP","RIGHT","Error","concat","laneIndexToDirection","laneIndex","PlayerNumber","LANE_MARGIN","DOWN_TAP_NOTE_SHEET_NAME","DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME","TAP_MINE_SHEET_NAME","DOWN_HOLD_BODY_ACTIVE_SHEET_NAME","DOWN_HOLD_BODY_INACTIVE_SHEET_NAME","DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME","DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME","DOWN_ROLL_BODY_INACTIVE_SHEET_NAME","DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME","SPRITE_DEFINITIONS","textureUrl","_Down_Tap_Note_16x8_default","a","width","height","numSprites","numAnimFrames","animLength","animLoop","_Down_Receptor_Go_4x1_default","Fallback_Tap_Mine_8x1_default","Down_Hold_Body_Active_default","Down_Hold_Body_Inactive_default","Down_Hold_BottomCap_active_default","Down_Hold_BottomCap_inactive_default","Down_Roll_Body_Inactive_default","Down_Roll_BottomCap_Inactive_default","ResourceManager_ResourceManager","ResourceManager","classCallCheck","spriteInfo","map_default","doneLoading","spriteTextures","undefined","loader","lib_ScreenManager","getPixiApp","_i","_SPRITE_DEFINITIONS","add","load","onLoad","_i2","_SPRITE_DEFINITIONS2","extractTexturesFromSpriteSheet","sprite","spriteTexture","resources","texture","sprites","spriteAnimTextures","f","rectangle","pixi_legacy_es","spriteFrame","baseTexture","set","textures","instance","RESOURCEMAN","getInstance","lib_ResourceManager","EntityManager_EntityManager","EntityManager","entities","createClass","entity","deltaTime","forEach","update","ENTITYMAN","entities_EntityManager","Entity_Entity","Entity","registerEntity","deregisterEntity","entities_Entity","GameSprite_GameSprite","GameSprite","_this","possibleConstructorReturn","getPrototypeOf","onStage","zIndex","anchor","x","y","isDoneLoading","removeFromStage","stage","addChild","removeChild","z","entities_GameSprite","AnimatedGameSprite_AnimatedGameSprite","AnimatedGameSprite","spriteIndex","arguments","animationSpeed","loop","entities_AnimatedGameSprite","RECEPTOR_MARGIN_TOP_PX","TapNoteReceptorSprite_TapNoteReceptorSprite","TapNoteReceptorSprite","checkDependencies","getSpriteInfo","alpha","rotation","Math","PI","play","entities_TapNoteReceptorSprite","NUM","TapNoteType","TapNoteSubType","TapNoteSource","PLAYER_INVALID","Invalid","NoteTypes_TapNoteResult","TapNoteResult","NoteTypes_HoldNoteResult","HoldNoteResult","NoteType","NoteTypes_TapNote","TapNote","Empty","subType","source","Original","pn","occursAtSecond","endSecond","highestSubtypeOnRow","Hold","duration","holdResult","other","assign_default","create_default","get_prototype_of_default","Fake","console","debug","tapNote","NoteTypes_NoteHelpers","NoteHelpers","beatNum","round","ROWS_PER_BEAT","trunc","start","newLength","position","nt","N_4TH","N_8TH","N_12TH","N_16TH","N_24TH","N_32ND","N_48TH","N_64TH","N_192ND","ROWS_PER_MEASURE","beat","getNoteType","beatToNoteRow","NoteTypes","MAX_NOTE_ROW","TimingSegmentType","SegmentEffectType","BEATS_PER_MEASURE","NoteTypes_TapNotes","TapNotes","EMPTY","copy","ORIGINAL_TAP","ORIGINAL_LIFT","ORIGINAL_HOLD_HEAD","ORIGINAL_ROLL_HEAD","ORIGINAL_MINE","ORIGINAL_ATTACK","ORIGINAL_AUTO_KEYSOUND","ORIGINAL_FAKE","ADDITION_TAP","ADDITION_MINE","Tap","Lift","HoldHead","Roll","Mine","Attack","AutoKeysound","Addition","ROW_INVALID","TimingSegments_TimingSegment","TimingSegment","beatOrRow","isRow","startRow","setRow","scalePosition","getRow","noteRowToBeat","dec","getBeat","toString","num1","num2","abs","EPSILON","TimingSegments_WarpSegment","_TimingSegment","WarpSegment","lengthRowsOrBeats","isRows","lengthRows","inherits","WARP","Range","getLengthBeats","rows","beats","startBeat","endBeat","getLength","newStartBeat","newEndBeat","setLengthBeats","getType","getLengthRows","lengthBeats","toFixed","compareFloat","TimingSegments_TickcountSegment","_TimingSegment2","TickcountSegment","_this2","ticks","DEFAULT_TICK_COUNT","ticksPerBeat","TICKCOUNT","Indefinite","getTicks","FoundEventType","TimingSegments_TimeSignatureSegment","_TimingSegment3","TimeSignatureSegment","_this3","numerator","denominator","TIME_SIG","num","den","getNum","getDen","TimingSegments_BPMSegment","_TimingSegment4","BPMSegment","_this4","bpm","bps","setBpm","BPM","getBpm","TimingSegments_StopSegment","_TimingSegment5","StopSegment","_this5","seconds","STOP","Row","pause","getPause","TimingSegments_DelaySegment","_TimingSegment6","DelaySegment","_this6","DELAY","INVALID_INDEX","DummySegments","TimingData_GetBeatArgs","GetBeatArgs","elapsedTime","bpsOut","warpDestOut","warpBeginOut","freezeOut","delayOut","TimingData_GetBeatStarts","GetBeatStarts","warp","stop","delay","lastRow","lastTime","warpDestination","isWarping","TimingData_TimingData","TimingData","beatStartLookup","timeStartLookup","beat0OffsetInSecs","timingSegments","args","maxSegment","segs","bpms","warps","stops","delays","curSegment","getBpmAtRow","eventRow","max_safe_integer_default","eventType","NOT_FOUND","findEvent","timeToNextEvent","nextEventTime","WARP_DESTINATION","BPM_CHANGE","getBps","STOP_DELAY","delaySeg","stopSeg","warpSeg","warpSum","Number","MAX_VALUE","findMarker","MARKER","releaseLookup","segmentsPerLookup","totalSegments","beatStart","getBeatInternal","timeStart","getElapsedTimeInternal","index","lookup","lit","item","starts","bpmInfo","segInfoStr","warpInfo","stopInfo","delayInfo","str","dumpOneLookupTable","tst","noteRow","segments","getTimingSegments","retSegment","getSegmentIndexAtRow","seg","getEffectType","_retSegment","getSegmentAtRow","getBpmSegmentAtRow","getStopSegmentAtRow","getDelaySegmentAtRow","beatRow","getStopAtRow","getDelayAtRow","isWarpAtRow","isFakeAtRow","isJudgableAtRow","amount","setOffset","offset","cur","isNotable","onSameRow","prev","next","equals","findIndex","ts","lessThan","cpy","measureIndexOut","beatIndexOut","rowsRemainder","tSigs","curSig","segmentEndRow","rowsPerMeasureThisSegment","getNoteRowsPerMeasure","rowsPerBeatThisSegment","getNoteRowsPerBeat","numRowsThisSegment","numMeasuresThisSegment","_numRowsThisSegment","_numMeasuresThisSegment","min","max","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","get_iterator_default","done","err","return","getNextSegmentBeatAtRow","backup","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","getPreviousSegmentBeatAtRow","getBeatAndBpsFromElapsedTime","second","getBeatFromElapsedTime","lookedUpStart","findEntryInLookup","getElapsedTimeFromBeatNoOffset","getBeatAndBpsFromElapsedTimeNoOffset","songBeat","musicSeconds","speeds","SPEED","allowEmpty","empty","warn","addSegment","entry","lower","upper","lookupItem","status","tmpRow","lib_TimingData","TIMESTAMP_RESOLUTION","NANOSECONDS_PER_MICROSECOND","GameTimer_GameTimer","GameTimer","secs","us","touch","now","subtract","time","getTime","diff","difference","ago","probableDelay","tm","sum","rhs","browser_process_hrtime_default","initTimeSecs","initTimeUs","deltaSecs","deltaUs","lhs","ret","StepsTypeCategory","StepsType","lib_GameTimer","gZeroTimer","EXPECTED_FPS","Difficulty","GameConstantsAndTypes_StepsTypeInfo","StepsTypeInfo","stepTypeName","numTracks","allowAutogen","stepsTypeCategory","StepsTypeInfos","Single","Double","Couple","Routine","OldStyleStringToDifficultyMap","Beginner","Easy","Medium","Hard","Challenge","Edit","GameConstantsAndTypes_Helpers","Helpers","stepsType","st","oldDifficulty","difficulty","toLowerCase","HHMMSS","arrayBits","split","stringToInt","stringToFloat","gameEnum","iterator","keys","keys_default","map","k","int","parse_int_default","isNaN","float","parse_float_default","h","l1","h1","l2","h2","lerp","GameConstantsAndTypes","SongSound_SongSound","SongSound","sound","at","timeElapsed","lib_SongSound","MAX_TOLERATED_DRIFT_SECS","DRIFT_SECS_BEFORE_UPDATE","GameSoundManager_MusicPlaying","MusicPlaying","music","timing","hasTiming","applyMusicRate","GameSoundManager_MusicToPlay","MusicToPlay","startSeconds","lengthSeconds","fadeInLengthSeconds","fadeOutLengthSeconds","forceLoop","alignBeat","GameSoundManager_GameSoundManager","GameSoundManager","updatingTimer","beatLastCrossed","outOfSyncSecs","musicPlaying","seekTimeSeconds","currentTimeSeconds","getTimeElapsed","toPlay","state","newMusic","getSound","handleSongTimer","playbackRate","lib_GameState","curSong","updateSongPosition","songTiming","rowNow","beatToNoteRowNotRounded","beatNow","resyncSongTimingWithMusicPosition","updateIfMusicNotPlaying","playing","musicPlayingPosSeconds","drift","log","SOUNDMAN","lib_GameSoundManager","DEBUG_ASSERT","cond","trace","ASSERT","message","Debug_DebugTools","DebugTools","pauseMusic","resumeMusic","numFrames","timeAdvanceSeconds","musicSkipforwards","getMusicTimeSeconds","getMusicTiming","SongPosition_SongPosition","SongPosition","songBeatNoOffset","curBps","freeze","warpBeginRow","lastBeatUpdate","musicSecondsVisible","songBeatVisible","positionSeconds","timestamp","isZero","beatInfo","getBeatFromElapsedTimeNoOffset","lib_SongPosition","PlayerState_PlayerState","PlayerState","playerNumber","PLAYER_1","readBPM","delta","isUsingStepTiming","steps","curSteps","timingData","Error_NotImplementedError","_Error","NotImplementedError","wrapNativeSuper","GameState_GameState","GameState","lastPositionTimer","lastPositionSeconds","paused","selectedSteps","playerState","forEachEnum","hasteRate","reset","newSong","resetMusicStatistics","setCurSong","prepareLookup","isHandlingSongTimer","setBgmTime","timeNoOffset","beatNoOffset","currentBgmTime","currentBgmBeat","currentBgmTimeNoOffset","currentBgmBeatNoOffset","currentBgmBeatPlayer","currentBgmBeatPlayerNoOffset","setPlayerBgmBeat","GAMESTATE","songData","songMusic","loadNextSong","startMusic","ARROW_SPACING","ArrowEffects_ArrowEffects","noteBeat","peakYOffsetOut","isPastPeakOut","yOffset","getSteps","timeSpacing","ArrowEffects","getDisplayedBeat","getDisplayedSpeedPercent","songSeconds","noteSeconds","getElapsedTimeFromBeat","secondsUntilStep","scrollBpm","yOffsetTimeSpacing","scrollSpeed","maxScrollBpm","readBpm","displayedBeatCache","displayedBeat","velocity","noteStatCache","speedScrollSpeed","speedScrollBpm","lib_ArrowEffects","TapNoteSprite_TapNoteSprite","TapNoteSprite","noteType","beatToNoteType","setYPosBasedOnBeat","peakYOffset","getYOffset","entities_TapNoteSprite","TapMineSprite_TapMineSprite","TapMineSprite","entities_TapMineSprite","BodyAndCapNote_BodyAndCapNote","BodyAndCapNote","bodySpriteInfo","capSpriteInfo","calculateLongNoteHeight","firstBodySegmentTexStartY","firstBodySegmentTexHeight","bodyTilingSprite","remainingHeight","segmentHeight","bodySegmentTex","bodySegmentSprite","bodySpriteTex","bodySprite","bottomCapSprite","laneX","gs","getSprite","updateSprites","addToStage","headYPos","capYPos","tilingPosY","setPosY","entities_BodyAndCapNote","HoldTailSprite_HoldTailSprite","HoldTailSprite","entities_HoldTailSprite","RollTailSprite_RollTailSprite","RollTailSprite","entities_RollTailSprite","NoteField_NoteTrackData","NoteTrackData","tapNotes","holdCaps","NoteField_NoteField","NoteField","noteTracks","resetTracks","track","tn","destroy","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_tn","drawDistanceAfterTargetsPixels","low","high","hasCache","NUM_ITERATIONS","MAX_NOTES_AFTER","firstBeatToDraw","mid","isPastPeakYOffset","getNumNotesRange","drawDistanceBeforeTargetsPixels","displayedPosition","displayedTiming","searchDistance","lastBeatToDraw","speedMultiplier","notesLower","notesUpper","noteStatLow","getNumNotesFromBeginning","noteStatHigh","PIXELS_TO_DRAW_OFFSCREEN","findFirstDisplayedBeat","findLastDisplayedBeat","firstRow","nd","getNoteData","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","tnEntry","has","tnSprite","tailSprite","setZIndex","toDestroy","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","tnsEntry","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_tnsEntry","tnsAndTrackEntry","delete","updateNotes","entities_NoteField","ScreenManager_ScreenManager","ScreenManager","pixiApp","receptorsVisible","receptorSprites","options","view","renderCanvas","backgroundColor","forceCanvas","renderer","loadSprites","ticker","maxFPS","desiredFps","isInit","color","initOrder","_initOrder","receptor","visible","noteField","SCREENMAN","Screenvue_type_script_lang_ts_Screen","_Vue","Screen","$refs","offsetWidth","offsetHeight","initPixi","tslib_es6","vue_property_decorator","IteratorDirection","Screenvue_type_script_lang_ts_","components_Screenvue_type_script_lang_ts_","component","componentNormalizer","components_Screen","ChartPickervue_type_template_id_8bc634de_scoped_true_render","items","packs","item-text","item-value","label","change","$event","changePackEvent","selectedPack","charts","changeChartEvent","selectedChart","getStepsItemText","getStepsItemValue","changeStepsEvent","ChartPickervue_type_template_id_8bc634de_scoped_true_staticRenderFns","OGG_LOAD_TIMEOUT","OGG_LOAD_POLL","FileOperations_FileOperations","uri","axios_default","responseType","then","response","stream","loaded","error","oggHowl","howler","src","html5","onload","onloaderror","_","msg","promise_default","resolve","reject","startTime","now_default","timeout","checkLoaded","setTimeout","lib_FileOperations","NoteData_TrackMap","TrackMap","mapReverse","size","isSorted","proxy","startAt","endAt","sort","NoteData_TrackMapIterator","Forwards","values","iterator_default","Backwards","sortedEntriesAsc","toConsumableArray","entries","sortNumbersAsc","sortedEntriesDesc","reverse","mapProps","get_own_property_names_default","prop","skipOverride","indexOf","mapFunc","reverseMapFunc","wrapFunc","retVal","b","TrackMapIterator","it","end","compare","lastNextResult","value1","value2","FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE","last","fn","getNextTapNoteRowForAllTracks","DisplayBPM","NoteData_NoteData","NoteData","noteCounts","holdDurations","newNumTracks","trackMap","newEmpty","endRow","constIterator","rowInAndOut","ignoreAutoKeysounds","mapTrack","iter","closestNextRow","anyHaveNextNote","getNumTracks","newRowThisTrack","getNextTapNoteRowForTrack","reverseEntries","closestPrevRow","anyHavePrevNote","getPrevTapNoteRowForTrack","dest","rowBegin","rowEnd","clear","headRow","rowPbr","getTapNote","getFirstTrackWithTap","getFirstTrackWithTapOrHoldHead","lib_NoteData","NoteDataUtil_NoteDataUtil","NoteDataUtil","out","smNoteData_","smNoteData","indexCommentStart","indexCommentEnd","substr","clearAll","setNumTracks","loadFromSmNoteDataStringWithPlayer","emptyFilter","measures","trim","filter","measureIndex","measure","measureLines","lineIndex","line","percentIntoMeasure","trackIndex","noteChar","charAt","parseTapNoteData","setTapNote","_step$value","slicedToArray","_beat","removeTapNote","newOriginalTap","newOriginalHoldHead","newOriginalRollHead","isHoldNoteAtRow","holdNote","findTapNote","newOriginalMine","newOriginalAutoKeysound","newOriginalLift","newOriginalFake","Steps_Steps","Steps","noteData","song","stepsTypeName","description","chartStyle","meter","credit","chartName","displayBPMType","ACTUAL","specifiedBpmMin","specifiedBpmMax","noteDataIsFilled","noteDataCompressed","getStepsTypeInfo","loadFromSmNoteDataString","stepsTypeString","lib_Steps","Song_Song","Song","fileName","groupName","mainTitle","subTitle","artist","mainTitleTranslit","subTitleTranslit","artistTranslit","version","genre","origin","musicLengthSec","musicSampleStartSec","musicSampleLengthSec","displayBpmType","firstSecond","lastSecond","specifiedLastSecond","unknownStyleSteps","stepsByType","tidyUpData","lib_Song","FAST_BPM_WARP","SMSetTitle","info","params","SMSetSubtitle","SMSetArtist","SMSetTitleTranslit","SMSetSubtitleTranslit","SMSetArtistTranslit","SMSetGenre","SMSetCredit","SMSetBanner","SMSetBackground","SMSetLyricsPath","SMSetCDTitle","SMSetMusic","SMSetOffset","SMSetBPMs","bpmChanges","NoteLoaderSM_NoteLoaderSM","parseBpms","SMSetStops","parseStops","SMSetDelays","processDelays","SMSetTimeSignatures","processTimeSignatures","SMSetTickCounts","processTickcounts","SMSetInstrumentTrack","SMSetSampleStart","HHMMSSToSeconds","SMSetSampleLength","SMSetDisplayBPM","RANDOM","SPECIFIED","SMSetSelectable","SMSetBGChanges","SMSetFGChanges","SMSetKeysounds","SMSetAttacks","songTagHandlers","NoteLoaderSM","rowsPerBeat","replace","stringToStepsType","oldStyleStringToDifficulty","songBpmInfo","bpmChangeExpressions","arrayBpmChangeValues","rowToBeat","newBpm","songStopInfo","arrayFreezeExpressions","arrayFreezeValues","freezeBeat","freezeSeconds","arrayDelayExpressions","arrayDelayValues","vs1","s1","vs2","arrayTickcountExpressions","arrayTickcountValues","tickcountBeat","clamp","prevbeat","warpstart","warpend","prewarpbpm","timeofs","compareFirst","stopIndex","stopMax","stopPair","adjustOffset","bpmIndex","bpmMax","bpmPair","changeIsBpm","msdFile","reusedSongInfo","getNumValues","numParams","getNumParams","getValue","valueName","toUpperCase","handler","loadFromTokens","decompress","addSteps","hasSteps","processBpmsAndStops","lib_NoteLoaderSM","MsdFile_MsdFile","MsdFile","readBuffer","valueIndex","paramIndex","buf","unescape","readingValue","currentParam","addValue","addParam","param","join","lib_MsdFile","DEFAULT_PACK_URL_PREFIX","PACK_PATH_PREFIX","NODE_ENV","BASE_URL","VUE_APP_PACK_URL_PREFIX","PACK_INDEX_FILENAME","VUE_APP_PACK_INDEX_FILENAME","DEFAULT_SELECTED_CHART","oggFilename","simFilename","ChartPickervue_type_script_lang_ts_ChartPicker","ChartPicker","pack","unshift","catch","foundPack","find","foundChart","chart","event","findPack","packName","findChart","ogg","encodeURIComponent","simFile","urls","changeChart","$emit","stepsIndex","getAllSteps","newHowl","absoluteSimURI","p1","loadTextFile","smText","loadFromSimfile","absoluteHowlURI","p2","loadOggFileAsHowl","howl","all","loadSong","$data","ChartPickervue_type_script_lang_ts_","components_ChartPickervue_type_script_lang_ts_","ChartPicker_component","components_ChartPicker","installComponents_default","VSelect","RhythmAssist_RhythmAssist","RhythmAssist","metronome","clap","songRow","rowLastCrossed","clapRow","isThereATapOrHoldHeadAtRow","tickBeat","tickSecond","clapSound","lastCrossedMeasureIndex","lastCrossedBeatIndex","lastCrossedRowsRemainder","noteRowToMeasureAndBeat","currentMeasureIndex","currentBeatIndex","currentRowsRemainder","metronomeRow","changedMeasure","_tickBeat","_tickSecond","assist_clap_default","volume","lib_RhythmAssist","gGameplayTimer","GameLoop_GameLoop","outsideDeltaTime","GameLoop","drawnFrames","getDeltaTime","totalTime","playTicks","isReadyToDraw","drawnArrow","showReceptors","lib_GameLoop","main","requestAnimationFrame","gameLoop","debugTools","Appvue_type_script_lang_ts_App","App","musicSeek","isPaused","components","Appvue_type_script_lang_ts_","src_Appvue_type_script_lang_ts_","App_component","src_App","VApp","VBtn","VContainer","VContent","VFlex","VLayout","VSpacer","VGrid","VTextField","VToolbar","VToolbarTitle","components_VToolbar","config","productionTip","render","$mount"],"mappings":"aACA,SAAAA,EAAAC,GAQA,IAPA,IAMAC,EAAAC,EANAC,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GAIAM,EAAA,EAAAC,EAAA,GACQD,EAAAH,EAAAK,OAAoBF,IAC5BJ,EAAAC,EAAAG,GACAG,EAAAP,IACAK,EAAAG,KAAAD,EAAAP,GAAA,IAEAO,EAAAP,GAAA,EAEA,IAAAD,KAAAG,EACAO,OAAAC,UAAAC,eAAAC,KAAAV,EAAAH,KACAc,EAAAd,GAAAG,EAAAH,IAGAe,KAAAhB,GAEA,MAAAO,EAAAC,OACAD,EAAAU,OAAAV,GAOA,OAHAW,EAAAR,KAAAS,MAAAD,EAAAb,GAAA,IAGAe,IAEA,SAAAA,IAEA,IADA,IAAAC,EACAf,EAAA,EAAiBA,EAAAY,EAAAV,OAA4BF,IAAA,CAG7C,IAFA,IAAAgB,EAAAJ,EAAAZ,GACAiB,GAAA,EACAC,EAAA,EAAkBA,EAAAF,EAAAd,OAA2BgB,IAAA,CAC7C,IAAAC,EAAAH,EAAAE,GACA,IAAAf,EAAAgB,KAAAF,GAAA,GAEAA,IACAL,EAAAQ,OAAApB,IAAA,GACAe,EAAAM,IAAAC,EAAAN,EAAA,KAGA,OAAAD,EAIA,IAAAQ,EAAA,GAKApB,EAAA,CACAqB,IAAA,GAGAZ,EAAA,GAGA,SAAAS,EAAA1B,GAGA,GAAA4B,EAAA5B,GACA,OAAA4B,EAAA5B,GAAA8B,QAGA,IAAAC,EAAAH,EAAA5B,GAAA,CACAK,EAAAL,EACAgC,GAAA,EACAF,QAAA,IAUA,OANAhB,EAAAd,GAAAa,KAAAkB,EAAAD,QAAAC,IAAAD,QAAAJ,GAGAK,EAAAC,GAAA,EAGAD,EAAAD,QAKAJ,EAAAO,EAAAnB,EAGAY,EAAAQ,EAAAN,EAGAF,EAAAS,EAAA,SAAAL,EAAAM,EAAAC,GACAX,EAAAY,EAAAR,EAAAM,IACA1B,OAAA6B,eAAAT,EAAAM,EAAA,CAA0CI,YAAA,EAAAC,IAAAJ,KAK1CX,EAAAgB,EAAA,SAAAZ,GACA,qBAAAa,eAAAC,aACAlC,OAAA6B,eAAAT,EAAAa,OAAAC,YAAA,CAAwDC,MAAA,WAExDnC,OAAA6B,eAAAT,EAAA,cAAiDe,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,kBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAvC,OAAAwC,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAvC,OAAA6B,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAS,EAAAc,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAtB,GACA,IAAAM,EAAAN,KAAAiB,WACA,WAA2B,OAAAjB,EAAA,YAC3B,WAAiC,OAAAA,GAEjC,OADAL,EAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAgB,EAAAC,GAAsD,OAAA7C,OAAAC,UAAAC,eAAAC,KAAAyC,EAAAC,IAGtD7B,EAAA8B,EAAA,mBAEA,IAAAC,EAAAC,OAAA,gBAAAA,OAAA,oBACAC,EAAAF,EAAAhD,KAAA2C,KAAAK,GACAA,EAAAhD,KAAAX,EACA2D,IAAAG,QACA,QAAAvD,EAAA,EAAgBA,EAAAoD,EAAAlD,OAAuBF,IAAAP,EAAA2D,EAAApD,IACvC,IAAAU,EAAA4C,EAIA1C,EAAAR,KAAA,qBAEAU,qECtJAY,EAAAD,QAAiBJ,EAAA8B,EAAuB,6DCAxCzB,EAAAD,QAAiBJ,EAAA8B,EAAuB,+DCAxCzB,EAAAD,QAAiBJ,EAAA8B,EAAuB,iECAxCzB,EAAAD,QAAA,44ECAA,IAAA+B,EAAAnC,EAAA,QAAAoC,EAAApC,EAAA2B,EAAAQ,GAAkhBC,EAAG,wBCArhB/B,EAAAD,QAAA,qmICAAC,EAAAD,QAAA,m8ECAAC,EAAAD,QAAiBJ,EAAA8B,EAAuB,+DCAxCzB,EAAAD,QAAiBJ,EAAA8B,EAAuB,+DCAxCzB,EAAAD,QAAiBJ,EAAA8B,EAAuB,mKCIxCO,EAAA,WAAIC,IAAIC,EAAA,KAAS,CACfC,SAAU,OCLZ,ICQYC,EDRRC,EAAM,WAAgB,IAAAC,EAAAC,KAAaC,EAAAF,EAAAG,eAA0BC,EAAAJ,EAAAK,MAAAD,IAAAF,EAAwB,OAAAE,EAAA,SAAmBE,MAAA,CAAOC,KAAA,KAAW,CAAAH,EAAA,aAAkBE,MAAA,CAAO9C,IAAA,KAAU,CAAA4C,EAAA,mBAAwBI,YAAA,2BAAsC,CAAAJ,EAAA,QAAAJ,EAAAS,GAAA,aAAAL,EAAA,QAA4CI,YAAA,qBAAgC,CAAAR,EAAAS,GAAA,uBAAAL,EAAA,YAAAA,EAAA,SAA2DE,MAAA,CAAOI,KAAA,GAAAC,KAAA,uDAAAC,OAAA,WAA2F,CAAAR,EAAA,QAAaI,YAAA,QAAmB,CAAAR,EAAAS,GAAA,0BAAAL,EAAA,aAAAA,EAAA,eAAAA,EAAA,YAAoFE,MAAA,CAAOO,IAAA,KAAU,CAAAT,EAAA,UAAeE,MAAA,CAAOQ,IAAA,KAAU,CAAAV,EAAA,cAAAA,EAAA,UAAgCE,MAAA,CAAOQ,IAAA,KAAU,CAAAV,EAAA,wBAAAA,EAAA,UAAAA,EAAA,SAAsDW,GAAA,CAAIC,MAAAhB,EAAAiB,iBAA4B,CAAAjB,EAAAS,GAAA,gBAAAL,EAAA,SAAqCW,GAAA,CAAIC,MAAAhB,EAAAkB,YAAuB,CAAAlB,EAAAS,GAAA,UAAAL,EAAA,gBAAsCE,MAAA,CAAOa,KAAA,UAAgBC,MAAA,CAAQ5C,MAAAwB,EAAA,KAAAqB,SAAA,SAAAC,GAA0CtB,EAAAuB,KAAAvB,EAAAwB,GAAAF,IAAqBG,WAAA,WAAoB,gBAC58BC,EAAA,uFEDIC,EAAM,WAAgB,IAAA3B,EAAAC,KAAaC,EAAAF,EAAAG,eAA0BC,EAAAJ,EAAAK,MAAAD,IAAAF,EAAwB,OAAAE,EAAA,OAAiBI,YAAA,iBAA4B,CAAAJ,EAAA,UAAewB,IAAA,iBAAmB5B,EAAA6B,GAAA,gBACpKC,EAAe,qEDANC,EAAmB,GAEnBC,EAAoB,GAEpBC,EAA4B,GAUnC,SAAUC,EAAqBC,GACjC,OAAQA,GACJ,KAAKrC,EAAiBsC,KAAM,OAAO,EACnC,KAAKtC,EAAiBuC,KAAM,OAAO,EACnC,KAAKvC,EAAiBwC,GAAI,OAAO,EACjC,KAAKxC,EAAiByC,MAAO,OAAO,EACpC,QAAS,MAAM,IAAIC,MAAJ,6BAAAC,OAAuCN,KAGxD,SAAUO,EAAqBC,GACjC,OAAQA,GACJ,KAAK,EAAG,OAAO,EACf,KAAK,EAAG,OAAO,EACf,KAAK,EACL,KAAK,EACD,OAAOA,EACX,QAAS,MAAM,IAAIH,MAAJ,sBAAAC,OAAgCE,MAvBvD,SAAY7C,GACRA,IAAA,kBACAA,IAAA,kBACAA,IAAA,cACAA,IAAA,qBAJJ,CAAYA,MAAgB,KA4BrB,IEnCK8C,EFmCCC,EAAc,gMGKdC,EAA2B,mBAC3BC,EAAoC,oBACpCC,EAAsB,eAGtBC,EAAmC,0BACnCC,EAAqC,4BACrCC,EAAyC,+BACzCC,EAA2C,iCAI3CC,GAAqC,4BAErCC,GAA2C,iCAGlDC,GAAuC,CAEzC,CACIxF,KAAM+E,EACNU,WAAYC,EAAAC,EACZC,MAAO5B,EACP6B,OAAQ5B,EACR6B,WAAY,EACZC,cAAe,GACfC,WAAY,EACZC,UAAU,GAEd,CACIjG,KAAMgF,EACNS,WAAYS,EAAAP,EACZC,MAAO5B,EACP6B,OAAQ5B,EACR6B,WAAY,EACZC,cAAe,EACfC,WAAY,GACZC,UAAU,GAEd,CACIjG,KAAMiF,EACNQ,WAAYU,EAAAR,EACZC,MAAO5B,EACP6B,OAAQ5B,EACR6B,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAGd,CACIjG,KAAMkF,EACNO,WAAYW,EAAAT,EACZC,MAAO5B,EACP6B,OAAQ,IACRC,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAEd,CACIjG,KAAMmF,EACNM,WAAYY,EAAAV,EACZC,MAAO5B,EACP6B,OAAQ,IACRC,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAEd,CACIjG,KAAMoF,EACNK,WAAYa,EAAAX,EACZC,MAAO5B,EACP6B,OAAQ3B,EACR4B,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAEd,CACIjG,KAAMqF,EACNI,WAAYc,EAAAZ,EACZC,MAAO5B,EACP6B,OAAQ3B,EACR4B,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAad,CACIjG,KAAMsF,GACNG,WAAYe,EAAAb,EACZC,MAAO5B,EACP6B,OAAQ,IACRC,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,GAYd,CACIjG,KAAMuF,GACNE,WAAYgB,EAAAd,EACZC,MAAO5B,EACP6B,OAAQ3B,EACR4B,WAAY,EACZC,cAAe,EACfC,WAAY,EACZC,UAAU,IAKZS,cAoBF,SAAAC,IAAArI,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAyE,GANQzE,KAAA2E,WAA0C,IAAIC,EAAAnB,EAG9CzD,KAAA6E,aAAc,iEAKG,OAAO7E,KAAK6E,kDAChB/G,GACjB,IAAMgH,EAAiB9E,KAAK2E,WAAWxG,IAAIL,GAC3C,QAAuBiH,IAAnBD,EACA,MAAM,IAAIvC,MAAJ,0CAAAC,OAAoD1E,IAE9D,OAAOgH,wCAMP,IADA,IAAME,EAASC,GAAUC,aAAaF,OACtCG,EAAA,EAAAC,EAAyB9B,GAAzB6B,EAAAC,EAAAnJ,OAAAkJ,IAA6C,CAAxC,IAAMR,EAAUS,EAAAD,GACjBH,EAAOK,IAAIV,EAAW7G,KAAM6G,EAAWpB,YAG3CyB,EAAOM,KAAKtF,KAAKuF,OAAOzG,KAAKkB,wCAK7B,QAAAwF,EAAA,EAAAC,EAAyBnC,GAAzBkC,EAAAC,EAAAxJ,OAAAuJ,IAA6C,CAAxC,IAAMb,EAAUc,EAAAD,GACjBxF,KAAK0F,+BAA+Bf,GAGxC3E,KAAK6E,aAAc,yDAMgBc,GAInC,IAHA,IAAMC,EAAgBX,GAAUC,aAAaF,OAAOa,UAAUF,EAAO7H,MAAMgI,QAErEC,EAA4B,GACzB1I,EAAI,EAAGA,EAAIsI,EAAO/B,WAAYvG,IAAK,CAExC,IADA,IAAM2I,EAAqC,GAClCC,EAAI,EAAGA,EAAIN,EAAO9B,cAAeoC,IAAK,CAE3C,IAAMC,EAAY,IAAIC,EAAA,KAClBF,EAAIN,EAAOjC,MACXrG,EAAIsI,EAAOhC,OACXgC,EAAOjC,MACPiC,EAAOhC,QAGLyC,EAAc,IAAID,EAAA,KAAaP,EAAcS,YAAaH,GAChEF,EAAmB7J,KAAKiK,GAG5BL,EAAQ5J,KAAK6J,GAGjBhG,KAAK2E,WAAW2B,IAAIX,EAAO7H,KAAM,CAC7BA,KAAM6H,EAAO7H,KACb4F,MAAOiC,EAAOjC,MACdC,OAAQgC,EAAOhC,OACfG,WAAY6B,EAAO7B,WACnBC,SAAU4B,EAAO5B,SACjBwC,SAAUR,4CA3Ed,OAHKtB,EAAgB+B,WACjB/B,EAAgB+B,SAAW,IAAI/B,GAE5BA,EAAgB+B,kBA+EzBC,GAAcjC,GAAgBkC,cACrBC,GAAA,4BC5PFC,cAAb,WAaI,SAAAC,IAAAzK,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA6G,GAHQ7G,KAAA8G,SAAqB,GAVjC,OAAA1K,OAAA2K,EAAA,KAAA3K,CAAAyK,EAAA,EAAAhI,IAAA,iBAAAN,MAAA,SAe0ByI,GAElB,OADAhH,KAAK8G,SAAS3K,KAAK6K,GACZhH,OAjBf,CAAAnB,IAAA,mBAAAN,MAAA,SAoB4ByI,GACpB,IAAK,IAAIjL,EAAI,EAAGA,EAAIiE,KAAK8G,SAAS7K,OAAQF,IAClCiE,KAAK8G,SAAS/K,KAAOiL,GAErBhH,KAAK8G,SAAS3J,OAAOpB,EAAG,GAGhC,OAAOiE,OA3Bf,CAAAnB,IAAA,SAAAN,MAAA,SA+BkB0I,GAIV,OAHAjH,KAAK8G,SAASI,QAAQ,SAACF,GACnBA,EAAOG,OAAOF,KAEXjH,QAnCf,EAAAnB,IAAA,cAAAN,MAAA,WAMQ,OAHKsI,EAAcL,WACfK,EAAcL,SAAW,IAAIK,GAE1BA,EAAcL,aAN7BK,EAAA,IAsCMO,GAAYR,GAAcF,cACjBW,GAAA,GC5CAC,cACX,SAAAC,IAAAnL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAuH,GACIF,GAAUG,eAAexH,+DASzBqH,GAAUI,iBAAiBzH,eAGpB0H,GAAA,GCJTC,eASF,SAAAC,EAAmBjC,GAAmB,IAAAkC,EAAA,OAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA4H,GAClCC,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAwL,GAAArL,KAAAyD,OAEA6H,EAAKlC,OAASA,EACdkC,EAAKG,SAAU,EAEfH,EAAKlC,OAAOsC,OAAS,EAGrBJ,EAAKlC,OAAOuC,OAAOC,EAAI,GACvBN,EAAKlC,OAAOuC,OAAOE,EAAI,GAVWP,8FANlC,IAAKlB,GAAY0B,gBAAmB,MAAM,IAAI9F,MAAM,8FAoBpDvC,KAAKsI,kBACLlM,OAAA+B,GAAA,KAAA/B,QAAA2L,EAAA,KAAA3L,CAAAwL,EAAAvL,WAAA,UAAA2D,MAAAzD,KAAAyD,0CAGiB,OAAOA,KAAKgI,4CACZ,OAAOhI,KAAK2F,sCACnBwC,EAAWC,GAGrB,OAFApI,KAAK2F,OAAOwC,EAAIA,EAChBnI,KAAK2F,OAAOyC,EAAIA,EACTpI,qCAEImI,GAEX,OADAnI,KAAK2F,OAAOwC,EAAIA,EACTnI,qCAEIoI,GAEX,OADApI,KAAK2F,OAAOyC,EAAIA,EACTpI,0CAGP,OAAIA,KAAKgI,QAAkBhI,MAE3BA,KAAKgI,SAAU,EACf/C,GAAUC,aAAaqD,MAAMC,SAASxI,KAAK2F,QACpC3F,gDAGP,OAAKA,KAAKgI,SAEVhI,KAAKgI,SAAU,EACf/C,GAAUC,aAAaqD,MAAME,YAAYzI,KAAK2F,QACvC3F,MAJqBA,uCAOf0I,GAEb,OADA1I,KAAK2F,OAAOsC,OAASS,EACd1I,oCAGGiH,GAEV,OAAOjH,YAhEU0H,IAmEViB,GAAA,GC5ETC,eAGF,SAAAC,EAAmBlE,GAA2C,IAAAkD,EAAfiB,EAAeC,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAD,EAAC3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA6I,GAC1D,IAAMlD,EAAS,IAAIQ,EAAA,KAAoBxB,EAAW4B,SAASuC,IADD,OAE1DjB,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAyM,GAAAtM,KAAAyD,KAAM2F,IACNkC,EAAKlC,OAASA,EAGdkC,EAAKlC,OAAOqD,eAAiB,EAAIrE,EAAWb,WAC5C+D,EAAKlC,OAAOsD,KAAOtE,EAAWZ,SAP4B8D,iFAW1D,OAAO7H,KAAK2F,cAdagD,IAiBlBO,GAAA,GCjBFC,GAAyB,GAEhCC,eAMF,SAAAC,EAAYnH,GAA2B,IAAA2F,EAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAqJ,GACnCV,GAAWW,oBACXzB,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAiN,GAAA9M,KAAAyD,KAAM2G,GAAY4C,cAAczG,KAEhC+E,EAAK3F,UAAYA,EACjB2F,EAAKlC,OAAO6D,MAAQ,IACpB3B,EAAKlC,OAAOyC,EAAIe,GAGhBtB,EAAKlC,OAAO8D,SAAY,GAAK5B,EAAK3F,WAAcwH,KAAKC,GAAK,KAG1D,IAAMjH,EAAYT,EAAqB4F,EAAK3F,WAZT,OAanC2F,EAAKlC,OAAOwC,EAAIvF,EAAed,EAAmBY,EAElDmF,EAAKlC,OAAOiE,OAfuB/B,oFAkBf,OAAO7H,KAAKkC,yCAEtB+E,GACV,OAAOjH,YA3BqBkJ,IA8BrBW,GAAA,cNpCf,SAAYlH,GACRA,IAAA,0BACAA,IAAA,0BACAA,IAAA,gBACAA,IAAA,yBAJJ,CAAYA,MAAY,KAMGA,EAAamH,IAAjC,IOQKC,GAeAC,GAUAC,GPhCCC,GAAiBvH,EAAawH,gIOF9BC,cAAb,SAAAC,IAAAjO,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAqK,KAIaC,GAAb,SAAAC,IAAAnO,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAuK,KAKA,SAAYR,GACRA,IAAA,oBACAA,IAAA,gBACAA,IAAA,0BACAA,IAAA,0BACAA,IAAA,kBACAA,IAAA,kBACAA,IAAA,sBACAA,IAAA,kCACAA,IAAA,kBACAA,IAAA,gBACAA,IAAA,0BAXJ,CAAYA,QAAW,KAevB,SAAYC,GACRA,IAAA,kBACAA,IAAA,kBAEAA,IAAA,gBACAA,IAAA,wBALJ,CAAYA,QAAc,KAU1B,SAAYC,GACRA,IAAA,0BACAA,IAAA,0BACAA,IAAA,gBACAA,IAAA,wBAJJ,CAAYA,QAAa,KAQlB,IA8LKO,GA9LCC,GAAb,oBAAAC,IAAAtO,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA0K,GAkBW1K,KAAAkB,KAAoB6I,GAAYY,MAEhC3K,KAAA4K,QAA0BZ,GAAeG,QAEzCnK,KAAA6K,OAAwBZ,GAAca,SAEtC9K,KAAAlD,OAAwB,IAAIsN,GAE5BpK,KAAA+K,GAAmBb,GAKnBlK,KAAAgL,eAAyB,EACzBhL,KAAAiL,UAAoB,EAIpBjL,KAAAkL,oBAAsClB,GAAemB,KASrDnL,KAAAoL,SAAmB,EACnBpL,KAAAqL,WAA6B,IAAIf,GA9C5C,OAAAlO,OAAA2K,EAAA,KAAA3K,CAAAsO,EAAA,EAAA7L,IAAA,SAAAN,MAAA,SAgDkB+M,GACV,OAAItL,KAAKkB,OAASoK,EAAMpK,MACpBlB,KAAK4K,UAAYU,EAAMV,SACvB5K,KAAK6K,SAAWS,EAAMT,QACtB7K,KAAKoL,WAAaE,EAAMF,UACxBpL,KAAK+K,KAAOO,EAAMP,KArD9B,CAAAlM,IAAA,OAAAN,MAAA,WA8DQ,OAAOgN,KAAcC,KAAcC,KAAsBzL,OAAQA,SA9DzE,EAAAnB,IAAA,SAAAN,MAAA,SAGQ2C,EACA0J,EACAC,GACI3J,EAAO6I,GAAY2B,OACnBC,QAAQC,MAAR,yBAAApJ,OAAuCtB,EAAvC,gDACAA,EAAO6I,GAAYY,OAEvB,IAAMkB,EAAU,IAAInB,EAIpB,OAHAmB,EAAQ3K,KAAOA,EACf2K,EAAQjB,QAAUA,EAClBiB,EAAQhB,OAASA,EACVgB,MAdfnB,EAAA,GAmEaoB,GAAb,oBAAAC,IAAA3P,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA+L,GAAA,OAAA3P,OAAA2K,EAAA,KAAA3K,CAAA2P,EAAA,OAAAlN,IAAA,gBAAAN,MAAA,SACgCyN,GACxB,OAAOtC,KAAKuC,MAAMD,EAAUE,MAFpC,CAAArN,IAAA,0BAAAN,MAAA,SAI0CyN,GAClC,OAAOtC,KAAKyC,MAAMH,EAAUE,MALpC,CAAArN,IAAA,gBAAAN,MAAA,SAOgCqC,GACxB,OAAOA,EAAMsL,KARrB,CAAArN,IAAA,gBAAAN,MAAA,SAmBgC6N,EAAenQ,EAAgBoQ,EAAmBC,GAC1E,OAAIA,EAAWF,EACJE,EAEPA,GAAYF,EAAQnQ,EACbqQ,EAAWrQ,EAASoQ,EAExBD,GAASE,EAAWF,GAASC,EAAYpQ,IA1BxD,CAAA4C,IAAA,iBAAAN,MAAA,SAkCiCgO,GACzB,OAAQA,GACJ,KAAK/B,GAASgC,MAAS,OAAO,EAC9B,KAAKhC,GAASiC,MAAS,MAAO,GAC9B,KAAKjC,GAASkC,OAAS,OAAO,EAAI,EAClC,KAAKlC,GAASmC,OAAS,MAAO,IAC9B,KAAKnC,GAASoC,OAAS,OAAO,EAAM,EACpC,KAAKpC,GAASqC,OAAS,OAAO,EAAI,EAClC,KAAKrC,GAASsC,OAAS,OAAO,EAAI,GAClC,KAAKtC,GAASuC,OAAS,OAAO,EAAI,GAClC,KAAKvC,GAASwC,QAAS,OAAO,EAAI,GAClC,KAAKxC,GAASL,QAAS,OAAO,EAAI,GAClC,QACI,MAAM,IAAI5H,MAAJ,2BAAAC,OAAqC+J,OA/C3D,CAAA1N,IAAA,gBAAAN,MAAA,SAmDgCgO,GACxB,OAAQA,GACJ,KAAK/B,GAASgC,MAAO,OAAO,GAC5B,KAAKhC,GAASiC,MAAO,OAAO,GAC5B,KAAKjC,GAASkC,OAAQ,OAAO,GAC7B,KAAKlC,GAASmC,OAAQ,OAAO,GAC7B,KAAKnC,GAASoC,OAAQ,OAAO,EAC7B,KAAKpC,GAASqC,OAAQ,OAAO,EAC7B,KAAKrC,GAASsC,OAAQ,OAAO,EAC7B,KAAKtC,GAASuC,OAAQ,OAAO,EAC7B,KAAKvC,GAASwC,QACd,KAAKxC,GAASL,QACV,OAAO,EACX,QACI,MAAM,IAAI5H,MAAJ,2BAAAC,OAAqC+J,OAjE3D,CAAA1N,IAAA,cAAAN,MAAA,SA0E8BqC,GACtB,OAAIA,GAAOqM,GAAmB,KAAO,EAC1BzC,GAASgC,MACT5L,GAAOqM,GAAmB,KAAO,EACjCzC,GAASiC,MACT7L,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASkC,OACT9L,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASmC,OACT/L,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASoC,OACThM,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASqC,OACTjM,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASsC,OACTlM,GAAOqM,GAAmB,MAAQ,EAClCzC,GAASuC,OAEbvC,GAASwC,UA5FxB,CAAAnO,IAAA,iBAAAN,MAAA,SA+FiC2O,GACzB,OAAOlN,KAAKmN,YAAYpB,EAAYqB,cAAcF,MAhG1D,CAAArO,IAAA,eAAAN,MAAA,SAyG+BqC,EAAapC,GACpC,OAAOwB,KAAKmN,YAAYvM,KAASpC,MA1GzCuN,EAAA,GA6GesB,GAAA,GAOFnB,GAAwB,GAIxBoB,GAAwB,GAAK,IAG1C,SAAY9C,GACRA,IAAA,oBACAA,IAAA,oBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,wBACAA,IAAA,gBACAA,IAAA,0BAXJ,CAAYA,QAAQ,KAeb,ICxPK+C,GAiBAC,GDuOCC,GAAoB,EACpBR,GAAmBf,GAAgBuB,GAEnCC,GAAb,oBAAAC,IAAAvR,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA2N,GAAA,OAAAvR,OAAA2K,EAAA,KAAA3K,CAAAuR,EAAA,OAAA9O,IAAA,WAAAN,MAAA,WA0B+B,OAAOyB,KAAK4N,MAAMC,SA1BjD,CAAAhP,IAAA,iBAAAN,MAAA,WA2BqC,OAAOyB,KAAK8N,aAAaD,SA3B9D,CAAAhP,IAAA,kBAAAN,MAAA,WA4BsC,OAAOyB,KAAK+N,cAAcF,SA5BhE,CAAAhP,IAAA,sBAAAN,MAAA,WA6B0C,OAAOyB,KAAKgO,mBAAmBH,SA7BzE,CAAAhP,IAAA,sBAAAN,MAAA,WA8B0C,OAAOyB,KAAKiO,mBAAmBJ,SA9BzE,CAAAhP,IAAA,kBAAAN,MAAA,WA+BsC,OAAOyB,KAAKkO,cAAcL,SA/BhE,CAAAhP,IAAA,oBAAAN,MAAA,WAgCwC,OAAOyB,KAAKmO,gBAAgBN,SAhCpE,CAAAhP,IAAA,0BAAAN,MAAA,WAiC8C,OAAOyB,KAAKoO,uBAAuBP,SAjCjF,CAAAhP,IAAA,kBAAAN,MAAA,WAkCsC,OAAOyB,KAAKqO,cAAcR,SAlChE,CAAAhP,IAAA,iBAAAN,MAAA,WAmCqC,OAAOyB,KAAKsO,aAAaT,SAnC9D,CAAAhP,IAAA,kBAAAN,MAAA,WAoCsC,OAAOyB,KAAKuO,cAAcV,WApChEF,EAAA,GACkBD,GAAAE,MAAQnD,GAAQ7L,OAC1BmL,GAAYY,MAAOX,GAAeG,QAASF,GAAca,UAC/C4C,GAAAI,aAAerD,GAAQ7L,OACjCmL,GAAYyE,IAAKxE,GAAeG,QAASF,GAAca,UAC7C4C,GAAAK,cAAgBtD,GAAQ7L,OAClCmL,GAAY0E,KAAMzE,GAAeG,QAASF,GAAca,UAC9C4C,GAAAM,mBAAqBvD,GAAQ7L,OACvCmL,GAAY2E,SAAU1E,GAAemB,KAAMlB,GAAca,UAC/C4C,GAAAO,mBAAqBxD,GAAQ7L,OACvCmL,GAAY2E,SAAU1E,GAAe2E,KAAM1E,GAAca,UAC/C4C,GAAAQ,cAAgBzD,GAAQ7L,OAClCmL,GAAY6E,KAAM5E,GAAeG,QAASF,GAAca,UAC9C4C,GAAAS,gBAAkB1D,GAAQ7L,OACpCmL,GAAY8E,OAAQ7E,GAAeG,QAASF,GAAca,UAChD4C,GAAAU,uBAAyB3D,GAAQ7L,OAC3CmL,GAAY+E,aAAc9E,GAAeG,QAASF,GAAca,UACtD4C,GAAAW,cAAgB5D,GAAQ7L,OAClCmL,GAAY2B,KAAM1B,GAAeG,QAASF,GAAca,UAC9C4C,GAAAY,aAAe7D,GAAQ7L,OACjCmL,GAAYyE,IAAKxE,GAAeG,QAASF,GAAc8E,UAC7CrB,GAAAa,cAAgB9D,GAAQ7L,OAClCmL,GAAY6E,KAAM5E,GAAeG,QAASF,GAAc8E,UCjRhE,SAAYxB,GACRA,IAAA,gBACAA,IAAA,kBACAA,IAAA,oBACAA,IAAA,0BACAA,IAAA,kBACAA,IAAA,oBACAA,IAAA,4BACAA,IAAA,oBACAA,IAAA,oBACAA,IAAA,sBACAA,IAAA,mBACAA,IAAA,iBACAA,IAAA,yBAbJ,CAAYA,QAAiB,KAiB7B,SAAYC,GACRA,IAAA,gBACAA,IAAA,oBACAA,IAAA,8BACAA,IAAA,gBACAA,IAAA,wBALJ,CAAYA,QAAiB,KAQtB,IAAMwB,IAAe,EAENC,GAAtB,WAmBI,SAAAC,IAAiD,IAArCC,EAAqCpG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAzBiG,GAAaI,IAAYrG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,KAAAA,UAAA,GAAA3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAkP,GAFzClP,KAAAqP,SAAmB,EAIvBrP,KAAKqP,SAAYD,EAAQD,EAAY9B,GAAYD,cAAc+B,GArBvE,OAAA/S,OAAA2K,EAAA,KAAA3K,CAAA8S,EAAA,EAAArQ,IAAA,QAAAN,MAAA,SAmCiB6N,EAAenQ,EAAgBoQ,GACxCrM,KAAKsP,OAAOjC,GAAYkC,cAAcnD,EAAOnQ,EAAQoQ,EAAWrM,KAAKwP,aApC7E,CAAA3Q,IAAA,SAAAN,MAAA,WAuCsB,OAAOyB,KAAKqP,WAvClC,CAAAxQ,IAAA,SAAAN,MAAA,SAwCkBqC,GAAeZ,KAAKqP,SAAWzO,IAxCjD,CAAA/B,IAAA,UAAAN,MAAA,WA0CuB,OAAO8O,GAAYoC,cAAczP,KAAKqP,YA1C7D,CAAAxQ,IAAA,UAAAN,MAAA,SA2CmB2O,GAAgBlN,KAAKsP,OAAOjC,GAAYD,cAAcF,MA3CzE,CAAArO,IAAA,WAAAN,MAAA,SA6CoBmR,GAAe,OAAO1P,KAAK2P,UAAUC,aA7CzD,CAAA/Q,IAAA,WAAAN,MAAA,SAgDoB+M,GACZ,OAAOtL,KAAKwP,SAAWlE,EAAMkE,WAjDrC,CAAA3Q,IAAA,SAAAN,MAAA,SAsDkB+M,GACV,OAAOtL,KAAKwP,WAAalE,EAAMkE,YAvDvC,EAAA3Q,IAAA,eAAAN,MAAA,SAS+BsR,EAAcC,GACrC,QAAIpG,KAAKqG,IAAIF,EAAOC,GAAQ9P,KAAKgQ,aAVzCd,EAAA,GAEkBD,GAAAe,QAAkB,KAiE7B,IAAMC,GAAb,SAAAC,GAGI,SAAAC,EAAYd,EAAmBe,GAAyC,IAAAvI,EAAbwI,IAAatH,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,KAAAA,UAAA,GAKpE,GALoE3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAmQ,QAKnDpL,IAAbsK,EAGA,OAFAxH,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA+T,GAAA5T,KAAAyD,OACA6H,EAAKyI,WAAa,EAClBlU,OAAA0L,EAAA,KAAA1L,CAAAyL,GAEJ,QAA0B9C,IAAtBqL,EACA,MAAM,IAAI7N,MAAM,gFAXgD,OAapEsF,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA+T,GAAA5T,KAAAyD,KAAMqP,GAAU,IAEZxH,EAAKyI,WADLD,EACkBD,EAEA/C,GAAYD,cAAcgD,GAjBoBhU,OAAA0L,EAAA,KAAA1L,CAAAyL,GAH5E,OAAAzL,OAAAmU,EAAA,KAAAnU,CAAA+T,EAAAD,GAAA9T,OAAA2K,EAAA,KAAA3K,CAAA+T,EAAA,EAAAtR,IAAA,UAAAN,MAAA,WAwBuB,OAAOgP,GAAkBiD,OAxBhD,CAAA3R,IAAA,gBAAAN,MAAA,WAyB6B,OAAOiP,GAAkBiD,QAzBtD,CAAA5R,IAAA,YAAAN,MAAA,WA2ByB,OAAOyB,KAAKsQ,WAAa,IA3BlD,CAAAzR,IAAA,gBAAAN,MAAA,WA6B6B,OAAOyB,KAAKsQ,aA7BzC,CAAAzR,IAAA,iBAAAN,MAAA,WA8B8B,OAAO8O,GAAYoC,cAAczP,KAAKsQ,cA9BpE,CAAAzR,IAAA,YAAAN,MAAA,WA+ByB,OAAOyB,KAAK0Q,mBA/BrC,CAAA7R,IAAA,gBAAAN,MAAA,SAiCyBoS,GAAgB3Q,KAAKsQ,WAAaK,IAjC3D,CAAA9R,IAAA,iBAAAN,MAAA,SAkC0BqS,GAAiB5Q,KAAKsQ,WAAajD,GAAYD,cAAcwD,KAlCvF,CAAA/R,IAAA,QAAAN,MAAA,SAoCiB6N,EAAenQ,EAAgBoQ,GAExC,IAAMwE,EAAe7Q,KAAK2P,UACpBmB,EAAeD,EAAY7Q,KAAK+Q,YAChCC,EAAe3D,GAAYkC,cAC7BlC,GAAYoC,cAAcrD,GAC1BiB,GAAYoC,cAAcxT,GAC1BoR,GAAYoC,cAAcpD,GAC1BwE,GACEI,EAAe5D,GAAYkC,cAC7BlC,GAAYoC,cAAcrD,GAC1BiB,GAAYoC,cAAcxT,GAC1BoR,GAAYoC,cAAcpD,GAC1ByE,GACJ9Q,KAAKkR,eAAeD,EAAaD,GACjC5U,OAAA+B,GAAA,KAAA/B,QAAA2L,EAAA,KAAA3L,CAAA+T,EAAA9T,WAAA,QAAA2D,MAAAzD,KAAAyD,KAAYoM,EAAOnQ,EAAQoQ,KAnDnC,CAAAxN,IAAA,aAAAN,MAAA,WAuDQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZW,EAAatQ,KAAKoR,gBAClBC,EAAcrR,KAAK0Q,iBACzB/E,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6C8N,EAA7C,MAAA9N,OAA4D6O,EAA5D,SA5DR,CAAAxS,IAAA,WAAAN,MAAA,SA8DoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BzT,EAAS+D,KAAK+Q,YACpB,SAAAvO,OAAU0K,EAAV,KAAA1K,OAAkBvG,KAjE1B,CAAA4C,IAAA,YAAAN,MAAA,WAqEQ,MAAO,CAACyB,KAAK+Q,eArErB,CAAAlS,IAAA,SAAAN,MAAA,SAwEkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiB6E,KAIlBlB,GAAcsC,aAAavR,KAAKsQ,WAAYhF,EAAMgF,iBAjF/DH,EAAA,CAAiClB,IAgGpBuC,GAAb,SAAAC,GAOI,SAAAC,IAA+E,IAAAC,EAAnEtC,EAAmEtG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAxDiG,GAAa4C,EAA2C7I,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAnC2I,EAAiBG,mBAAkB,OAAAzV,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA0R,GAC3EC,EAAAvV,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAsV,GAAAnV,KAAAyD,KAAMqP,GAAU,IAChBsC,EAAKG,aAAeF,EAFuDD,EAPnF,OAAAvV,OAAAmU,EAAA,KAAAnU,CAAAsV,EAAAD,GAAArV,OAAA2K,EAAA,KAAA3K,CAAAsV,EAAA,EAAA7S,IAAA,UAAAN,MAAA,WAYuB,OAAOgP,GAAkBwE,YAZhD,CAAAlT,IAAA,gBAAAN,MAAA,WAa6B,OAAOiP,GAAkBwE,aAbtD,CAAAnT,IAAA,YAAAN,MAAA,WAcyB,OAAO,IAdhC,CAAAM,IAAA,WAAAN,MAAA,WAgBwB,OAAOyB,KAAK8R,eAhBpC,CAAAjT,IAAA,WAAAN,MAAA,SAiBoBqT,GAAiB5R,KAAK8R,aAAeF,IAjBzD,CAAA/S,IAAA,aAAAN,MAAA,WAoBQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZiC,EAAQ5R,KAAKiS,WACnBtG,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6CoP,EAA7C,QAxBR,CAAA/S,IAAA,WAAAN,MAAA,SA0BoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BkC,EAAQ5R,KAAKiS,WACnB,SAAAzP,OAAU0K,EAAV,KAAA1K,OAAkBoP,KA7B1B,CAAA/S,IAAA,YAAAN,MAAA,WAiCQ,MAAO,CAACyB,KAAKiS,cAjCrB,CAAApT,IAAA,SAAAN,MAAA,SAoCkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiBoG,KAIlBzC,GAAcsC,aAAavR,KAAK8R,aAAcxG,EAAMwG,mBA7CjEJ,EAAA,CAAsCzC,IAEpBuC,GAAAK,mBAAqB,EA0DhC,IC9NFK,GD8NQC,GAAb,SAAAC,GAII,SAAAC,IAAkE,IAAAC,EAAtDjD,EAAsDtG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAA3CiG,GAAauD,EAA8BxJ,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAlB,EAAGyJ,EAAezJ,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAD,EAAC,OAAA3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAqS,GAC9DC,EAAAlW,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAiW,GAAA9V,KAAAyD,KAAMqP,GAAU,IAChBiD,EAAKC,UAAYA,EACjBD,EAAKE,YAAcA,EAH2CF,EAJtE,OAAAlW,OAAAmU,EAAA,KAAAnU,CAAAiW,EAAAD,GAAAhW,OAAA2K,EAAA,KAAA3K,CAAAiW,EAAA,EAAAxT,IAAA,UAAAN,MAAA,WAUuB,OAAOgP,GAAkBkF,WAVhD,CAAA5T,IAAA,gBAAAN,MAAA,WAW6B,OAAOiP,GAAkBwE,aAXtD,CAAAnT,IAAA,YAAAN,MAAA,WAYyB,OAAO,IAZhC,CAAAM,IAAA,SAAAN,MAAA,WAcsB,OAAOyB,KAAKuS,YAdlC,CAAA1T,IAAA,SAAAN,MAAA,SAekBmU,GAAe1S,KAAKuS,UAAYG,IAflD,CAAA7T,IAAA,SAAAN,MAAA,WAiBsB,OAAOyB,KAAKwS,cAjBlC,CAAA3T,IAAA,SAAAN,MAAA,SAkBkBoU,GAAe3S,KAAKwS,YAAcG,IAlBpD,CAAA9T,IAAA,MAAAN,MAAA,SAoBemU,EAAaC,GAAe3S,KAAKuS,UAAYG,EAAK1S,KAAKwS,YAAcG,IApBpF,CAAA9T,IAAA,wBAAAN,MAAA,WAiCQ,OAAsC,EAA/B8O,GAAYD,cAAc,GAASpN,KAAKuS,UAAYvS,KAAKwS,cAjCxE,CAAA3T,IAAA,qBAAAN,MAAA,WA4CQ,OAAsC,EAA/B8O,GAAYD,cAAc,GAASpN,KAAKwS,cA5CvD,CAAA3T,IAAA,aAAAN,MAAA,WAgDQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZ+C,EAAM1S,KAAK4S,SACXD,EAAM3S,KAAK6S,SACjBlH,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6CkQ,EAA7C,KAAAlQ,OAAoDmQ,EAApD,QArDR,CAAA9T,IAAA,WAAAN,MAAA,SAuDoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BgD,EAAM1S,KAAK4S,SACXD,EAAM3S,KAAK6S,SACjB,SAAArQ,OAAU0K,EAAV,KAAA1K,OAAkBkQ,EAAlB,KAAAlQ,OAAyBmQ,KA3DjC,CAAA9T,IAAA,YAAAN,MAAA,WA+DQ,MAAO,CAACyB,KAAK4S,SAAU5S,KAAK6S,YA/DpC,CAAAhU,IAAA,SAAAN,MAAA,SAkEkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiB+G,MAIlBpD,GAAcsC,aAAavR,KAAKuS,UAAWjH,EAAMiH,cAGjDtD,GAAcsC,aAAavR,KAAKwS,YAAalH,EAAMkH,mBA9EhEH,EAAA,CAA0CpD,IAwF7B6D,GAAb,SAAAC,GAII,SAAAC,IAA6C,IAAAC,EAAjC5D,EAAiCtG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAtBiG,GAAakE,EAASnK,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAH,EAAG,OAAA3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAgT,GACzCC,EAAA7W,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA4W,GAAAzW,KAAAyD,KAAMqP,GAAU,IAHZ4D,EAAAE,IAAc,EAIlBF,EAAKG,OAAOF,GAF6BD,EAJjD,OAAA7W,OAAAmU,EAAA,KAAAnU,CAAA4W,EAAAD,GAAA3W,OAAA2K,EAAA,KAAA3K,CAAA4W,EAAA,EAAAnU,IAAA,UAAAN,MAAA,WASuB,OAAOgP,GAAkB8F,MAThD,CAAAxU,IAAA,gBAAAN,MAAA,WAU6B,OAAOiP,GAAkBwE,aAVtD,CAAAnT,IAAA,YAAAN,MAAA,WAWyB,OAAO,IAXhC,CAAAM,IAAA,SAAAN,MAAA,WAasB,OAAOyB,KAAKmT,MAblC,CAAAtU,IAAA,SAAAN,MAAA,WAcsB,OAAkB,GAAXyB,KAAKmT,MAdlC,CAAAtU,IAAA,SAAAN,MAAA,SAgBkB4U,GAAenT,KAAKmT,IAAMA,IAhB5C,CAAAtU,IAAA,SAAAN,MAAA,SAiBkB2U,GAAelT,KAAKmT,IAAMD,EAAM,KAjBlD,CAAArU,IAAA,aAAAN,MAAA,WAoBQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZuD,EAAMlT,KAAKsT,SACjB3H,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6C0Q,EAA7C,QAxBR,CAAArU,IAAA,WAAAN,MAAA,SA2BoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BwD,EAAMlT,KAAKsT,SAAShC,QAAQ5B,GAClC,SAAAlN,OAAU0K,EAAV,KAAA1K,OAAkB0Q,KA9B1B,CAAArU,IAAA,YAAAN,MAAA,WAkCQ,MAAO,CAACyB,KAAKsT,YAlCrB,CAAAzU,IAAA,SAAAN,MAAA,SAqCkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiB0H,KAIlB/D,GAAcsC,aAAavR,KAAKmT,IAAK7H,EAAM6H,UA9CxDH,EAAA,CAAgC/D,IAwDnBsE,GAAb,SAAAC,GAII,SAAAC,IAAiD,IAAAC,EAArCrE,EAAqCtG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAA1BiG,GAAa2E,EAAa5K,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAH,EAAG,OAAA3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAyT,GAC7CC,EAAAtX,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAqX,GAAAlX,KAAAyD,KAAMqP,GAAU,IAChBqE,EAAKC,QAAUA,EAF8BD,EAJrD,OAAAtX,OAAAmU,EAAA,KAAAnU,CAAAqX,EAAAD,GAAApX,OAAA2K,EAAA,KAAA3K,CAAAqX,EAAA,EAAA5U,IAAA,UAAAN,MAAA,WASuB,OAAOgP,GAAkBqG,OAThD,CAAA/U,IAAA,gBAAAN,MAAA,WAU6B,OAAOiP,GAAkBqG,MAVtD,CAAAhV,IAAA,YAAAN,MAAA,WAWyB,OAAOyB,KAAK2T,QAAU,IAX/C,CAAA9U,IAAA,WAAAN,MAAA,WAawB,OAAOyB,KAAK2T,UAbpC,CAAA9U,IAAA,WAAAN,MAAA,SAcoBoV,GAAmB3T,KAAK2T,QAAUA,IAdtD,CAAA9U,IAAA,aAAAN,MAAA,WAiBQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZmE,EAAQ9T,KAAK+T,WACnBpI,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6CsR,EAA7C,QArBR,CAAAjV,IAAA,WAAAN,MAAA,SAuBoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BoE,EAAQ9T,KAAK+T,WACnB,SAAAvR,OAAU0K,EAAV,KAAA1K,OAAkBsR,KA1B1B,CAAAjV,IAAA,YAAAN,MAAA,WA8BQ,MAAO,CAACyB,KAAK+T,cA9BrB,CAAAlV,IAAA,SAAAN,MAAA,SAiCkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiBmI,GAGhBxE,GAAcsC,aAAavR,KAAK2T,QAASrI,EAAMqI,cAzC9DF,EAAA,CAAiCxE,IAgDpB+E,GAAb,SAAAC,GAII,SAAAC,IAA+C,IAAAC,EAAnC9E,EAAmCtG,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAxBiG,GAAa2E,EAAW5K,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAD,EAAC,OAAA3M,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAkU,GAC3CC,EAAA/X,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA8X,GAAA3X,KAAAyD,KAAMqP,GAAU,IAHZ8E,EAAAR,SAAmB,EAIvBQ,EAAKR,QAAUA,EAF4BQ,EAJnD,OAAA/X,OAAAmU,EAAA,KAAAnU,CAAA8X,EAAAD,GAAA7X,OAAA2K,EAAA,KAAA3K,CAAA8X,EAAA,EAAArV,IAAA,UAAAN,MAAA,WASuB,OAAOgP,GAAkB6G,QAThD,CAAAvV,IAAA,gBAAAN,MAAA,WAU6B,OAAOiP,GAAkBqG,MAVtD,CAAAhV,IAAA,WAAAN,MAAA,WAYwB,OAAOyB,KAAK2T,UAZpC,CAAA9U,IAAA,WAAAN,MAAA,SAaoBoV,GAAmB3T,KAAK2T,QAAUA,IAbtD,CAAA9U,IAAA,YAAAN,MAAA,WAeyB,OAAOyB,KAAK2T,QAAU,IAf/C,CAAA9U,IAAA,YAAAN,MAAA,WAgByB,MAAO,CAACyB,KAAK+T,cAhBtC,CAAAlV,IAAA,aAAAN,MAAA,WAkBQ,IAAM2C,EAAOlB,KAAKmR,UACZvQ,EAAMZ,KAAKwP,SACXtC,EAAOlN,KAAK2P,UACZmE,EAAQ9T,KAAK+T,WACnBpI,QAAQC,MAAR,KAAApJ,OAAmBtB,EAAnB,KAAAsB,OAA2B5B,EAA3B,MAAA4B,OAAmC0K,EAAnC,OAAA1K,OAA6CsR,EAA7C,QAtBR,CAAAjV,IAAA,WAAAN,MAAA,SAwBoBmR,GACZ,IAAMxC,EAAOlN,KAAK2P,UAAU2B,QAAQ5B,GAC9BoE,EAAQ9T,KAAK+T,WAAWzC,QAAQ5B,GACtC,SAAAlN,OAAU0K,EAAV,KAAA1K,OAAkBsR,KA3B1B,CAAAjV,IAAA,SAAAN,MAAA,SA8BkB+M,GACV,OAAItL,KAAKmR,YAAc7F,EAAM6F,YAIvB7F,aAAiB4I,GAGhBjF,GAAcsC,aAAavR,KAAK2T,QAASrI,EAAMqI,cAtC9DO,EAAA,CAAkCjF,ICvb5BoF,IAAyB,EAWzBC,GAA6C,CAC/C,KACA,IAAIf,GACJ,IAAIS,GACJ,KACA,IAAI/D,GACJ,KACA,KACA,KACA,KACA,KACA,OAGJ,SAAKiC,GACDA,IAAA,kBACAA,IAAA,0CACAA,IAAA,8BACAA,IAAA,kBACAA,IAAA,oBACAA,IAAA,8BACAA,IAAA,sBACAA,IAAA,6BARJ,CAAKA,QAAc,SAmCNqC,GAAb,SAAAC,IAAApY,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAwU,GACWxU,KAAAyU,YAAc,EACdzU,KAAAkN,KAAO,EACPlN,KAAA0U,OAAS,EACT1U,KAAA2U,YAAc,EACd3U,KAAA4U,cAAgB,EAChB5U,KAAA6U,WAAY,EACZ7U,KAAA8U,UAAW,GAETC,GAAb,SAAAC,IAAA5Y,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAgV,GACWhV,KAAAkT,IAAM,EACNlT,KAAAiV,KAAO,EACPjV,KAAAkV,KAAO,EACPlV,KAAAmV,MAAQ,EACRnV,KAAAoV,QAAU,EACVpV,KAAAqV,SAAW,EACXrV,KAAAsV,gBAAkB,EAClBtV,KAAAuV,WAAY,GAOVC,GAAb,WAqFI,SAAAC,IAAArZ,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAyV,GAROzV,KAAA0V,gBAAmC,GACnC1V,KAAA2V,gBAAmC,GAGlC3V,KAAA4V,kBAA4B,EAE5B5V,KAAA6V,eAAoC,GAIxC,IAAK,IAAI9Z,EAAI,EAAGA,EAAIwR,GAAkBzD,IAAK/N,IACvCiE,KAAK6V,eAAe1Z,KAAK,IAxFrC,OAAAC,OAAA2K,EAAA,KAAA3K,CAAAqZ,EAAA,EAAA5W,IAAA,kBAAAN,MAAA,SA4F2B6N,EAAsB0J,EAAmBC,GAC5D,IAAMC,EAAOhW,KAAK6V,eACZI,EAAOD,EAAKzI,GAAkB8F,KAC9B6C,EAAQF,EAAKzI,GAAkBiD,MAC/B2F,EAAQH,EAAKzI,GAAkBqG,MAC/BwC,EAASJ,EAAKzI,GAAkB6G,OAClCiC,EAAajK,EAAM8G,IAAM9G,EAAM6I,KAAO7I,EAAM8I,KAAO9I,EAAM+I,MAEzDhC,EAAMnT,KAAKsW,YAAYlK,EAAMgJ,SAAW,GAE5C,MAAOiB,EAAaN,EAAY,CAC5B,IAAMQ,EAAW,CAAEhY,MAAOiY,GAAA/S,GACpBgT,EAAY,CAAElY,MAAO2T,GAAewE,WAE1C,GADAjB,EAAWkB,UAAUJ,EAAUE,EAAWrK,EAAO,GAAG,EAAO6J,EAAMC,EAAOC,EAAOC,GAC3EK,EAAUlY,QAAU2T,GAAewE,UAAa,MACpD,IAAIE,EAAkBxK,EAAMmJ,UAAY,EACpClI,GAAYoC,cAAc8G,EAAShY,MAAQ6N,EAAMgJ,SAAWjC,EAC5D0D,EAAgBzK,EAAMiJ,SAAWuB,EACrC,GAAId,EAAKrB,YAAcoC,EAAiB,MAGxC,OAFAzK,EAAMiJ,SAAWwB,EAETJ,EAAUlY,OACd,KAAK2T,GAAe4E,iBAChB1K,EAAMmJ,WAAY,EAClB,MACJ,KAAKrD,GAAe6E,WAChB5D,EAAO8C,EAAK7J,EAAM8G,KAAoB8D,SAEtCX,IACAjK,EAAM8G,MACN,MACJ,KAAKhB,GAAekC,MACpB,KAAKlC,GAAe+E,WAChB,IAAMC,EAAYd,EAAOhK,EAAM+I,OAG/B,GAFAyB,EAAkBM,EAASnD,WAC3B8C,EAAgBzK,EAAMiJ,SAAWuB,EAC7Bd,EAAKrB,YAAcoC,EAKnB,OAJAf,EAAKjB,WAAY,EACjBiB,EAAKhB,UAAW,EAChBgB,EAAK5I,KAAOgK,EAASvH,eACrBmG,EAAKpB,OAASvB,GAOlB,GAJA/G,EAAMiJ,SAAWwB,EAEjBR,IACAjK,EAAM+I,QACFsB,EAAUlY,QAAU2T,GAAekC,MAAS,MACpD,KAAKlC,GAAe0B,KAChB,IAAMuD,EAAWhB,EAAM/J,EAAM8I,MAG7B,GAFA0B,EAAkBO,EAAQpD,WAC1B8C,EAAgBzK,EAAMiJ,SAAWuB,EAC7Bd,EAAKrB,YAAcoC,EAKnB,OAJAf,EAAKjB,WAAY,EACjBiB,EAAKhB,UAAW,EAChBgB,EAAK5I,KAAOiK,EAAQxH,eACpBmG,EAAKpB,OAASvB,GAGlB/G,EAAMiJ,SAAWwB,EAEjBR,IACAjK,EAAM8I,OACN,MACJ,KAAKhD,GAAe1B,KAChBpE,EAAMmJ,WAAY,EAClB,IAAM6B,EAAWlB,EAAM9J,EAAM6I,MACvBoC,EAAUD,EAAQrG,YAAcqG,EAAQzH,UAC1C0H,EAAUjL,EAAMkJ,kBAChBlJ,EAAMkJ,gBAAkB+B,GAE5BvB,EAAKlB,aAAe2B,EAAShY,MAC7BuX,EAAKnB,YAAcvI,EAAMkJ,gBAEzBe,IACAjK,EAAM6I,OACN,MACJ,QACI,MAER7I,EAAMgJ,QAAUmB,EAAShY,MAGzBuX,EAAKrB,cAAgB6C,OAAOC,YAC5BzB,EAAKrB,YAAcrI,EAAMiJ,UAE7BS,EAAK5I,KAAOG,GAAYoC,cAAcrD,EAAMgJ,UAAYU,EAAKrB,YAAcrI,EAAMiJ,UAAYlC,EAC7F2C,EAAKpB,OAASvB,IAnLtB,CAAAtU,IAAA,yBAAAN,MAAA,SAsLkC6N,EAAsBc,EAAc6I,GAC9D,IAAMC,EAAOhW,KAAK6V,eACZI,EAAOD,EAAKzI,GAAkB8F,KAC9B6C,EAAQF,EAAKzI,GAAkBiD,MAC/B2F,EAAQH,EAAKzI,GAAkBqG,MAC/BwC,EAASJ,EAAKzI,GAAkB6G,OAClCiC,EAAajK,EAAM8G,IAAM9G,EAAM6I,KAAO7I,EAAM8I,KAAO9I,EAAM+I,MAEzDhC,EAAMnT,KAAKsW,YAAYlK,EAAMgJ,SAAW,GACtCoC,EAAatK,EAAOoK,OAAOC,UAEjC,MAAOlB,EAAaN,EAAY,CAC5B,IAAMQ,EAAW,CAAEhY,MAAOiY,GAAA/S,GACpBgT,EAAY,CAAElY,MAAO2T,GAAewE,WAC1CjB,EAAWkB,UAAUJ,EAAUE,EAAWrK,EAAOc,EAAMsK,EAAYvB,EAAMC,EAAOC,EAAOC,GACvF,IAAIQ,EAAkBxK,EAAMmJ,UAAY,EACpClI,GAAYoC,cAAc8G,EAAShY,MAAQ6N,EAAMgJ,SAAWjC,EAC5D0D,EAAgBzK,EAAMiJ,SAAWuB,EAGrC,OAFAxK,EAAMiJ,SAAWwB,EAETJ,EAAUlY,OACd,KAAK2T,GAAe4E,iBAChB1K,EAAMmJ,WAAY,EAClB,MACJ,KAAKrD,GAAe6E,WAChB5D,EAAO8C,EAAK7J,EAAM8G,KAAoB8D,SAEtCX,IACAjK,EAAM8G,MACN,MACJ,KAAKhB,GAAe0B,KACpB,KAAK1B,GAAe+E,WAChB,IAAME,EAAWhB,EAAM/J,EAAM8I,MAC7B0B,EAAkBO,EAAQpD,WAC1B8C,EAAgBzK,EAAMiJ,SAAWuB,EACjCxK,EAAMiJ,SAAWwB,EAEjBR,IACAjK,EAAM8I,OACN,MACJ,KAAKhD,GAAekC,MAChBwC,EAAmBR,EAAOhK,EAAM+I,OAAwBpB,WACxD8C,EAAgBzK,EAAMiJ,SAAWuB,EACjCxK,EAAMiJ,SAAWwB,EAEjBR,IACAjK,EAAM+I,QACN,MACJ,KAAKjD,GAAeuF,OAChB,OAAOrL,EAAMiJ,SACjB,KAAKnD,GAAe1B,KAChBpE,EAAMmJ,WAAY,EAClB,IAAM6B,EAAWlB,EAAM9J,EAAM6I,MACvBoC,EAAUD,EAAQrG,YAAcqG,EAAQzH,UAC1C0H,EAAUjL,EAAMkJ,kBAChBlJ,EAAMkJ,gBAAkB+B,GAG5BhB,IACAjK,EAAM6I,OACN,MACJ,QACI,MAER7I,EAAMgJ,QAAUmB,EAAShY,MAE7B,OAAO6N,EAAMiJ,WAxPrB,CAAAxW,IAAA,gBAAAN,MAAA,WA+PQyB,KAAK0X,gBAUL,IATA,IAAMC,EAAoB,GACpB3B,EAAOhW,KAAK6V,eACZI,EAAOD,EAAKzI,GAAkB8F,KAC9B6C,EAAQF,EAAKzI,GAAkBiD,MAC/B2F,EAAQH,EAAKzI,GAAkBqG,MAC/BwC,EAASJ,EAAKzI,GAAkB6G,OAEhCwD,EAAgB3B,EAAKha,OAASia,EAAMja,OAASka,EAAMla,OAASma,EAAOna,OAEhEoa,EAAasB,EAAmBtB,EAAauB,EAAevB,GAAcsB,EAAmB,CAClG,IAAME,EAAY,IAAI9C,GACtB8C,EAAUxC,UAAYrV,KAAK4V,kBAC3B,IAAME,EAAO,IAAIvB,GACjBuB,EAAKrB,YAAc6C,OAAOC,UAC1BvX,KAAK8X,gBAAgBD,EAAW/B,EAAMO,GACtCrW,KAAK0V,gBAAgBvZ,KAAK,CAAC2Z,EAAKrB,YAAaoD,IAE7C,IAAME,EAAY,IAAIhD,GACtBgD,EAAU1C,UAAYrV,KAAK4V,kBAC3B5V,KAAKgY,uBAAuBD,EAAWT,OAAOC,UAAWlB,GACzDrW,KAAK2V,gBAAgBxZ,KAAK,CAACkR,GAAYoC,cAAcsI,EAAU3C,SAAU2C,IAKzE/X,KAAK0V,gBAAgBzZ,OAAS,GAAK+D,KAAK0X,kBAzRpD,CAAA7Y,IAAA,gBAAAN,MAAA,WA6RQyB,KAAK0V,gBAAkB,GACvB1V,KAAK2V,gBAAkB,KA9R/B,CAAA9W,IAAA,aAAAN,MAAA,SAiSsByX,EAAuBiC,EAAena,GACpD,OAAIma,EAAQjC,EAAK/Z,OACb,GAAAuG,OAAU1E,EAAV,MAAA0E,OAAmByV,EAAnB,QAAAzV,OAA+BwT,EAAKiC,GAAOzI,UAE/C,GAAAhN,OAAU1E,EAAV,MAAA0E,OAAmByV,EAAnB,aArSR,CAAApZ,IAAA,qBAAAN,MAAA,SAwS8B2Z,EAAyBpa,GAC/C,IAAMkY,EAAOhW,KAAK6V,eACZI,EAAOD,EAAKzI,GAAkB8F,KAC9B6C,EAAQF,EAAKzI,GAAkBiD,MAC/B2F,EAAQH,EAAKzI,GAAkBqG,MAC/BwC,EAASJ,EAAKzI,GAAkB6G,OACtCzI,QAAQC,MAAR,GAAApJ,OAAiB1E,EAAjB,mBACA,IAAK,IAAIqa,EAAM,EAAGA,EAAMD,EAAOjc,OAAQkc,IAAO,CAC1C,IAAMC,EAAOF,EAAOC,GACpB,QAAapT,IAATqT,EAAsB,MAAM,IAAI7V,MAAM,kCAC1C,IAAM8V,EAASD,EAAK,GACpBzM,QAAQC,MAAR,GAAApJ,OAAiB2V,EAAjB,MAAA3V,OAAyB4V,EAAK,KAE9B,IAAME,EAAUtY,KAAKuY,WAAWtC,EAAMoC,EAAOnF,IAAK,OAC5CsF,EAAWxY,KAAKuY,WAAWrC,EAAOmC,EAAOpD,KAAM,QAC/CwD,EAAWzY,KAAKuY,WAAWpC,EAAOkC,EAAOnD,KAAM,QAC/CwD,EAAY1Y,KAAKuY,WAAWnC,EAAQiC,EAAOlD,MAAO,SAClDwD,EAAM,KAAAnW,OAAK8V,EAAL,MAAA9V,OAAiBgW,EAAjB,MAAAhW,OAA8BiW,EAA9B,MAAAjW,OAA2CkW,EAA3C,qBAAAlW,OACc6V,EAAOjD,QADrB,gBAAA5S,OAC2C6V,EAAOhD,SADlD,6BAAA7S,OAEsB6V,EAAO/C,gBAF7B,iBAAA9S,OAE4D6V,EAAO9C,WAC/E5J,QAAQC,MAAM+M,MA5T1B,CAAA9Z,IAAA,mBAAAN,MAAA,WAiUQoN,QAAQC,MAAM,qCACd5L,KAAK4Y,mBAAmB5Y,KAAK0V,gBAAiB,mBAC9C1V,KAAK4Y,mBAAmB5Y,KAAK2V,gBAAiB,mBAC9ChK,QAAQC,MAAM,oCApUtB,CAAA/M,IAAA,QAAAN,MAAA,WAyUQ,IAAK,IAAIsa,EAAM,EAAGA,EAAMtL,GAAkBzD,IAAK+O,IAC3C,GAAI7Y,KAAK6V,eAAegD,GAAK5c,OAAS,EAClC,OAAO,EAGf,OAAO,IA9Uf,CAAA4C,IAAA,kBAAAN,MAAA,SAuV2Bua,EAAiBD,GACpC,IAAME,EAAW/Y,KAAKgZ,kBAAkBH,GAExC,GAAwB,IAApBE,EAAS9c,OAAc,CACvB,IAAMgd,EAAa3E,GAAcuE,GACjC,GAAmB,OAAfI,EAAuB,MAAM,IAAI1W,MAAM,0CAC3C,OAAO0W,EAGX,IAAMhB,EAAQjY,KAAKkZ,qBAAqBL,EAAKC,GACvCK,EAAMJ,EAASd,GAErB,OAAQkB,EAAIC,iBACR,KAAK5L,GAAkBwE,WAEnB,OAAOmH,EACX,QAGI,GAAIA,EAAI3J,WAAasJ,EACjB,OAAOK,EAEX,IAAME,EAAa/E,GAAcuE,GACjC,GAAmB,OAAfQ,EAAuB,MAAM,IAAI9W,MAAM,0CAC3C,OAAO8W,KA/WvB,CAAAxa,IAAA,qBAAAN,MAAA,SAsX8Bua,GACtB,IAAMta,EAAIwB,KAAKsZ,gBAAgBR,EAASvL,GAAkB8F,KAC1D,OAAQ7U,IAxXhB,CAAAK,IAAA,sBAAAN,MAAA,SA0X+Bua,GACvB,IAAMta,EAAIwB,KAAKsZ,gBAAgBR,EAASvL,GAAkBqG,MAC1D,OAAQpV,IA5XhB,CAAAK,IAAA,uBAAAN,MAAA,SA8XgCua,GACxB,IAAMta,EAAIwB,KAAKsZ,gBAAgBR,EAASvL,GAAkB6G,OAC1D,OAAQ5V,IAhYhB,CAAAK,IAAA,cAAAN,MAAA,SAoYuBua,GAAmB,OAAO9Y,KAAKuZ,mBAAmBT,GAASxF,WApYlF,CAAAzU,IAAA,eAAAN,MAAA,SAqYwBua,GAAmB,OAAO9Y,KAAKwZ,oBAAoBV,GAAS/E,aArYpF,CAAAlV,IAAA,gBAAAN,MAAA,SAsYyBua,GAAmB,OAAO9Y,KAAKyZ,qBAAqBX,GAAS/E,aAtYtF,CAAAlV,IAAA,cAAAN,MAAA,SAwYuBua,GACf,IAAM5C,EAAQlW,KAAKgZ,kBAAkBzL,GAAkBiD,MACvD,GAAqB,IAAjB0F,EAAMja,OAAgB,OAAO,EAEjC,IAAMF,EAAIiE,KAAKkZ,qBAAqB3L,GAAkBiD,KAAMsI,GAC5D,IAAW,IAAP/c,EAAY,OAAO,EAEvB,IAAMsB,EAAI6Y,EAAMna,GACV2d,EAAUrM,GAAYoC,cAAcqJ,GAC1C,OAAIzb,EAAEsS,WAAa+J,GAAWA,EAAWrc,EAAEsS,UAAYtS,EAAE0T,cAES,IAA1D/Q,KAAKgZ,kBAAkBzL,GAAkBqG,MAAM3X,QACY,IAA3D+D,KAAKgZ,kBAAkBzL,GAAkB6G,OAAOnY,QAGjB,IAA/B+D,KAAK2Z,aAAab,IAAkD,IAAhC9Y,KAAK4Z,cAAcd,MAvZvE,CAAAja,IAAA,eAAAN,MAAA,SA8ZwB2O,GAAgB,OAAOlN,KAAK6Z,YAAYxM,GAAYD,cAAcF,MA9Z1F,CAAArO,IAAA,cAAAN,MAAA,SAgauBua,GAEf,OAAO,IAlaf,CAAAja,IAAA,eAAAN,MAAA,SA2awB2O,GAAgB,OAAOlN,KAAK8Z,YAAYzM,GAAYD,cAAcF,MA3a1F,CAAArO,IAAA,kBAAAN,MAAA,SA6a2BqC,GAAe,OAAQZ,KAAK6Z,YAAYjZ,KAASZ,KAAK8Z,YAAYlZ,KA7a7F,CAAA/B,IAAA,mBAAAN,MAAA,SA8a4B2O,GAAgB,OAAOlN,KAAK+Z,gBAAgB1M,GAAYD,cAAcF,MA9alG,CAAArO,IAAA,eAAAN,MAAA,SAgbwByb,GAChBha,KAAKia,UAAUja,KAAK4V,kBAAoBoE,KAjbhD,CAAAnb,IAAA,YAAAN,MAAA,SAobqB2b,GACTA,IAAWla,KAAK4V,oBAChB5V,KAAK4V,kBAAoBsE,KAtbrC,CAAArb,IAAA,YAAAN,MAAA,WA6bQ,OAAOyB,KAAK4V,oBA7bpB,CAAA/W,IAAA,oBAAAN,MAAA,SAgc6Bsa,GACrB,OAAO7Y,KAAK6V,eAAegD,KAjcnC,CAAAha,IAAA,aAAAN,MAAA,SAocsB4a,GAEd,IAAMN,EAAMM,EAAIhI,UACV6E,EAAOhW,KAAK6V,eAAegD,GAGjC,GAAoB,IAAhB7C,EAAK/Z,OAAT,CAOA,IAAMgc,EAAQjY,KAAKkZ,qBAAqBL,EAAKM,EAAI3J,UACjD,GAAIyI,IAAU5D,GAEV,MAAM,IAAI9R,MAAM,uDAEpB,IAAM4X,EAAqBnE,EAAKiC,GAC1BmC,EAAYjB,EAAIiB,YAChBC,EAAYlB,EAAI3J,WAAa2K,EAAI3K,SAGvC,GAAK4K,GAAcC,EAAnB,CAKA,OAAQlB,EAAIC,iBACR,KAAK5L,GAAkBqG,IACvB,KAAKrG,GAAkBiD,MAGnB,GAAI4J,GAAaD,EAGb,YADApE,EAAK7Y,OAAO8a,EAAO,GAGvB,MACJ,KAAKzK,GAAkBwE,WACnB,IAAIsI,EAAsBH,EAc1B,GAVIE,GAAapC,EAAQ,IACrBqC,EAAOtE,EAAKiC,EAAQ,IASpBA,EAAQjC,EAAK/Z,OAAS,EAAG,CACzB,IAAMse,EAAsBvE,EAAKiC,EAAQ,GACzC,GAAIkB,EAAIqB,OAAOD,GAEX,OAAIpB,EAAIqB,OAAOF,IAGXtE,EAAK7Y,OAAO8a,EAAQ,EAAG,QAInBqC,IAASH,GACTnE,EAAK7Y,OAAO8a,EAAO,MAKvBsC,EAAKjL,OAAO6J,EAAI3J,eAGZ8K,IAASH,GACTnE,EAAK7Y,OAAO8a,EAAO,KAM3B,GAAIqC,EAAKE,OAAOrB,GAMZ,YAHImB,IAASH,GACTnE,EAAK7Y,OAAO8a,EAAO,SAO/B,GAAIqC,EAAKE,OAAOrB,GAKZ,YAHImB,IAASH,GACTnE,EAAK7Y,OAAO8a,EAAO,IAK/B,MACJ,QACI,MAKR,IAAIoC,IAAcF,EAAIK,OAAOrB,GAA7B,CAOA,IAAMtL,EAAOtC,KAAcC,KAAcC,KAAsB0N,IAAOA,GACtE,GAAIkB,EAGArE,EAAKiC,GAASpK,MACX,CAEH,IAAI9R,EAAIia,EAAKyE,UAAU,SAACC,GAAD,OAASA,EAAGC,SAAS9M,MACjC,IAAP9R,IAEAA,EAAIia,EAAK/Z,QAGb+Z,EAAK7Y,OAAOpB,EAAG,EAAG8R,UAzHtB,CAEI,IAAM+M,EAAMrP,KAAcC,KAAcC,KAAsB0N,IAAOA,GACrEnD,EAAK7Z,KAAKye,MA7ctB,CAAA/b,IAAA,0BAAAN,MAAA,SAwkBQua,EAAiB+B,EACjBC,EAAiCC,GAG7BF,EAAgBtc,MAAQ,EAExB,IADA,IAAMyc,EAAQhb,KAAKgZ,kBAAkBzL,GAAkBkF,UAC9C1W,EAAI,EAAGA,EAAIif,EAAM/e,OAAQF,IAAK,CACnC,IAAMkf,EAAUD,EAAMjf,GAChBmf,EAAiBnf,EAAI,IAAMif,EAAM/e,OAAjBua,GAAA/S,EAAqDwX,EAAOzL,SAE5E2L,EAA4BF,EAAOG,wBAEnCC,EAAyBJ,EAAOK,qBAEtC,GAAIxC,GAAWmC,EAAOzL,SAAU,CAE5B,IAAM+L,EAAqBzC,EAAUmC,EAAOzL,SAEtCgM,EAAyB9R,KAAKyC,MAAMoP,EAAqBJ,GAK/D,OAJAN,EAAgBtc,OAASid,EAEzBV,EAAavc,MAAQmL,KAAKyC,MAAMoP,EAAqBF,QACrDN,EAAcxc,MAAQgd,EAAqBJ,GAI3C,IAAMM,EAAqBP,EAAgBD,EAAOzL,SAC5CkM,EAAyBhS,KAAKyC,OAC/BsP,EAAqBN,EAA4B,GAAKA,GAC3DN,EAAgBtc,OAASmd,EAGjC,MAAM,IAAInZ,MAAM,iDAxmB5B,CAAA1D,IAAA,uBAAAN,MAAA,SA2mBgCsa,EAAwBjY,GAChD,IAAMoV,EAAOhW,KAAK6V,eAAegD,GACjC,GAAoB,IAAhB7C,EAAK/Z,OACL,OAAOoY,GAMX,IAAMsH,EAAM,EACNC,EAAM5F,EAAK/Z,OAAS,EACtByB,EAAIie,EACJvd,EAAIwd,EAER,MAAQle,GAAKU,EAAI,CACb,IAAMT,EAAI+L,KAAKyC,OAAOzO,EAAIU,GAAK,GAC/B,IAAOT,IAAMge,GAAO3F,EAAKrY,GAAG6R,UAAY5O,KAAWjD,IAAMie,GAAOhb,EAAMoV,EAAKrY,EAAI,GAAG6R,UAC9E,OAAO7R,EACAqY,EAAKrY,GAAG6R,UAAY5O,EAC3BlD,EAAIC,EAAI,EAERS,EAAIT,EAAI,EAIhB,OAAO0W,KApoBf,CAAAxV,IAAA,wBAAAN,MAAA,SAsoBiCsa,EAAwB3L,GACjD,OAAOlN,KAAKkZ,qBAAqBL,EAAKxL,GAAYD,cAAcF,MAvoBxE,CAAArO,IAAA,0BAAAN,MAAA,SA0oBmCsa,EAAwBjY,GACnD,IAAMoV,EAAOhW,KAAKgZ,kBAAkBH,GAD0BgD,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAE9D,QAAAiX,EAAAC,EAAAC,IAAkBlG,KAAlB6F,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAAwB,KAAb1C,EAAa6C,EAAAzd,MACpB,KAAI4a,EAAI3J,UAAY5O,GACpB,OAAOuY,EAAIxJ,WAJ+C,MAAAyM,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,GAM9D,OAAO1O,GAAYoC,cAAc7O,KAhpBzC,CAAA/B,IAAA,2BAAAN,MAAA,SAkpBoCsa,EAAwB3L,GACpD,OAAOlN,KAAKsc,wBAAwBzD,EAAKxL,GAAYD,cAAcF,MAnpB3E,CAAArO,IAAA,8BAAAN,MAAA,SAspBuCsa,EAAwBjY,GACvD,IAAI2b,GAAU,EACRvG,EAAOhW,KAAKgZ,kBAAkBH,GAF8B2D,GAAA,EAAAC,GAAA,EAAAC,OAAA3X,EAAA,IAGlE,QAAA4X,EAAAC,EAAAV,IAAkBlG,KAAlBwG,GAAAG,EAAAC,EAAArC,QAAA4B,MAAAK,GAAA,EAAwB,KAAbrD,EAAawD,EAAApe,MACpB,GAAI4a,EAAI3J,UAAY5O,EAAO,MAC3B2b,EAASpD,EAAIxJ,WALiD,MAAAyM,GAAAK,GAAA,EAAAC,EAAAN,EAAA,YAAAI,GAAA,MAAAI,EAAAP,QAAAO,EAAAP,SAAA,WAAAI,EAAA,MAAAC,GAOlE,OAAQH,GAAU,EAAKA,EAASlP,GAAYoC,cAAc7O,KA7pBlE,CAAA/B,IAAA,+BAAAN,MAAA,SA+pBwCsa,EAAwB3L,GACxD,OAAOlN,KAAK6c,4BAA4BhE,EAAKxL,GAAYD,cAAcF,MAhqB/E,CAAArO,IAAA,yBAAAN,MAAA,SAmqBkCkW,GAC1B,IAAMqB,EAAO,IAAIvB,GAGjB,OAFAuB,EAAKrB,YAAcA,EACnBzU,KAAK8c,6BAA6BhH,GAC3BA,EAAK5I,OAvqBpB,CAAArO,IAAA,iCAAAN,MAAA,SA0qB0Cwe,GAElC,OAAO/c,KAAKgd,uBAAuBD,KA5qB3C,CAAAle,IAAA,iCAAAN,MAAA,SA+qB0C2O,GAClC,IAAId,EAAQ,IAAI2I,GAChB3I,EAAMiJ,UAAYrV,KAAK4V,kBACvB,IAAMqH,EAAgBxH,EAAWyH,kBAAkBld,KAAK2V,gBAAiBzI,GAMzE,YALsBnI,IAAlBkY,IAEA7Q,EAAQb,KAAcC,KAAcC,KAAsBwR,EAAc,KAAMA,EAAc,KAEhGjd,KAAKgY,uBAAuB5L,EAAOc,EAAnCsJ,GAAA/S,GACO2I,EAAMiJ,WAxrBrB,CAAAxW,IAAA,yBAAAN,MAAA,SA2rBkC2O,GAC1B,OAAOlN,KAAKmd,+BAA+BjQ,KA5rBnD,CAAArO,IAAA,+BAAAN,MAAA,SAgsBwCuX,GAEhC9V,KAAKod,qCAAqCtH,KAlsBlD,CAAAjX,IAAA,uCAAAN,MAAA,SAqsBgDuX,GACxC,IAAI1J,EAAQ,IAAI2I,GAChB3I,EAAMiJ,UAAYrV,KAAK4V,kBACvB,IAAMqH,EAAgBxH,EAAWyH,kBAAkBld,KAAK0V,gBAAiBI,EAAKrB,kBACxD1P,IAAlBkY,IAEA7Q,EAAQb,KAAcC,KAAcC,KAAsBwR,EAAc,KAAMA,EAAc,KAEhGjd,KAAK8X,gBAAgB1L,EAAO0J,EAA5BU,GAAA/S,KA7sBR,CAAA5E,IAAA,2BAAAN,MAAA,SAgtBoC8e,EAAkBC,GAC9C,IAAMC,EAASvd,KAAKgZ,kBAAkBzL,GAAkBiQ,OACxD,OAAID,EAAOthB,OAAuB,IAltB1C,CAAA4C,IAAA,aAAAN,MAAA,SA4tBsBkf,GACVA,GAAczd,KAAK0d,UAKmC,IAAtD1d,KAAK6V,eAAetI,GAAkB8F,KAAKpX,SAC3C0P,QAAQgS,KAAK,kDACb3d,KAAK4d,WAAW,IAAI9K,GAAW,EAAG,MAIyB,IAA3D9S,KAAK6V,eAAetI,GAAkB8F,KAAK,GAAG7D,UAC9CxP,KAAK6V,eAAetI,GAAkB8F,KAAK,GAAG/D,OAAO,GAIM,IAA3DtP,KAAK6V,eAAetI,GAAkBkF,UAAUxW,QAChD+D,KAAK4d,WAAW,IAAIzL,GAAqB,IAOmB,IAA5DnS,KAAK6V,eAAetI,GAAkBwE,WAAW9V,QACjD+D,KAAK4d,WAAW,IAAIpM,GAAiB,QAtvBjD,EAAA3S,IAAA,oBAAAN,MAAA,SAEoC2Z,EAAyB2F,GACrD,GAAsB,IAAlB3F,EAAOjc,OAAX,CACA,IAAI6hB,EAAQ,EACRC,EAAQ7F,EAAOjc,OAAS,EAIxB+hB,EAAa9F,EAAO4F,GACxB,QAAmB/Y,IAAfiZ,EAA4B,MAAM,IAAIzb,MAAM,iCAChD,KAAIyb,EAAW,GAAKH,GAApB,CAIA,GADAG,EAAa9F,EAAO6F,QACDhZ,IAAfiZ,EAA4B,MAAM,IAAIzb,MAAM,iCAChD,GAAIyb,EAAW,GAAKH,EAEhB,OAAO3F,EAAO6F,EAAQ,GAI1B,MAAOA,EAAQD,EAAQ,EAAG,CACtB,IAAMvD,EAAO7Q,KAAKyC,OAAO4R,EAAQD,GAAS,GAE1C,GADAE,EAAa9F,EAAOqC,QACDxV,IAAfiZ,EAA4B,MAAM,IAAIzb,MAAM,gCAChD,GAAIyb,EAAW,GAAKH,EAChBE,EAAQxD,MACL,MAAIyD,EAAW,GAAKH,GAEpB,CAEHC,EAAQvD,EACR,MAJAuD,EAAQvD,GAWhB,GAAc,IAAVuD,EACJ,OAAO5F,EAAO4F,EAAQ,OAzC9B,CAAAjf,IAAA,YAAAN,MAAA,SA6CQgY,EAA6BE,EAC7BwH,EAAyB/Q,EAAcsK,EAAqBvB,EAC5DC,EAAwBC,EAAwBC,GAiB5C,GAhBI6H,EAAO1I,WAAalI,GAAYD,cAAc6Q,EAAO3I,iBAAmBiB,EAAShY,QACjFgY,EAAShY,MAAQ8O,GAAYD,cAAc6Q,EAAO3I,iBAClDmB,EAAUlY,MAAQ2T,GAAe4E,kBAEjCmH,EAAO/K,IAAM+C,EAAKha,QAAUga,EAAKgI,EAAO/K,KAAK1D,SAAW+G,EAAShY,QACjEgY,EAAShY,MAAQ0X,EAAKgI,EAAO/K,KAAK1D,SAClCiH,EAAUlY,MAAQ2T,GAAe6E,YAEjCkH,EAAO9I,MAAQiB,EAAOna,QAAUma,EAAO6H,EAAO9I,OAAO3F,SAAW+G,EAAShY,QACzEgY,EAAShY,MAAQ6X,EAAO6H,EAAO9I,OAAO3F,SACtCiH,EAAUlY,MAAQ2T,GAAekC,OAEjCoD,GAAcnK,GAAYD,cAAcF,GAAQqJ,EAAShY,QACzDgY,EAAShY,MAAQ8O,GAAYD,cAAcF,GAC3CuJ,EAAUlY,MAAQ2T,GAAeuF,QAEjCwG,EAAO/I,KAAOiB,EAAMla,QAAUka,EAAM8H,EAAO/I,MAAM1F,SAAW+G,EAAShY,MAAO,CAE5E,IAAM2f,EAAS,CAAC3f,MAAOgY,EAAShY,OAChCgY,EAAShY,MAAQ4X,EAAM8H,EAAO/I,MAAM1F,SACpCiH,EAAUlY,MAAS2f,EAAO3f,QAAUgY,EAAShY,MAAS2T,GAAe+E,WAAa/E,GAAe0B,KAEjGqK,EAAOhJ,KAAOiB,EAAMja,QAAUia,EAAM+H,EAAOhJ,MAAMzF,SAAW+G,EAAShY,QACrEgY,EAAShY,MAAQ2X,EAAM+H,EAAOhJ,MAAMzF,SACpCiH,EAAUlY,MAAQ2T,GAAe1B,UAxEjDiF,EAAA,GAkxBe0I,GAAA,2BC32BTC,GAAuB,IACvBC,GAA8B,IASvBC,GAAb,WA0DI,SAAAC,EAAYC,EAAeC,GAEvB,GAFkCriB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAue,QAErBxZ,IAATyZ,QAA6BzZ,IAAP0Z,EAGtB,OAFAze,KAAKwe,KAAOA,OACZxe,KAAKye,GAAKA,GAIdze,KAAKwe,KAAO,EACZxe,KAAKye,GAAK,EACVze,KAAK0e,QApEb,OAAAtiB,OAAA2K,EAAA,KAAA3K,CAAAmiB,EAAA,EAAA1f,IAAA,MAAAN,MAAA,WAyEQ,IAAMogB,EAAM,IAAIJ,EAChB,OAAOI,EAAIC,SAAS5e,QA1E5B,CAAAnB,IAAA,QAAAN,MAAA,WA6EQ,IAAMsgB,EAAON,EAAUO,UACvB9e,KAAKwe,KAAOK,EAAKL,KACjBxe,KAAKye,GAAKI,EAAKJ,KA/EvB,CAAA5f,IAAA,SAAAN,MAAA,WAiF+B,OAAqB,IAAdyB,KAAKwe,MAA0B,IAAZxe,KAAKye,KAjF9D,CAAA5f,IAAA,UAAAN,MAAA,WAkFuByB,KAAKwe,KAAO,EAAGxe,KAAKye,GAAK,IAlFhD,CAAA5f,IAAA,eAAAN,MAAA,WAsFQ,IAAMogB,EAAM,IAAIJ,EACVQ,EAAOR,EAAUS,WAAWL,EAAK3e,MAIvC,OAFAA,KAAKwe,KAAOG,EAAIH,KAChBxe,KAAKye,GAAKE,EAAIF,GACPM,IA3Ff,CAAAlgB,IAAA,gBAAAN,MAAA,WA8F6B,OAAOyB,KAAKif,QA9FzC,CAAApgB,IAAA,OAAAN,MAAA,WA0GQ,IAAM2gB,EAAgBlf,KAAKif,MAAQ,EACnC,OAAOjf,KAAKqF,IAAI6Z,KA3GxB,CAAArgB,IAAA,MAAAN,MAAA,SAgHe4gB,GACP,OAAOZ,EAAUa,IAAIpf,KAAMmf,KAjHnC,CAAAtgB,IAAA,WAAAN,MAAA,SAmHoB8gB,GACZ,OAAOd,EAAUS,WAAWhf,KAAMqf,KApH1C,CAAAxgB,IAAA,WAAAN,MAAA,SAsHoB8gB,GACZ,OAAIrf,KAAKwe,OAASa,EAAIb,KAAexe,KAAKwe,KAAOa,EAAIb,KAC9Cxe,KAAKye,GAAKY,EAAIZ,MAxH7B,EAAA5f,IAAA,UAAAN,MAAA,WAGQ,IAAMsgB,EAAOS,OACPd,EAAOK,EAAK,GACZJ,EAAK/U,KAAKyC,MAAM0S,EAAK,GAAKR,IACD,IAA3BE,EAAUgB,eACVhB,EAAUgB,aAAef,EACzBD,EAAUiB,WAAaf,GAG3B,IAAIgB,EAAYjB,EAAOD,EAAUgB,aAC7BG,EAAUjB,EAAKF,EAAUiB,WAK7B,OAJIE,EAAU,IACVA,GAAWtB,KACTqB,GAEC,CAAEjB,KAAMiB,EAAWhB,GAAIiB,KAjBtC,CAAA7gB,IAAA,MAAAN,MAAA,SA0BuBohB,EAAgBR,GAI/B,IAAMxL,EAAUjK,KAAKyC,MAAMgT,GACrBV,EAAK/U,KAAKyC,OAAQgT,EAAKxL,GAAWyK,IAElCwB,EAAM,IAAIrB,EAAU,EAAG,GAQ7B,OAPAqB,EAAIpB,KAAO7K,EAAUgM,EAAInB,KACzBoB,EAAInB,GAAKA,EAAKkB,EAAIlB,GAEdmB,EAAInB,IAAML,KACVwB,EAAInB,IAAML,KACRwB,EAAIpB,MAEHoB,IAzCf,CAAA/gB,IAAA,aAAAN,MAAA,SA4C8BohB,EAAgBN,GACtC,IAAIb,EAAOmB,EAAInB,KAAOa,EAAIb,KACtBC,EAAKkB,EAAIlB,GAAKY,EAAIZ,GAMtB,OAJIA,EAAK,IACLA,GAAML,KACJI,GAECA,EAAOC,EAAKL,OApD3BG,EAAA,GAoBmBD,GAAAiB,aAAe,EACfjB,GAAAkB,WAAa,EAsGjB,IClIHK,GASAC,GDyHGC,GAAA,GAEFC,GAAa,IAAI1B,GAAU,EAAG,2ECxI9B2B,cAAe,KAI5B,SAAYJ,GACRA,IAAA,sBACAA,IAAA,sBACAA,IAAA,sBACAA,IAAA,yBAJJ,CAAYA,QAAiB,KAS7B,SAAYC,GACRA,IAAA,kCACAA,IAAA,kCACAA,IAAA,kCACAA,IAAA,8BACAA,IAAA,0CACAA,IAAA,oCACAA,IAAA,gCACAA,IAAA,wCACAA,IAAA,gCACAA,IAAA,gCACAA,IAAA,mCACAA,IAAA,+BACAA,IAAA,+BACAA,IAAA,+BACAA,IAAA,2BACAA,IAAA,iCACAA,IAAA,qCACAA,IAAA,mCACAA,IAAA,mCACAA,IAAA,mCACAA,IAAA,mCACAA,IAAA,mCACAA,IAAA,mCACAA,IAAA,qCACAA,IAAA,qCACAA,IAAA,uCACAA,IAAA,uCACAA,IAAA,uCACAA,IAAA,uCACAA,IAAA,uCACAA,IAAA,uCACAA,IAAA,6BACAA,IAAA,6BACAA,IAAA,uCACAA,IAAA,qCACAA,IAAA,yCACAA,IAAA,uCACAA,IAAA,2CACAA,IAAA,iBACAA,IAAA,yBAxCJ,CAAYA,QAAS,KA4Cd,IAoFKI,GApFCC,GAAb,WAUI,SAAAC,EAAYC,EAAsBC,EACtBC,EAAuBC,GAAoCpkB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAogB,GACnEpgB,KAAKqgB,aAAeA,EACpBrgB,KAAKsgB,UAAYA,EACjBtgB,KAAKugB,aAAeA,EACpBvgB,KAAKwgB,kBAAoBA,EAfjC,OAAApkB,OAAA2K,EAAA,KAAA3K,CAAAgkB,EAAA,EAAAvhB,IAAA,WAAAN,MAAA,WAmBQ,OAAOyB,KAAKqgB,iBAnBpBD,EAAA,GA2BaK,GAAkC,CAE3C,IAAIN,GAAc,eAAgB,GAAG,EAAMN,GAAkBa,QAC7D,IAAIP,GAAc,eAAgB,GAAG,EAAMN,GAAkBc,QAC7D,IAAIR,GAAc,eAAgB,GAAG,EAAMN,GAAkBe,QAC7D,IAAIT,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,mBAAoB,GAAG,EAAMN,GAAkBa,QACjE,IAAIP,GAAc,gBAAiB,GAAG,EAAON,GAAkBgB,SAE/D,IAAIV,GAAc,cAAe,GAAG,EAAMN,GAAkBa,QAC5D,IAAIP,GAAc,kBAAmB,GAAG,EAAMN,GAAkBc,QAChE,IAAIR,GAAc,cAAe,IAAI,EAAMN,GAAkBc,QAC7D,IAAIR,GAAc,cAAe,IAAI,EAAMN,GAAkBe,QAE7D,IAAIT,GAAc,eAAgB,IAAI,EAAMN,GAAkBgB,SAE9D,IAAIV,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAG3D,IAAIP,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,aAAc,IAAI,EAAMN,GAAkBc,QAC5D,IAAIR,GAAc,WAAY,GAAG,EAAMN,GAAkBa,QAEzD,IAAIP,GAAc,cAAe,GAAG,EAAMN,GAAkBa,QAE5D,IAAIP,GAAc,gBAAiB,GAAG,EAAMN,GAAkBa,QAE9D,IAAIP,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,aAAc,IAAI,EAAMN,GAAkBc,QAC5D,IAAIR,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,aAAc,GAAG,EAAMN,GAAkBa,QAC3D,IAAIP,GAAc,aAAc,IAAI,EAAMN,GAAkBc,QAE5D,IAAIR,GAAc,gBAAiB,GAAG,EAAMN,GAAkBa,QAC9D,IAAIP,GAAc,gBAAiB,GAAG,EAAMN,GAAkBc,QAE9D,IAAIR,GAAc,iBAAkB,GAAG,EAAMN,GAAkBa,QAC/D,IAAIP,GAAc,iBAAkB,GAAG,EAAMN,GAAkBa,QAC/D,IAAIP,GAAc,iBAAkB,GAAG,EAAMN,GAAkBa,QAC/D,IAAIP,GAAc,iBAAkB,GAAG,EAAMN,GAAkBc,QAC/D,IAAIR,GAAc,iBAAkB,IAAI,EAAMN,GAAkBc,QAChE,IAAIR,GAAc,iBAAkB,IAAI,EAAMN,GAAkBc,QAEhE,IAAIR,GAAc,WAAY,GAAG,EAAMN,GAAkBa,QACzD,IAAIP,GAAc,WAAY,GAAG,EAAMN,GAAkBa,QAEzD,IAAIP,GAAc,iBAAkB,GAAG,EAAON,GAAkBa,QAEhE,IAAIP,GAAc,gBAAiB,GAAG,EAAMN,GAAkBa,QAC9D,IAAIP,GAAc,kBAAmB,GAAG,EAAMN,GAAkBa,QAChE,IAAIP,GAAc,iBAAkB,GAAG,EAAMN,GAAkBa,QAC/D,IAAIP,GAAc,mBAAoB,GAAG,EAAMN,GAAkBa,UAKrE,SAAYR,GACRA,IAAA,0BACAA,IAAA,kBACAA,IAAA,sBACAA,IAAA,kBACAA,IAAA,4BACAA,IAAA,kBACAA,IAAA,gBACAA,IAAA,yBARJ,CAAYA,QAAU,KAWtB,IAAMY,GAAyD,IAAIlc,EAAAnB,EAAI,CACnE,CAAC,WAAYyc,GAAWa,UACxB,CAAC,OAAQb,GAAWc,MACpB,CAAC,QAASd,GAAWc,MACrB,CAAC,QAASd,GAAWc,MACrB,CAAC,SAAUd,GAAWe,QACtB,CAAC,UAAWf,GAAWe,QACvB,CAAC,QAASf,GAAWe,QACrB,CAAC,WAAYf,GAAWe,QACxB,CAAC,YAAaf,GAAWe,QACzB,CAAC,OAAQf,GAAWgB,MACpB,CAAC,MAAOhB,GAAWgB,MACnB,CAAC,SAAUhB,GAAWgB,MACtB,CAAC,QAAShB,GAAWgB,MACrB,CAAC,UAAWhB,GAAWiB,WACvB,CAAC,YAAajB,GAAWiB,WACzB,CAAC,SAAUjB,GAAWiB,WACtB,CAAC,MAAOjB,GAAWiB,WACnB,CAAC,OAAQjB,GAAWkB,QAcXC,GAAb,oBAAAC,IAAAllB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAshB,GAAA,OAAAllB,OAAA2K,EAAA,KAAA3K,CAAAklB,EAAA,OAAAziB,IAAA,oBAAAN,MAAA,SACoCgjB,GAC5B,IAAK,IAAIxlB,EAAI,EAAGA,EAAI0kB,GAAexkB,OAAQF,IACvC,GAAI0kB,GAAe1kB,GAAGskB,eAAiBkB,EACnC,OAAOxlB,EAGf,OAAO+jB,GAAU3V,UAPzB,CAAAtL,IAAA,mBAAAN,MAAA,SAUmCijB,GAC3B,GAAIA,GAAM1B,GAAUhW,IAChB,MAAM,IAAIvH,MAAJ,gDAAAC,OAA0Dgf,IAEpE,OAAOf,GAAee,KAd9B,CAAA3iB,IAAA,6BAAAN,MAAA,SAiB6CkjB,GACrC,IAAMC,EAAaZ,GAA8B3iB,IAAIsjB,EAAcE,eACnE,YAAmB5c,IAAf2c,EACOxB,GAAW/V,QAEfuX,IAtBf,CAAA7iB,IAAA,kBAAAN,MAAA,SAyBkCqjB,GAC1B,IAAMC,EAAYD,EAAOE,MAAM,KAC/B,MAAOD,EAAU5lB,OAAS,EACtB4lB,EAAU1kB,OAAO,EAAG,EAAG,KAE3B,IAAIwW,EAAU,EAId,OAHAA,GAA4C,GAAjC3T,KAAK+hB,YAAYF,EAAU,IAAW,GACjDlO,GAA4C,GAAjC3T,KAAK+hB,YAAYF,EAAU,IACtClO,GAAW3T,KAAKgiB,cAAcH,EAAU,IACjClO,IAlCf,CAAA9U,IAAA,cAAAN,MAAA,SA2C8B0jB,GACtB,IAAMC,EAAqB,GACrBC,EAAOC,KAAYH,GACVE,EAAKE,IAAI,SAACC,GACrB,GAAU,QAANA,EAAJ,CACA,IAAM/jB,EAAS0jB,EAAiBK,GAC5B/jB,EAAQ0jB,EAASnY,KACjBoY,EAAS/lB,KAAKoC,MAGtB,OAAO2jB,IArDf,CAAArjB,IAAA,QAAAN,MAAA,SAyDwBmU,EAAaiJ,EAAaC,GAC1C,OAAOlS,KAAKiS,IAAIjS,KAAKkS,IAAIlJ,EAAKiJ,GAAMC,KA1D5C,CAAA/c,IAAA,cAAAN,MAAA,SAqE8Boa,GACtB,IAAM4J,EAAMC,KAAS7J,EAAK,IAC1B,OAAI8J,MAAMF,GACC,EAEJA,IA1Ef,CAAA1jB,IAAA,gBAAAN,MAAA,SA6EgCoa,GACxB,IAAM+J,EAAQC,KAAWhK,GACzB,OAAI8J,MAAMC,GACC,EAEJA,IAlFf,CAAA7jB,IAAA,OAAAN,MAAA,SAsFuB4J,EAAWzK,EAAWklB,GACrC,OAAQA,EAAIllB,GAAKyK,EAAIzK,IAvF7B,CAAAmB,IAAA,QAAAN,MAAA,SAiGwB4J,EAAW0a,EAAYC,EAAYC,EAAYC,GAC/D,OAAgB,IAAPH,GAAmB,IAAPC,EAAaxB,EAAQ2B,KAAK9a,EAAG4a,EAAIC,IAAO7a,EAAI0a,IAAOG,EAAKD,IAAOD,EAAKD,GAAME,MAlGvGzB,EAAA,GAqGe4B,GAAA,GCzRTC,cAIF,SAAAC,EAAYC,GAAWjnB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAojB,GACnBpjB,KAAKqjB,MAAQA,sDAGLC,QACGve,IAAPue,GACAtjB,KAAKsB,KAAKgiB,GAEdtjB,KAAKqjB,MAAMzZ,uCAIX5J,KAAKqjB,MAAMvP,qCAGH+K,GACR7e,KAAKqjB,MAAM/hB,KAAKud,sCAGA,OAAO7e,KAAKqjB,+CAE5B,IAAME,EAAcvjB,KAAKqjB,MAAM/hB,OAC/B,OAAOiiB,WAGAC,GAAA,GCxBTC,GAA4B,EAAIxD,GAAgB,EAChDyD,GAA2B,IAEpBC,GAAb,WASI,SAAAC,EAAYC,EAAaC,GAAkB1nB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA4jB,GALpC5jB,KAAA+jB,WAAY,EACZ/jB,KAAAgkB,gBAAiB,EAKpBhkB,KAAK6jB,MAAQ,IAAIL,GAAUK,GAC3B7jB,KAAK8jB,OAASA,EAXtB,OAAA1nB,OAAA2K,EAAA,KAAA3K,CAAAwnB,EAAA,EAAA/kB,IAAA,WAAAN,MAAA,WAeQ,YAAsBwG,IAAf/E,KAAK6jB,UAfpBD,EAAA,GAmBaK,GAAb,SAAAC,IAAA9nB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAkkB,GACWlkB,KAAA+jB,WAAY,EAGZ/jB,KAAAmkB,aAAe,EACfnkB,KAAAokB,cAAgB,EAChBpkB,KAAAqkB,oBAAsB,EACtBrkB,KAAAskB,qBAAuB,EACvBtkB,KAAAukB,WAAY,EACZvkB,KAAAwkB,WAAY,EACZxkB,KAAAgkB,gBAAiB,GAMfS,GAAb,WA2BI,SAAAC,IAAAtoB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA0kB,GAZQ1kB,KAAA2kB,eAAgB,EAGhB3kB,KAAA4kB,gBAAkB,EAMlB5kB,KAAA6kB,cAAgB,EAxB5B,OAAAzoB,OAAA2K,EAAA,KAAA3K,CAAAsoB,EAAA,EAAA7lB,IAAA,aAAAN,MAAA,gBAgCkCwG,IAAtB/E,KAAK8kB,cACL9kB,KAAK8kB,aAAajB,MAAM/P,UAjCpC,CAAAjV,IAAA,cAAAN,MAAA,gBAsCkCwG,IAAtB/E,KAAK8kB,cACL9kB,KAAK8kB,aAAajB,MAAMja,SAvCpC,CAAA/K,IAAA,YAAAN,MAAA,SA2CqBwmB,QACahgB,IAAtB/E,KAAK8kB,cACL9kB,KAAK8kB,aAAajB,MAAMviB,KAAKyjB,KA7CzC,CAAAlmB,IAAA,oBAAAN,MAAA,SAiD6BwmB,GACrB,QAA0BhgB,IAAtB/E,KAAK8kB,aAA4B,CACjC,IAAME,EAAqBhlB,KAAK8kB,aAAajB,MAAMoB,iBACnDjlB,KAAK8kB,aAAajB,MAAMviB,KAAK0jB,EAAqBD,MApD9D,CAAAlmB,IAAA,sBAAAN,MAAA,WAyDQ,YAA0BwG,IAAtB/E,KAAK8kB,aACE9kB,KAAK8kB,aAAajB,MAAMoB,iBAE5B,IA5Df,CAAApmB,IAAA,iBAAAN,MAAA,WAgEQ,YAA0BwG,IAAtB/E,KAAK8kB,aACE9kB,KAAK8kB,aAAahB,OAEtB,IAAI3F,KAnEnB,CAAAtf,IAAA,aAAAN,MAAA,SAsEsB2mB,GAAmB,IAAArd,EAAA7H,KAIjC,QAAqB+E,IAAjBmgB,EAAOrB,OAAgD,WAAzBqB,EAAOrB,MAAMsB,QAC3C,MAAM,IAAI5iB,MAAM,4CAEpB,QAAsBwC,IAAlBmgB,EAAOpB,OAAwB,MAAM,IAAIvhB,MAAM,kCACnD,IAAM6iB,EAAW,IAAIzB,GAAauB,EAAOrB,MAAOqB,EAAOpB,QAQvDsB,EAASrB,UAAYmB,EAAOnB,UAC5BqB,EAASvB,MAAMviB,KAAK4jB,EAAOf,cAKvBe,EAAOX,WACPa,EAASvB,MAAMwB,WAAWpc,MAAK,GAGnCmc,EAASvB,MAAMja,OACVsb,EAAOX,WAERa,EAASvB,MAAMwB,WAAWvkB,GAAG,MAAO,WAEhC+G,EAAKyd,iBAAgB,KAG7BtlB,KAAK8kB,aAAeM,IAxG5B,CAAAvmB,IAAA,kBAAAN,MAAA,SA2G2BuC,GACnBd,KAAK2kB,cAAgB7jB,IA5G7B,CAAAjC,IAAA,sBAAAN,MAAA,WA8GmC,OAAOyB,KAAK2kB,gBA9G/C,CAAA9lB,IAAA,SAAAN,MAAA,SAiHkB0I,GACV,GAAKjH,KAAK2kB,cAAV,CAEA,IAAMY,EAAe,EAWrB,QAR0BxgB,IAAtBygB,GAAUC,SACVD,GAAUE,mBAAmBF,GAAUlZ,SAASgR,aAAerW,EACrDse,EAAcC,GAAUC,QAAQE,iBAMpB5gB,IAAtBygB,GAAUC,QAAuB,CACjC,IAAMpI,EAAWmI,GAAUlZ,SAAS+Q,SAChCuI,EAASvY,GAAYwY,wBAAwBxI,GACjDuI,EAASlc,KAAKkS,IAAI,EAAGgK,GAIrB,IAFA,IAAME,EAAUpc,KAAKyC,MAAMyZ,EAAS1Z,IAE3BgB,EAAOlN,KAAK4kB,gBAAkB,EAAG1X,GAAQ4Y,EAAS5Y,KAM3DlN,KAAK4kB,gBAAkBkB,EAG3B9lB,KAAK+lB,kCAAkC9e,MA/I/C,CAAApI,IAAA,oCAAAN,MAAA,SAkJ6C0I,GAAkD,IAA/B+e,EAA+Bjd,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,IAAAA,UAAA,GAUvF,QAA0BhE,IAAtBygB,GAAUC,cAA+C1gB,IAAtB/E,KAAK8kB,eAEvC9kB,KAAK8kB,aAAajB,MAAMwB,WAAWY,WAAcD,GAAtD,CAIA,IAAME,EAAyBlmB,KAAK8kB,aAAajB,MAAMoB,iBACjDkB,EAAQzc,KAAKqG,IAAImW,EAAyBV,GAAUlZ,SAASgR,cAC/D6I,EAAQ1C,IAERzjB,KAAK6kB,eAAiBsB,EAGlBnmB,KAAK6kB,cAAgBnB,KACrB1jB,KAAK6kB,cAAgB,EAErBW,GAAUE,mBAAmBQ,EAAwBlmB,KAAK8kB,aAAahB,QACvEnY,QAAQya,IAAI,4BAIhBpmB,KAAK6kB,cAAgB,MAjLjC,EAAAhmB,IAAA,cAAAN,MAAA,WAMQ,OAHKmmB,EAAiBle,WAClBke,EAAiBle,SAAW,IAAIke,GAE7BA,EAAiBle,aANhCke,EAAA,GAyLM2B,GAAW5B,GAAiB/d,cACnB4f,GAAA,GCpOT,SAAUC,GAAaC,GACpBA,IAGD7a,QAAQC,MAAM,wBACdD,QAAQ8a,SAIV,SAAUC,GAAOF,EAAeG,GAClC,IAAKH,EACD,MAAM,IAAIjkB,MAAMokB,GAQjB,IAAMC,GAAb,oBAAAC,IAAAzqB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA6mB,GAAA,OAAAzqB,OAAA2K,EAAA,KAAA3K,CAAAyqB,EAAA,OAAAhoB,IAAA,QAAAN,MAAA,WAEQinB,GAAU1R,QACVwS,GAASQ,eAHjB,CAAAjoB,IAAA,OAAAN,MAAA,WAQQinB,GAAU5b,OACV0c,GAASS,gBATjB,CAAAloB,IAAA,gBAAAN,MAAA,WAW6C,IAAbyoB,EAAaje,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAD,EAC9Bke,EAAqBD,GAAa,EAAI/G,IAC5CqG,GAASY,kBAAkBD,GAC3BzB,GAAUE,mBAAmBY,GAASa,sBAAuBb,GAASc,sBAd9EP,EAAA,GChBaQ,GAAb,oBAAAC,IAAAlrB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAsnB,GACWtnB,KAAAsd,aAAe,EACftd,KAAAqd,SAAW,EACXrd,KAAAunB,iBAAmB,EACnBvnB,KAAAwnB,OAAS,EAETxnB,KAAAynB,QAAS,EAETznB,KAAAmV,OAAQ,EAERnV,KAAA0nB,aAAe,EAEf1nB,KAAAsV,gBAAkB,EAClBtV,KAAA2nB,eAAiB,IAAIrJ,GACrBte,KAAA4nB,qBAAuB,EACvB5nB,KAAA6nB,iBAAmB,EAf9B,OAAAzrB,OAAA2K,EAAA,KAAA3K,CAAAkrB,EAAA,EAAAzoB,IAAA,QAAAN,MAAA,WAkBQyB,KAAK4nB,oBAAsB,EAC3B5nB,KAAK6nB,gBAAkB,EAEvB7nB,KAAKsd,aAAe,EAEpBtd,KAAKqd,SAAW,EAChBrd,KAAKunB,iBAAmB,EACxBvnB,KAAKwnB,OAAS,EACdxnB,KAAKynB,QAAS,EACdznB,KAAKmV,OAAQ,EACbnV,KAAK0nB,cAAgB,EACrB1nB,KAAKsV,iBAAmB,IA7BhC,CAAAzW,IAAA,qBAAAN,MAAA,SAgC8BupB,EAAyBhE,EAAoBiE,GAC9DA,EAAUC,SAGXhoB,KAAK2nB,eAAejJ,QAFpB1e,KAAK2nB,eAAiBI,EAK1B,IAAME,EAAW,IAAI1T,GACrB0T,EAASxT,YAAcqT,EACvBhE,EAAOhH,6BAA6BmL,GACpCjoB,KAAKqd,SAAW4K,EAAS/a,KACzBlN,KAAKwnB,OAASS,EAASvT,OACvB1U,KAAKynB,OAASQ,EAASpT,UACvB7U,KAAKmV,MAAQ8S,EAASnT,SACtB9U,KAAK0nB,aAAeO,EAASrT,aAC7B5U,KAAKsV,gBAAkB2S,EAAStT,YAEhC+R,GAAO1mB,KAAKqd,UAAY,IAAlB,aAAA7a,OAAqCxC,KAAKqd,SAA1C,QAAA7a,OAAyDslB,EAAzD,wBAEN9nB,KAAKsd,aAAewK,EAEpB9nB,KAAKunB,iBAAmBzD,EAAOoE,+BAA+BloB,KAAK4nB,qBAGnE5nB,KAAK4nB,oBAAsB5nB,KAAKsd,aAChCtd,KAAK6nB,gBAAkB7nB,KAAKqd,aAzDpCiK,EAAA,GA4Dea,GAAA,GCjEFC,GAAb,oBAAAC,IAAAjsB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAqoB,GACWroB,KAAAsoB,aAAe3lB,EAAa4lB,SAE5BvoB,KAAAsM,SAAW,IAAI6b,GAEfnoB,KAAAwoB,QAAU,EALrB,OAAApsB,OAAA2K,EAAA,KAAA3K,CAAAisB,EAAA,EAAAxpB,IAAA,SAAAN,MAAA,SAUkBkqB,MAVlB,CAAA5pB,IAAA,uBAAAN,MAAA,WAeQ,OAAIinB,GAAUkD,kBAA4B1oB,KAAKsM,SACxCkZ,GAAUlZ,WAhBzB,CAAAzN,IAAA,qBAAAN,MAAA,WAoBQ,IAAMoqB,EAAQnD,GAAUoD,SAAS5oB,KAAKsoB,cAEtC,OAAOK,EAAME,eAtBrBR,EAAA,gBCHaS,GAAb,SAAAC,GACI,SAAAC,IAAA,OAAA5sB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAgpB,GAAA5sB,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA4sB,GAAAzsB,KAAAyD,KACU,wBAFd,OAAA5D,OAAAmU,EAAA,KAAAnU,CAAA4sB,EAAAD,GAAAC,EAAA,CAAA5sB,OAAA6sB,GAAA,KAAA7sB,CAAyCmG,QCW5B2mB,GAAb,WAuDI,SAAAC,IAAA/sB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAmpB,GA1BOnpB,KAAAsM,SAAyB,IAAI6b,GAkB7BnoB,KAAA0oB,mBAAoB,EAInB1oB,KAAAopB,kBAAoB,IAAI9K,GACxBte,KAAAqpB,oBAAsB,EACtBrpB,KAAAspB,QAAS,EAGbtpB,KAAK4oB,SAAW,GAChB5oB,KAAKupB,cAAgB,EAErBvpB,KAAKwpB,YAAc,GAJvB,IAAA3N,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAKI,QAAAiX,EAAAC,EAAAC,IAAiBgH,GAAQuG,YAAY9mB,MAArCkZ,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAAoD,KAAzC9Q,EAAyCiR,EAAAzd,MAChDyB,KAAKwpB,YAAYze,GAAM,IAAIqd,IANnC,MAAAhM,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,GASI/b,KAAK0pB,UAAY,EAEjB1pB,KAAK2pB,QAlEb,OAAAvtB,OAAA2K,EAAA,KAAA3K,CAAA+sB,EAAA,EAAAtqB,IAAA,QAAAN,MAAA,WAuEQyB,KAAKspB,QAAS,IAvEtB,CAAAzqB,IAAA,eAAAN,MAAA,SA2EwBqrB,GAChB5pB,KAAK8T,QACLwS,GAASQ,aACT9mB,KAAK6pB,4BACW9kB,IAAZ6kB,GAIJ5pB,KAAK8pB,WAAWF,KAnFxB,CAAA/qB,IAAA,aAAAN,MAAA,SA0FsBqrB,QACO7kB,IAAjB/E,KAAKylB,SAELzlB,KAAKylB,QAAQE,WAAWjO,gBAE5B/L,QAAQya,IAAI,iBACZpmB,KAAKylB,QAAUmE,OAEM7kB,IAAjB/E,KAAKylB,SAELzlB,KAAKylB,QAAQE,WAAWoE,kBApGpC,CAAAlrB,IAAA,OAAAN,MAAA,WAwGoB+nB,GAAShB,iBAAgB,KAxG7C,CAAAzmB,IAAA,QAAAN,MAAA,WA0GqB+nB,GAAShB,iBAAgB,KA1G9C,CAAAzmB,IAAA,WAAAN,MAAA,WA2GwB,OAAQ+nB,GAAS0D,wBA3GzC,CAAAnrB,IAAA,SAAAN,MAAA,SAgHkBkqB,GAGVzoB,KAAKwpB,YAAY,GAAGriB,OAAOshB,KAnHnC,CAAA5pB,IAAA,uBAAAN,MAAA,WAuHQyB,KAAKsM,SAASqd,QACd3pB,KAAKopB,kBAAkB1K,QACvB1e,KAAKqpB,oBAAsB,EAE3BrpB,KAAKiqB,WAAW,EAAG,EAAG,EAAG,GAGzBjqB,KAAKwpB,YAAY,GAAGld,SAASqd,UA9HrC,CAAA9qB,IAAA,iBAAAN,MAAA,SAiI0B2O,GAClB,MAAM,IAAI4b,KAlIlB,CAAAjqB,IAAA,aAAAN,MAAA,SAqIsBsgB,EAAc3R,EAAcgd,EAAsBC,GAChEhB,EAAUiB,eAAiBvL,EAC3BsK,EAAUkB,eAAiBnd,EAK3Bic,EAAUmB,uBAAyBJ,EACnCf,EAAUoB,uBAAyBJ,IA7I3C,CAAAtrB,IAAA,mBAAAN,MAAA,SAgJ4BwM,EAAkBmC,EAAcid,GACpDhB,EAAUqB,qBAAqBzf,GAAMmC,EACrCic,EAAUsB,6BAA6B1f,GAAMof,IAlJrD,CAAAtrB,IAAA,qBAAAN,MAAA,SAqJ8BupB,EAAyBhE,GAAqD,IAAjCiE,EAAiChf,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,GAAViX,GAKtF8H,IAAoB9nB,KAAKqpB,qBAAwBrpB,KAAKspB,QAGtDtpB,KAAKopB,kBAAkB1K,QACvB1e,KAAKqpB,oBAAsBvB,GAH3BA,GAAmB9nB,KAAKopB,kBAAkBnK,MAQ9Cjf,KAAKsM,SAASoZ,mBAAmBoC,EAAiBhE,EAAQiE,GAI1D,IAAMhd,EAAK,EACP/K,KAAK4oB,SAAS3sB,SACd+D,KAAKwpB,YAAYze,GAAIuB,SAASoZ,mBAAmBoC,EAC7C9nB,KAAK4oB,SAAS7d,GAAI8d,WAAYd,GAClC/nB,KAAK0qB,iBAAiB3f,EAAI/K,KAAKwpB,YAAYze,GAAIuB,SAASub,gBACpD7nB,KAAKwpB,YAAYze,GAAIuB,SAASib,mBAEtCvnB,KAAKiqB,WAAWU,GAAUre,SAASsb,oBAC/B5nB,KAAKsM,SAASub,gBACdC,EACA9nB,KAAKsM,SAASib,oBAjL1B,CAAA1oB,IAAA,WAAAN,MAAA,SA0LoBqsB,EAAgBC,EAAiBvpB,GAG7CtB,KAAK8qB,aAAaF,GAElB,IAAM1F,EAAS,IAAIjB,GACnBiB,EAAOrB,MAAQgH,EACf3F,EAAOnB,WAAY,EACnBmB,EAAOpB,OAAS8G,EAASjF,gBACX5gB,IAAVzD,IACA4jB,EAAOf,aAAe7iB,GAE1BqpB,GAAU/gB,OAEV0c,GAASyE,WAAW7F,MAxM5B,EAAArmB,IAAA,cAAAN,MAAA,WAmBQ,OAHK4qB,EAAU3iB,WACX2iB,EAAU3iB,SAAW,IAAI2iB,GAEtBA,EAAU3iB,aAnBzB2iB,EAAA,GAEkBD,GAAAkB,eAAiB,EACjBlB,GAAAmB,eAAiB,EAEjBnB,GAAAoB,uBAAyB,EACzBpB,GAAAqB,uBAAyB,EAEzBrB,GAAAsB,qBAAiC,GACjCtB,GAAAuB,6BAAyC,GAkM3D,IAAME,GAAYzB,GAAUxiB,cACb8e,GAAA,GCxMTwF,GAAgB,EAGhBC,iHAkCEC,EAAkBC,EAClBC,GAGA,QAA0BrmB,IAAtBygB,GAAUC,QAAyB,OAAO,EAE9C0F,EAAe5sB,MAAQ+Y,OAAOC,UAC9B6T,EAAc7sB,OAAQ,EAEtB,IAAI8sB,EAAU,EACR/e,EAAWkZ,GAAUlZ,SAErB+Q,EAAW/Q,EAASub,gBAGpBgB,GAFWrD,GAAUC,QAAQ6F,SAAS9F,GAAU+D,eAEnC/D,GAAUC,QAAQE,YAYrC,GARyB,IAArB3lB,KAAKurB,cAGLF,EAAUG,EAAaC,iBAAiBP,GAAYM,EAAaC,iBAAiBpO,GAClFgO,GAAWxC,EAAW6C,yBAAyBpf,EAASub,gBAAiBvb,EAASsb,qBAClFyD,GAAW,EAAIrrB,KAAKurB,aAGC,IAArBvrB,KAAKurB,YAAmB,CAExB,IAAMI,EAAcnG,GAAUlZ,SAASsb,oBACjCgE,EAAc/C,EAAWgD,uBAAuBX,GAGhDY,EAAmBF,EAAcD,EACjCzY,EAAMlT,KAAK+rB,UACX5Y,EAAOD,EAAM,GACb8Y,EAAqBF,EAAmB3Y,EAC9CkY,GAAWW,EAAqBhsB,KAAKurB,YAEzCF,GAAWL,GAGX,IAAIiB,EAAcjsB,KAAKisB,YAKvB,OAJ0B,IAAtBjsB,KAAKksB,eACLD,EAAcjsB,KAAKksB,cAA+B,EAAflsB,KAAKmsB,UAGxCd,EAAU,EACHA,EAAUY,GAErBZ,GAAWY,EACXd,EAAe5sB,OAAS0tB,EACjBZ,4CAIoBne,GAE3B,IAAMzR,EAAO+vB,EAAaY,mBACpBxQ,EAAMngB,EAAKQ,OAAS,EACtByB,EAAI,EACJU,EAAIwd,EACR,MAAOle,GAAKU,EAAG,CACX,IAAMT,EAAI+L,KAAKyC,OAAOzO,EAAIU,GAAK,GAC/B,IAAW,IAANT,GAAWlC,EAAKkC,GAAGuP,MAAQA,KAAUvP,IAAMie,GAAO1O,EAAOzR,EAAKkC,EAAI,GAAGuP,MACtE,OAAOzR,EAAKkC,GAAG0uB,cAAgB5wB,EAAKkC,GAAG2uB,UAAYpf,EAAOzR,EAAKkC,GAAGuP,MAC3DzR,EAAKkC,GAAGuP,MAAQA,EACvBxP,EAAIC,EAAI,EAERS,EAAIT,EAAI,EAGhB,OAAOuP,WAlGG+d,GAAAmB,mBAA2C,GAI3CnB,GAAAsB,cAAiC,GAMjCtB,GAAAM,YAAc,EACdN,GAAAiB,aAAe,EAEfjB,GAAAgB,YAAc,IACdhB,GAAAuB,iBAAmB,EAEnBvB,GAAAc,UAAY,IACZd,GAAAwB,eAAiB,EAIjBxB,GAAAkB,QAAU,IAgFb,IAAAO,GAAA,GCvHTC,eAUF,SAAAC,EAAY1qB,EAA6BgpB,GAAgB,IAAArjB,EAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA4sB,GACrDjkB,GAAWW,oBACX,IAAIujB,EAAWxf,GAAYyf,eAAe5B,GACtC2B,IAAariB,GAASwC,UAEtB6f,EAAWriB,GAASuC,QAExBlF,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAwwB,GAAArwB,KAAAyD,KAAM2G,GAAY4C,cAAc1G,GAA2BgqB,IAE3DhlB,EAAK3F,UAAYA,EACjB2F,EAAKglB,SAAWA,EAChBhlB,EAAKqjB,SAAWA,EAGhBrjB,EAAKlC,OAAO8D,SAAY,GAAK5B,EAAK3F,WAAcwH,KAAKC,GAAK,KAG1D,IAAMjH,EAAYT,EAAqB4F,EAAK3F,WAjBS,OAkBrD2F,EAAKlC,OAAOwC,EAAIvF,EAAed,EAAmBY,EAClDmF,EAAKklB,qBAGLllB,EAAKlC,OAAOiE,OAtByC/B,oFAyBjC,OAAO7H,KAAKkC,gDACb,OAAOlC,KAAK6sB,2CAChB,OAAO7sB,KAAKkrB,wCAEjBjkB,GAOV,OADAjH,KAAK+sB,qBACE/sB,kDAIP,IAAMgtB,EAAc,CAACzuB,MAAO,GACtB6sB,EAAgB,CAAC7sB,OAAO,GAG9ByB,KAAK2F,OAAOyC,EAAIskB,GAAaO,WAAWjtB,KAAKkrB,SAAU8B,EAAa5B,GAAiBjiB,UAtDjED,IAyDbgkB,GAAA,GC1DTC,eASF,SAAAC,EAAYlrB,EAA6BgpB,GAAgB,IAAArjB,EAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAotB,GACrDzkB,GAAWW,oBACXzB,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAgxB,GAAA7wB,KAAAyD,KAAM2G,GAAY4C,cAAcxG,GAAsB,IAEtD8E,EAAK3F,UAAYA,EACjB2F,EAAKqjB,SAAWA,EAGhB,IAAMxoB,EAAYT,EAAqB4F,EAAK3F,WARS,OASrD2F,EAAKlC,OAAOwC,EAAIvF,EAAed,EAAmBY,EAClDmF,EAAKklB,qBAGLllB,EAAKlC,OAAOiE,OAbyC/B,oFAgBjC,OAAO7H,KAAKkC,4CACjB,OAAOlC,KAAKkrB,wCAEjBjkB,GAOV,OADAjH,KAAK+sB,qBACE/sB,kDASP,IAAMgtB,EAAc,CAACzuB,MAAO,GACtB6sB,EAAgB,CAAC7sB,OAAO,GAG9ByB,KAAK2F,OAAOyC,EAAIskB,GAAaO,WAAWjtB,KAAKkrB,SAAU8B,EAAa5B,GAAiBjiB,UAhDjED,IAmDbmkB,GAAA,GC/CTC,eAyBF,SAAAC,EAAmBrrB,EAA6BgpB,EAAkB9f,EAC/CoiB,EAAgCC,GAA6B,IAAA5lB,EAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAutB,GAC5E1lB,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAmxB,GAAAhxB,KAAAyD,OACA6H,EAAK3F,UAAYA,EACjB2F,EAAKqjB,SAAWA,EAChBrjB,EAAKuD,SAAWA,EAChBvD,EAAKG,SAAU,EAIfH,EAAKlE,OAASkE,EAAK6lB,0BAMnB,IAAIC,EAA4B,EAC5BC,EAA4B,EAKhC,GAJAD,EAA4BH,EAAe7pB,OAAUkE,EAAKlE,OAAS6pB,EAAe7pB,OAClFiqB,EAA4BJ,EAAe7pB,OAASgqB,EAGhD9lB,EAAKlE,OAAS6pB,EAAe7pB,OAAQ,CACrCkE,EAAKgmB,iBAAmB,GAExB,IAAIC,EAAkBjmB,EAAKlE,OAASiqB,EACpC,MAAOE,EAAkB,EAAG,CACxB,IAAMC,EAAgBrkB,KAAKiS,IAAImS,EAAiBN,EAAe7pB,QAC3DqqB,OAA4B,EAE5BA,EADAD,IAAkBP,EAAe7pB,OAChB6pB,EAAejnB,SAAS,GAAG,GAG3B,IAAIJ,EAAA,KACjBqnB,EAAejnB,SAAS,GAAG,GAAGF,YAC9B,IAAIF,EAAA,KAAe,EAAG,EAAGqnB,EAAe9pB,MAAOqqB,IAGvD,IAAME,EAAoB,IAAI9nB,EAAA,KAAY6nB,GAC1CnmB,EAAKgmB,iBAAiB1xB,KAAK,IAAIwM,GAAWslB,IAE1CH,GAAmBC,GAK3B,IAAMG,EAAgB,IAAI/nB,EAAA,KACtBqnB,EAAejnB,SAAS,GAAG,GAAGF,YAC9B,IAAIF,EAAA,KACA,EAAGwnB,EACHH,EAAe9pB,MAAOkqB,IAExBO,EAAa,IAAIhoB,EAAA,KAAY+nB,GACnCrmB,EAAKsmB,WAAa,IAAIxlB,GAAWwlB,GAEjC,IAAMC,EAAkB,IAAIjoB,EAAA,KAAYsnB,EAAclnB,SAAS,GAAG,IAClEsB,EAAKumB,gBAAkB,IAAIzlB,GAAWylB,GAMtC,IAAM1rB,EAAYT,EAAqB4F,EAAK3F,WACtCmsB,EAAQzrB,EAAed,EAAmBY,EA9D4B,OA+D5EyrB,EAAWhmB,EAAIkmB,OACetpB,IAA1B8C,EAAKgmB,kBACLhmB,EAAKgmB,iBAAiB3mB,QAAQ,SAAConB,GAAD,OAAQA,EAAGC,YAAYpmB,EAAIkmB,IAE7DD,EAAgBjmB,EAAIkmB,EAIpBF,EAAWjmB,OAAOE,EAAI,OACQrD,IAA1B8C,EAAKgmB,kBACLhmB,EAAKgmB,iBAAiB3mB,QAAQ,SAAConB,GAAD,OAAQA,EAAGC,YAAYrmB,OAAOE,EAAI,IAEpEgmB,EAAgBlmB,OAAOE,EAAI,EAE3BP,EAAK2mB,gBA7EuE3mB,+EAiF5E7H,KAAKsI,kBACLlM,OAAA+B,GAAA,KAAA/B,QAAA2L,EAAA,KAAA3L,CAAAmxB,EAAAlxB,WAAA,UAAA2D,MAAAzD,KAAAyD,0CAGiB,OAAOA,KAAKgI,6CAE7B,OAAIhI,KAAKgI,QAAkBhI,MAE3BA,KAAKgI,SAAU,EAGfhI,KAAKouB,gBAAgBK,kBACS1pB,IAA1B/E,KAAK6tB,kBACL7tB,KAAK6tB,iBAAiB3mB,QAAQ,SAAConB,GAAD,OAAQA,EAAGG,eAE7CzuB,KAAKmuB,WAAWM,aACTzuB,gDAGP,OAAKA,KAAKgI,SAEVhI,KAAKgI,SAAU,EACfhI,KAAKouB,gBAAgB9lB,uBACSvD,IAA1B/E,KAAK6tB,kBACL7tB,KAAK6tB,iBAAiB3mB,QAAQ,SAAConB,GAAD,OAAQA,EAAGhmB,oBAE7CtI,KAAKmuB,WAAW7lB,kBACTtI,MARqBA,oCAWlBiH,GAEV,OADAjH,KAAKwuB,gBACExuB,uDAIP,IAAMgtB,EAAc,CAACzuB,MAAO,GACtB6sB,EAAgB,CAAC7sB,OAAO,GAGxBmwB,EAAWhC,GAAaO,WAC1BjtB,KAAKkrB,SAAU8B,EAAa5B,GAAiBjiB,GAC3CwlB,EAAUjC,GAAaO,WACzBjtB,KAAKkrB,SAAWlrB,KAAKoL,SACrB4hB,EAAa5B,GAAiBjiB,GAGlC,OAAOwlB,EAAUD,EAAY1sB,EAA4B,0CAIzD,IAAMgrB,EAAc,CAACzuB,MAAO,GACtB6sB,EAAgB,CAAC7sB,OAAO,GAGxBmwB,EAAWhC,GAAaO,WAC1BjtB,KAAKkrB,SAAU8B,EAAa5B,GAAiBjiB,GAG3CglB,EAAanuB,KAAKmuB,WAAWI,YAInC,GAHAJ,EAAW/lB,EAAIsmB,OAGe3pB,IAA1B/E,KAAK6tB,iBAAgC,CACrC,IAAIe,EAAaF,EAAWP,EAAWxqB,OACvC3D,KAAK6tB,iBAAiB3mB,QAAQ,SAAConB,GAC3BA,EAAGC,YAAYnmB,EAAIwmB,EACnBA,GAAcN,EAAGC,YAAY5qB,SAIrC3D,KAAKouB,gBAAgBS,QAAQH,EAAW1uB,KAAK2D,eAlLxB+D,IAqLdonB,GAAA,GC5LTC,eAMF,SAAAC,EAAmB9sB,EAA6BgpB,EAAkB9f,GAAgBhP,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAgvB,GAC9E,IAAMxB,EAAiB7mB,GAAY4C,cAActG,GAC3CwqB,EAAgB9mB,GAAY4C,cAAcpG,GAF8B,OAAA/G,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA4yB,GAAAzyB,KAAAyD,KAGxEkC,EAAWgpB,EAAU9f,EAAUoiB,EAAgBC,kCAThCqB,IAYdG,GAAA,GCPTC,eAMF,SAAAC,EAAmBjtB,EAA6BgpB,EAAkB9f,GAAgBhP,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAmvB,GAmB9E,IAAM3B,EAAiB7mB,GAAY4C,cAAcnG,IAC3CqqB,EAAgB9mB,GAAY4C,cAAclG,IApB8B,OAAAjH,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAA+yB,GAAA5yB,KAAAyD,KAqBxEkC,EAAWgpB,EAAU9f,EAAUoiB,EAAgBC,kCA3BhCqB,IA8BdM,GAAA,GC3BTC,GAMF,SAAAC,IAAAlzB,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAsvB,GACItvB,KAAKuvB,SAAW,IAAI3qB,EAAAnB,EACpBzD,KAAKwvB,SAAW,IAAI5qB,EAAAnB,GAOtBgsB,eAMF,SAAAC,IAAA,IAAA7nB,EAAA,OAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA0vB,GACI7nB,EAAAzL,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAszB,GAAAnzB,KAAAyD,OACA6H,EAAK8nB,WAAa,GAClB9nB,EAAK+nB,YAAY,GAHrB/nB,iFAMmByY,GAAiB,IAAAzE,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAEhC,QAAAiX,EAAAC,EAAAC,IAAoBlc,KAAK2vB,cAAzB9T,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAAqC,KAA1BgU,EAA0B7T,EAAAzd,MAAAie,GAAA,EAAAC,GAAA,EAAAC,OAAA3X,EAAA,IACjC,QAAA4X,EAAAC,EAAAV,IAAiB2T,EAAMN,YAAvB/S,GAAAG,EAAAC,EAAArC,QAAA4B,MAAAK,GAAA,EAAiC,KAAtBsT,EAAsBnT,EAAApe,MAC7BuxB,EAAG,GAAGC,WAFuB,MAAA3T,GAAAK,GAAA,EAAAC,EAAAN,EAAA,YAAAI,GAAA,MAAAI,EAAAP,QAAAO,EAAAP,SAAA,WAAAI,EAAA,MAAAC,GAAA,IAAAsT,GAAA,EAAAC,GAAA,EAAAC,OAAAnrB,EAAA,IAIjC,QAAAorB,EAAAC,EAAAlU,IAAiB2T,EAAML,YAAvBQ,GAAAG,EAAAC,EAAA7V,QAAA4B,MAAA6T,GAAA,EAAiC,KAAtBK,EAAsBF,EAAA5xB,MAC7B8xB,EAAG,GAAGN,WALuB,MAAA3T,GAAA6T,GAAA,EAAAC,EAAA9T,EAAA,YAAA4T,GAAA,MAAAI,EAAA/T,QAAA+T,EAAA/T,SAAA,WAAA4T,EAAA,MAAAC,KAFL,MAAA9T,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,GAYhC/b,KAAK2vB,WAAa,GAClB,IAAK,IAAI5zB,EAAI,EAAGA,EAAIukB,EAAWvkB,IAC3BiE,KAAK2vB,WAAWxzB,KAAK,IAAIkzB,mDAIHiB,GAC1B,IAAMjT,EAAWmI,GAAUlZ,SAAS+Q,SAEhCkT,EAAM,EACNC,EAAOnT,EAGLoT,EAAiD,IAAtC/D,GAAaH,cAActwB,OACvCw0B,IACDF,EAAMC,EAAO,GASjB,IANA,IAAME,EAAiB,GACjBC,EAAkB,GAEpBC,EAAkBL,EAGbx0B,EAAI,EAAGA,EAAI20B,EAAgB30B,IAAK,CACrC,IAAM80B,GAAON,EAAMC,GAAQ,EAErBM,EAAoB,CAACvyB,OAAO,GAC5ByuB,EAAc,CAACzuB,MAAO,GACtB8sB,EAAUqB,GAAaO,WAAW4D,EAAK7D,EAAa8D,GAEtDzF,EAAUiF,GACTG,GAAYzwB,KAAK+wB,iBAAiBF,EAAKxT,GAAYsT,GAGpDC,EAAkBC,EAClBN,EAAMM,GAENL,EAAOK,EAGf,OAAOD,gDAGkBI,GAEzB,QAA0BjsB,IAAtBygB,GAAUC,QAAyB,OAAO,EAa9C,IAXA,IAAMwL,EAAoBzL,GAAUlZ,SAC9B4kB,EAAkB1L,GAAUC,QAAQE,WAGtCwL,EAAiB,GACjBC,EAAiBH,EAAkB5T,SAAW8T,EAC5CE,EAAkBH,EAAgBxF,yBACpCuF,EAAkBpJ,gBAAiBoJ,EAAkBrJ,qBAEnD8I,EAAiB,GAEd30B,EAAI,EAAGA,EAAI20B,EAAgB30B,IAAK,CACrC,IAAM+0B,EAAoB,CAACvyB,OAAO,GAC5ByuB,EAAc,CAACzuB,MAAO,GACtB8sB,EAAUqB,GAAaO,WAAWmE,EAAgBpE,EAAa8D,GAEjEzF,EAAU2F,EACVI,GAAkBD,EAElBC,GAAkBD,EAEtBA,GAAkB,EAMtB,OAHIE,EAAkB,MAClBD,EAAiB1nB,KAAKiS,IAAIyV,EAAgBH,EAAkB5T,SAAW,KAEpE+T,mDAGqBlkB,GAE5B,IAAMzR,EAAOixB,GAAaH,cACpB3Q,EAAMngB,EAAKQ,OAAS,EACtByB,EAAI,EACJU,EAAIwd,EACR,MAAOle,GAAKU,EAAG,CACX,IAAMT,EAAI+L,KAAKyC,OAAOzO,EAAIU,GAAK,GAC/B,IAAW,IAANT,GAAWlC,EAAKkC,GAAGuP,MAAQA,KAAUvP,IAAMie,GAAO1O,EAAOzR,EAAKkC,EAAI,GAAGuP,MACtE,OAAOzR,EAAKkC,GACLlC,EAAKkC,GAAGuP,MAAQA,EACvBxP,EAAIC,EAAI,EAERS,EAAIT,EAAI,EAGhB,MAAO,CAACuP,KAAM,EAAGokB,WAAY,EAAGC,WAAY,4CAGxBhB,EAAaC,GACjC,IAAMgB,EAAcxxB,KAAKyxB,yBAAyBlB,GAC5CmB,EAAe1xB,KAAKyxB,yBAAyBjB,GACnD,OAAOkB,EAAaH,WAAaC,EAAYF,+CAG9BrqB,GAEf,QAA0BlC,IAAtBygB,GAAUC,QAAyB,OAAOzlB,KAC7BwlB,GAAUlZ,SAASub,gBAgBpC,IAhBA,IAEM8J,EAA2B,IAC3Bf,EAAkB5wB,KAAK4xB,uBAAuBD,GAC9CP,EAAiBpxB,KAAK6xB,sBAAsBF,GAE5CG,EAAWzkB,GAAYD,cAAcwjB,GACrCxb,EAAU/H,GAAYD,cAAcgkB,GAQpCW,EAAKvM,GAAUC,QAAQ6F,SAAS9F,GAAU+D,eAAeyI,cACtDxzB,EAAI,EAAGA,EAAIuzB,EAAGxC,SAAStzB,OAAQuC,IAAK,KAAAyzB,GAAA,EAAAC,GAAA,EAAAC,OAAAptB,EAAA,IACzC,QAAAqtB,EAAAC,EAAAnW,IAAsB6V,EAAGxC,SAAS/wB,MAAlCyzB,GAAAG,EAAAC,EAAA9X,QAAA4B,MAAA8V,GAAA,EAAsC,KAA3BK,EAA2BF,EAAA7zB,MAElC,KAAI+zB,EAAQ,GAAKR,GAAjB,CACA,GAAIQ,EAAQ,GAAKld,EAAW,MAC5B,IAAIkd,EAAQ,GAAGpxB,OAAS6I,GAAYyE,KAChC8jB,EAAQ,GAAGpxB,OAAS6I,GAAY2E,UAChC4jB,EAAQ,GAAGpxB,OAAS6I,GAAY6E,QAGhC5O,KAAK2vB,WAAWnxB,GAAG+wB,SAASgD,IAAID,EAAQ,IAA5C,CAEA,IAAMplB,EAAOG,GAAYoC,cAAc6iB,EAAQ,IACzCpwB,EAAYO,EAAqBjE,GACnCg0B,OAAoB,EACxB,OAAQF,EAAQ,GAAGpxB,MACf,KAAK6I,GAAYyE,IACbgkB,EAAW,IAAItF,GACXhrB,EACAgL,GAEJ,MAEJ,KAAKnD,GAAY2E,SACb8jB,EAAW,IAAItF,GACXhrB,EACAgL,GAEJ,IAAIulB,OAAuD,EAEvDA,EADAH,EAAQ,GAAG1nB,UAAYZ,GAAemB,KACzB,IAAI8jB,GACb/sB,EACAgL,EACAG,GAAYoC,cAAc6iB,EAAQ,GAAGlnB,WAG5B,IAAIgkB,GACbltB,EACAgL,EACAG,GAAYoC,cAAc6iB,EAAQ,GAAGlnB,WAG7CpL,KAAK2vB,WAAWnxB,GAAGgxB,SAASlpB,IAAIgsB,EAAQ,GAAIG,EAAWhE,cACvD,MAEJ,KAAK1kB,GAAY6E,KACb4jB,EAAW,IAAInF,GACXnrB,EACAgL,GAEJ,MACJ,QACI,MAAM,IAAI3K,MAAJ,0CAAAC,OAAoD8vB,EAAQ,GAAGpxB,OAE7ElB,KAAK2vB,WAAWnxB,GAAG+wB,SAASjpB,IAAIgsB,EAAQ,GAAIE,EAASE,WAAWJ,EAAQ,IAAI7D,iBAtDvC,MAAArS,GAAA8V,GAAA,EAAAC,EAAA/V,EAAA,YAAA6V,GAAA,MAAAI,EAAAhW,QAAAgW,EAAAhW,SAAA,WAAA6V,EAAA,MAAAC,IA6D7C,IAAMQ,EAAkF,GAhFxDC,GAAA,EAAAC,GAAA,EAAAC,OAAA/tB,EAAA,IAiFhC,QAAAguB,EAAAC,EAAA9W,IAAoBlc,KAAK2vB,cAAzBiD,GAAAG,EAAAC,EAAAzY,QAAA4B,MAAAyW,GAAA,EAAqC,KAA1B/C,EAA0BkD,EAAAx0B,MAAA00B,GAAA,EAAAC,GAAA,EAAAC,OAAApuB,EAAA,IACjC,QAAAquB,EAAAC,EAAAnX,IAAuB2T,EAAMN,YAA7B0D,GAAAG,EAAAC,EAAA9Y,QAAA4B,MAAA8W,GAAA,EAAuC,KAA5BK,EAA4BF,EAAA70B,OAC/B+0B,EAAS,GAAKxB,GAAYwB,EAAS,GAAKle,IAIxCud,EAAUx2B,KAAK,CAACm3B,EAAS,GAAIA,EAAS,GAAIzD,EAAMN,YANvB,MAAAnT,GAAA8W,GAAA,EAAAC,EAAA/W,EAAA,YAAA6W,GAAA,MAAAI,EAAAhX,QAAAgX,EAAAhX,SAAA,WAAA6W,EAAA,MAAAC,GAAA,IAAAI,GAAA,EAAAC,GAAA,EAAAC,OAAA1uB,EAAA,IASjC,QAAA2uB,EAAAC,EAAAzX,IAAuB2T,EAAML,YAA7B+D,GAAAG,EAAAC,EAAApZ,QAAA4B,MAAAoX,GAAA,EAAuC,KAA5BK,EAA4BF,EAAAn1B,MAE/Bq1B,EAAS,GAAKxe,GACdud,EAAUx2B,KAAK,CAACy3B,EAAS,GAAIA,EAAS,GAAI/D,EAAML,YAZvB,MAAApT,GAAAoX,GAAA,EAAAC,EAAArX,EAAA,YAAAmX,GAAA,MAAAI,EAAAtX,QAAAsX,EAAAtX,SAAA,WAAAmX,EAAA,MAAAC,KAjFL,MAAArX,GAAAyW,GAAA,EAAAC,EAAA1W,EAAA,YAAAwW,GAAA,MAAAI,EAAA3W,QAAA2W,EAAA3W,SAAA,WAAAwW,EAAA,MAAAC,GAiGhCH,EAAUzrB,QAAQ,SAAC2sB,GACfA,EAAiB,GAAGC,OAAOD,EAAiB,IAC5CA,EAAiB,GAAG9D,2CAId9oB,GAEV,OADAjH,KAAK+zB,YAAY9sB,GACVjH,YAxOS0H,IA2OTssB,GAAA,GCvPFC,GAAb,WAsBI,SAAAC,IAAA93B,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAk0B,GARQl0B,KAAAm0B,QAAmC,KAEnCn0B,KAAAo0B,kBAAmB,EACnBp0B,KAAAq0B,gBAA2C,GAjBvD,OAAAj4B,OAAA2K,EAAA,KAAA3K,CAAA83B,EAAA,EAAAr1B,IAAA,WAAAN,MAAA,SAwBoB+1B,GACZ3oB,QAAQya,IAAI,YAEZpmB,KAAKm0B,QAAU,IAAIhuB,EAAA,KAAiB,CAChCzC,MAAO4wB,EAAQ5wB,MACfC,OAAQ2wB,EAAQ3wB,OAChB4wB,KAAMD,EAAQE,aACdC,gBAAiB,EACjBC,aAAa,IAEb10B,KAAKm0B,QAAQQ,oBAAoBxuB,EAAA,MACjCwF,QAAQya,IAAI,cAMhBzf,GAAYiuB,cAEZ50B,KAAKm0B,QAAQU,OAAOC,OAASZ,EAAca,aAC3C/0B,KAAKm0B,QAAQU,OAAOzoB,UA5C5B,CAAAvN,IAAA,SAAAN,MAAA,WA+CsB,OAAwB,OAAjByB,KAAKm0B,UA/ClC,CAAAt1B,IAAA,gBAAAN,MAAA,WAgD6B,OAAOyB,KAAKg1B,UAAYruB,GAAY0B,kBAhDjE,CAAAxJ,IAAA,aAAAN,MAAA,WAkDQ,GAAqB,OAAjByB,KAAKm0B,QACL,MAAM,IAAI5xB,MAAM,sEAEpB,OAAOvC,KAAKm0B,UArDpB,CAAAt1B,IAAA,aAAAN,MAAA,SAwDsB02B,GAAiBj1B,KAAKkF,aAAayvB,SAASF,gBAAkBQ,IAxDpF,CAAAp2B,IAAA,gBAAAN,MAAA,WA8DQ,IAAIyB,KAAKo0B,iBAAT,CACA,GAAoC,IAAhCp0B,KAAKq0B,gBAAgBp4B,OAQrB,IANA,IAAMi5B,EAAY,CACdr1B,EAAiBuC,KACjBvC,EAAiBsC,KACjBtC,EAAiBwC,GACjBxC,EAAiByC,OAErB6C,EAAA,EAAAgwB,EAAwBD,EAAxB/vB,EAAAgwB,EAAAl5B,OAAAkJ,IAAmC,CAA9B,IAAMjD,EAASizB,EAAAhwB,GAChBnF,KAAKq0B,gBAAgBl4B,KACjB,IAAI0N,GAAsB3H,GACzBusB,cAdG,IAAA5S,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAiBhB,QAAAiX,EAAAC,EAAAC,IAAuBlc,KAAKq0B,mBAA5BxY,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAA6C,KAAlCuZ,EAAkCpZ,EAAAzd,MACzC62B,EAAS7G,YAAY8G,SAAU,GAlBnB,MAAAjZ,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,GAqBhB/b,KAAKs1B,UAAY,IAAItB,GACrBh0B,KAAKo0B,kBAAmB,KAlFhC,CAAAv1B,IAAA,gBAAAN,MAAA,WAuFQ,GAAKyB,KAAKo0B,kBAAoD,IAAhCp0B,KAAKq0B,gBAAgBp4B,OAAnD,CADgB,IAAAugB,GAAA,EAAAC,GAAA,EAAAC,OAAA3X,EAAA,IAEhB,QAAA4X,EAAAC,EAAAV,IAAuBlc,KAAKq0B,mBAA5B7X,GAAAG,EAAAC,EAAArC,QAAA4B,MAAAK,GAAA,EAA6C,KAAlC4Y,EAAkCzY,EAAApe,MACzC62B,EAAS7G,YAAY8G,SAAU,GAHnB,MAAAjZ,GAAAK,GAAA,EAAAC,EAAAN,EAAA,YAAAI,GAAA,MAAAI,EAAAP,QAAAO,EAAAP,SAAA,WAAAI,EAAA,MAAAC,GAKhB1c,KAAKo0B,kBAAmB,MA3FhC,EAAAv1B,IAAA,aAAAN,MAAA,WAEiC,OAAO,KAFxC,CAAAM,IAAA,cAAAN,MAAA,WASQ,OAHK21B,EAAc1tB,WACf0tB,EAAc1tB,SAAW,IAAI0tB,GAE1BA,EAAc1tB,aAT7B0tB,EAAA,GA8FMqB,GAAYtB,GAAcvtB,cACjBzB,GAAA,GChGTuwB,GAAN,SAAAC,GAAA,SAAAC,IAAA,OAAAt5B,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA01B,GAAAt5B,OAAA0L,EAAA,KAAA1L,CAAA4D,KAAA5D,OAAA2L,EAAA,KAAA3L,CAAAs5B,GAAA94B,MAAAoD,KAAA+I,YAAA,OAAA3M,OAAAmU,EAAA,KAAAnU,CAAAs5B,EAAAD,GAAAr5B,OAAA2K,EAAA,KAAA3K,CAAAs5B,EAAA,EAAA72B,IAAA,OAAAN,MAAA,WAMI,MAAO,KANX,CAAAM,IAAA,UAAAN,MAAA,WASI,MAAO,KATX,CAAAM,IAAA,UAAAN,MAAA,WAaIoN,QAAQya,IAAI,WAEZ,IAAMoO,EAAex0B,KAAK21B,MAAMnB,aAC1B9wB,EAAQ8wB,EAAaoB,YACrBjyB,EAAS6wB,EAAaqB,aAGvB5wB,GAAU+vB,UACb/vB,GAAU6wB,SAAS,CACjBtB,eACA9wB,QACAC,eAxBR+xB,EAAA,CAAqBj2B,EAAA,YAAf+1B,GAAMO,EAAA,MADXC,EAAA,MACKR,IA6BS,IC4FVS,GD5FUC,GAAA,GE7CkaC,GAAA,4BCQjbC,GAAgBh6B,OAAAi6B,GAAA,KAAAj6B,CACd+5B,GACAz0B,EACAG,GACF,EACA,KACA,WACA,MAIey0B,GAAAF,WCnBXG,GAAM,WAAgB,IAAAx2B,EAAAC,KAAaC,EAAAF,EAAAG,eAA0BC,EAAAJ,EAAAK,MAAAD,IAAAF,EAAwB,OAAAE,EAAA,OAAiBI,YAAA,gBAA2B,CAAAJ,EAAA,YAAiBE,MAAA,CAAOm2B,MAAAz2B,EAAA02B,MAAAC,YAAA,OAAAC,aAAA,OAAAC,MAAA,QAAwE91B,GAAA,CAAK+1B,OAAA,SAAAC,GAA0B,OAAA/2B,EAAAg3B,oBAA8B51B,MAAA,CAAQ5C,MAAAwB,EAAA,aAAAqB,SAAA,SAAAC,GAAkDtB,EAAAi3B,aAAA31B,GAAqBG,WAAA,kBAA4BrB,EAAA,YAAiBE,MAAA,CAAOm2B,MAAAz2B,EAAAk3B,OAAAP,YAAA,OAAAC,aAAA,OAAAC,MAAA,SAA0E91B,GAAA,CAAK+1B,OAAA,SAAAC,GAA0B,OAAA/2B,EAAAm3B,qBAA+B/1B,MAAA,CAAQ5C,MAAAwB,EAAA,cAAAqB,SAAA,SAAAC,GAAmDtB,EAAAo3B,cAAA91B,GAAsBG,WAAA,mBAA6BrB,EAAA,YAAiBE,MAAA,CAAOm2B,MAAAz2B,EAAA4oB,MAAA+N,YAAA32B,EAAAq3B,iBAAAT,aAAA52B,EAAAs3B,kBAAAT,MAAA,SAAsG91B,GAAA,CAAK+1B,OAAA,SAAAC,GAA0B,OAAA/2B,EAAAu3B,qBAA+Bn2B,MAAA,CAAQ5C,MAAAwB,EAAA,cAAAqB,SAAA,SAAAC,GAAmDtB,EAAAwpB,cAAAloB,GAAsBG,WAAA,oBAA6B,IACj8B+1B,GAAe,8GCEbC,GAAmB,IACnBC,GAAmB,IAEnBC,mHAEyBC,GACvB,OAAOC,GAAAn0B,EAAMtF,IAAIw5B,EAAK,CAACE,aAAc,SAASC,KAAK,SAACC,GAChD,OAAOA,EAASt8B,iDAUQk8B,GAA2B,IAAdK,EAAcjvB,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,IAAAA,UAAA,GACnDkvB,GAAS,EACTC,EAAsB,KACpBC,EAAU,IAAIC,GAAA,QAAK,CACrBC,IAAK,CAACV,GACNW,MAAON,EACPO,OAAQ,WACJN,GAAS,GAEbO,YAAa,SAACC,EAAGC,GACbR,EAAQ,IAAI31B,MAAJ,8BAAAC,OAAwCm1B,EAAxC,MAAAn1B,OAAgDk2B,OAIhE,OAAO,IAAIC,GAAAl1B,EAAQ,SAACm1B,EAASC,GACzB,IAAMC,EAAYC,OACZC,EAAUxB,GACVyB,EAAc,SAAdA,IACF,GAAIhB,EACAtsB,QAAQya,IAAR,mCAAA5jB,OAA+Cm1B,IAC/CiB,EAAQT,OACL,IAAc,OAAVD,EACP,MAAMA,EACH,GAAIa,OAAaD,EAAYE,EAChC,MAAM,IAAIz2B,MAAJ,mBAAAC,OAA6Bw2B,EAA7B,kCAAAx2B,OAAqEm1B,IAE3EuB,WAAWD,EAAaxB,MAGhCwB,eAIGE,GAAA,sFJpCFC,GAAb,WAiBI,SAAAC,IAAAj9B,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAq5B,GACIr5B,KAAKqiB,IAAM,IAAIzd,EAAAnB,EACfzD,KAAKs5B,WAAa,IAAI10B,EAAAnB,EACtBzD,KAAKu5B,KAAO,EACZv5B,KAAKw5B,UAAW,EAChBx5B,KAAKy5B,QAtBb,OAAAr9B,OAAA2K,EAAA,KAAA3K,CAAAi9B,EAAA,EAAAx6B,IAAA,UAAAN,MAAA,SA2BmBm7B,EAAkBC,GAE7B,OADA35B,KAAK45B,OACE,IAAIC,GAAiB75B,KAAKqiB,IAAK4T,GAAkB6D,SAAUJ,EAASC,KA7BnF,CAAA96B,IAAA,OAAAN,MAAA,WAiCQ,OADAyB,KAAK45B,OACE55B,KAAKqiB,IAAIF,SAjCxB,CAAAtjB,IAAA,SAAAN,MAAA,WAqCQ,OADAyB,KAAK45B,OACE55B,KAAKqiB,IAAI0X,WArCxB,CAAAl7B,IAAAm7B,GAAAv2B,EAAAlF,MAAA,WAyCQ,OADAyB,KAAK45B,OACL1d,IAAOlc,KAAKqiB,OAzCpB,CAAAxjB,IAAA,iBAAAN,MAAA,SAgD0Bm7B,EAAkBC,GAEpC,OADA35B,KAAK45B,OACE,IAAIC,GAAiB75B,KAAKs5B,WAAYrD,GAAkBgE,UAAWP,EAASC,KAlD3F,CAAA96B,IAAA,cAAAN,MAAA,WAsDQ,OADAyB,KAAK45B,OACE55B,KAAKs5B,WAAWnX,SAtD/B,CAAAtjB,IAAA,gBAAAN,MAAA,WA0DQ,OADAyB,KAAK45B,OACE55B,KAAKs5B,WAAWS,WA1D/B,CAAAl7B,IAAA,MAAAN,MAAA,SAkEeM,EAAaN,GAIpB,OAHAyB,KAAKqiB,IAAI/b,IAAIzH,EAAKN,GAClByB,KAAKw5B,UAAW,EAChBx5B,KAAKu5B,KAAOv5B,KAAKqiB,IAAIkX,KACdv5B,OAtEf,CAAAnB,IAAA,OAAAN,MAAA,WA8EQ,IAAIyB,KAAKw5B,SAAT,CAEA,IAAMU,EAAmB99B,OAAA+9B,GAAA,KAAA/9B,CAAI4D,KAAKqiB,IAAI+X,WAAWR,KAAKP,EAASgB,gBAEzDC,EAAoBJ,EAAiB56B,QAAQi7B,UAEnDv6B,KAAKqiB,IAAM,IAAIzd,EAAAnB,EAAIy2B,GACnBl6B,KAAKs5B,WAAa,IAAI10B,EAAAnB,EAAI62B,GAC1Bt6B,KAAKw5B,UAAW,EAChBx5B,KAAKy5B,WAvFb,CAAA56B,IAAA,QAAAN,MAAA,WA+FiB,IAAAsJ,EAAA7H,KACHw6B,EAAWC,KAA2BhvB,KAAsBzL,KAAKqiB,MAGvEmY,EAAStzB,QAAQ,SAACwzB,GACd,IAA6C,IAAzCrB,EAASsB,aAAaC,QAAQF,IACK,oBAA3B7yB,EAAKwa,IAAYqY,GAD7B,CAIA,IAAMG,EAAWhzB,EAAKwa,IAAYqY,GAAM57B,KAAK+I,EAAKwa,KAC5CyY,EAAkBjzB,EAAKyxB,WAAmBoB,GAAM57B,KAAK+I,EAAKyxB,YAG1DyB,EAAW,WACb,IAAMC,EAASH,EAAOj+B,WAAP,EAAAmM,WAIf,OAHA+xB,EAAcl+B,WAAd,EAAAmM,WACAlB,EAAK0xB,KAAO1xB,EAAKwa,IAAIkX,KAEdyB,GAEXnzB,EAAK6yB,GAAQK,QAnHzB,EAAAl8B,IAAA,iBAAAN,MAAA,SAKkCkF,EAAsBw3B,GAChD,OAAOx3B,EAAE,GAAKw3B,EAAE,OANxB5B,EAAA,GAImBD,GAAAuB,aAAe,CAAC,MAAO,UAAW,SAAU,OAAQ,eAoHvE,SAAK1E,GACDA,IAAA,0BACAA,IAAA,4BAFJ,CAAKA,QAAiB,SAQhB4D,cAoBF,SAAAqB,EAAY7Y,EAA2BngB,EAC3Bw3B,EAAkBC,GAK1B,GALwCv9B,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAk7B,GACxCl7B,KAAKm7B,GAAK9Y,EAAI+X,UACdp6B,KAAKkC,UAAYA,EACjBlC,KAAKoM,MAAQstB,EACb15B,KAAKo7B,IAAMzB,OACQ50B,IAAf/E,KAAKoM,MAAT,CAMA,IAAItP,EAASkD,KAAKm7B,GAAG5gB,OACrB,OAAQzd,EAAOqf,KAAM,CACjB,GAAI+e,EAAiBG,QAAQv+B,EAAOyB,MAAM,GAAIyB,KAAKoM,MAAOpM,KAAKkC,WAE3D,YADAlC,KAAKs7B,eAAiBx+B,GAG1BA,EAASkD,KAAKm7B,GAAG5gB,qEAnCFghB,EAAgBC,EAAgBt5B,GACnD,OAAIA,IAAc+zB,GAAkB6D,SACzByB,GAAUC,EAEdD,GAAUC,0DAoCWz2B,IAAxB/E,KAAKs7B,iBACLt7B,KAAKs7B,eAAiBt7B,KAAKm7B,GAAG5gB,QAElC,IAAMqF,EAAM5f,KAAKs7B,eAIjB,YAAiBv2B,IAAb/E,KAAKo7B,KACDF,EAAiBG,QAAQzb,EAAIrhB,MAAM,GAAIyB,KAAKo7B,IAAKp7B,KAAKkC,WAC/C,CAAC3D,MAAOqhB,EAAIrhB,MAAO4d,MAAM,IAKxCnc,KAAKs7B,eAAiBt7B,KAAKm7B,GAAG5gB,OACvBqF,gCAIP,OAAO5f,qCAcP,MAAM,IAAI8oB,iCAIV,MAAM,IAAIA,sCAKV,YAA4B/jB,IAAxB/E,KAAKs7B,gBAGFt7B,KAAKs7B,eAAenf,cA6B7B,SAAUsf,GACZ1J,EAAcnxB,EAAwBwL,EACtCsvB,EAAcC,GACV,IAAK/6B,EAAIrC,MAAQ6N,EAAQ,EAAG2lB,EAAG6J,8BAA8Bh7B,IAAQA,EAAIrC,MAAQm9B,GAC7EC,EAAG/6B,GAKR,IKjQKi7B,GLiQCC,GAAb,oBAAAC,IAAA3/B,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA+7B,GAMW/7B,KAAAuvB,SAAuB,GACvBvvB,KAAAi4B,QAAkB,EAP7B,OAAA77B,OAAA2K,EAAA,KAAA3K,CAAA2/B,EAAA,EAAAl9B,IAAA,8BAAAN,MAAA,SASuCsqB,GAA0B,MAAM,IAAIC,KAT3E,CAAAjqB,IAAA,qBAAAN,MAAA,SAWQsqB,EACAmT,EACAC,GAAqD,MAAM,IAAInT,KAbvE,CAAAjqB,IAAA,eAAAN,MAAA,WAe4B,OAAOyB,KAAKuvB,SAAStzB,SAfjD,CAAA4C,IAAA,eAAAN,MAAA,SAgBwB29B,GAChBl8B,KAAKuvB,SAAStzB,OAASigC,EACvB,IAAK,IAAIngC,EAAI,EAAGA,EAAImgC,EAAcngC,IAE9BiE,KAAKuvB,SAASxzB,QAA2BgJ,IAArB/E,KAAKuvB,SAASxzB,GAAmB,IAAIq9B,GAAap5B,KAAKuvB,SAASxzB,KApBhG,CAAA8C,IAAA,cAAAN,MAAA,WAuB2B,MAAM,IAAIuqB,KAvBrC,CAAAjqB,IAAA,SAAAN,MAAA,SAwBkB+M,GAAmB,OAAOtL,KAAKuvB,WAAajkB,EAAMikB,WAxBpE,CAAA1wB,IAAA,aAAAN,MAAA,SA0BsBsxB,EAAejvB,GAK7B,IAAMu7B,EAAWn8B,KAAKuvB,SAASM,GACzB/W,EAAUqjB,EAASh+B,IAAIyC,GAG7B,YAAoBmE,IAAZ+T,EAAyBpL,GAAS0uB,WAAatjB,IAnC/D,CAAAja,IAAA,cAAAN,MAAA,SAsCuBsxB,EAAejvB,GAAoC,OAAOZ,KAAKuvB,SAASM,GAAO1xB,IAAIyC,KAtC1G,CAAA/B,IAAA,gBAAAN,MAAA,SAuCyBsxB,EAAejvB,GAAeZ,KAAKuvB,SAASM,GAAOiE,OAAOlzB,KAvCnF,CAAA/B,IAAA,kBAAAN,MAAA,SAwD2BsxB,EAAexgB,EAAkBgtB,EACjCna,EAAqBoa,GAA4B,MAAM,IAAIxT,KAzDtF,CAAAjqB,IAAA,2BAAAN,MAAA,WA8DwC,MAAM,IAAIuqB,KA9DlD,CAAAjqB,IAAA,2BAAAN,MAAA,WAiEwC,MAAM,IAAIuqB,KAjElD,CAAAjqB,IAAA,4BAAAN,MAAA,SAqEqCsxB,EAAe0M,GAA2D,IAA3BC,EAA2BzzB,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,IAAAA,UAAA,GACjG0zB,EAAWz8B,KAAKuvB,SAASM,GACzB6M,EAAOD,EAASrC,QAAQmC,EAAYh+B,MAAQ,GAC9Csf,EAAQ6e,EAAKniB,OACjB,GAAIsD,EAAM1B,KAAQ,OAAO,EAIzB,GAFAoK,GAAa1I,EAAMtf,MAAM,GAAKg+B,EAAYh+B,OAEtCi+B,EACA,MAAO3e,EAAMtf,MAAM,GAAG2C,OAAS6I,GAAY+E,aAEvC,GADA+O,EAAQ6e,EAAKniB,OACTsD,EAAM1B,KAAQ,OAAO,EAIjC,OADAogB,EAAYh+B,MAAQsf,EAAMtf,MAAM,IACzB,IApFf,CAAAM,IAAA,gCAAAN,MAAA,SAuFyCg+B,GAGjC,IAFA,IAAII,EAAiBrvB,GACjBsvB,GAAkB,EACbp+B,EAAI,EAAGA,EAAIwB,KAAK68B,eAAgBr+B,IAAK,CAC1C,IAAMs+B,EAAkB,CAACv+B,MAAOg+B,EAAYh+B,OACxCyB,KAAK+8B,0BAA0Bv+B,EAAGs+B,KAClCF,GAAkB,EAClBlW,GAAOoW,EAAgBv+B,MAAQ+O,GAAc,wCAC7CqvB,EAAiBjzB,KAAKiS,IAAIghB,EAAgBG,EAAgBv+B,QAIlE,QAAIq+B,IACAL,EAAYh+B,MAAQo+B,GACb,KArGnB,CAAA99B,IAAA,4BAAAN,MAAA,SA0GqCsxB,EAAe0M,GAC5C,IAAME,EAAWz8B,KAAKuvB,SAASM,GAGzB6M,EAAOD,EAASO,eAAeT,EAAYh+B,OAG3Csf,EAAQ6e,EAAKniB,OACnB,OAAIsD,EAAM1B,OAGVoK,GAAa1I,EAAMtf,MAAM,GAAKg+B,EAAYh+B,OAC1Cg+B,EAAYh+B,MAAQsf,EAAMtf,MAAM,IACzB,KAvHf,CAAAM,IAAA,gCAAAN,MAAA,SA0HyCg+B,GAGjC,IAFA,IAAIU,EAAiB,EACjBC,GAAkB,EACb1+B,EAAI,EAAGA,EAAIwB,KAAK68B,eAAgBr+B,IAAK,CAC1C,IAAMs+B,EAAkB,CAACv+B,MAAOg+B,EAAYh+B,OACxCyB,KAAKm9B,0BAA0B3+B,EAAGs+B,KAClCI,GAAkB,EAClB3W,GAAauW,EAAgBv+B,MAAQ+O,IACrC2vB,EAAiBvzB,KAAKkS,IAAIqhB,EAAgBH,EAAgBv+B,QAIlE,QAAI2+B,IACAX,EAAYh+B,MAAQ0+B,GACb,KAxInB,CAAAp+B,IAAA,mBAAAN,MAAA,SA6I4B6+B,EAAc/E,GAAe,MAAM,IAAIvP,KA7InE,CAAAjqB,IAAA,aAAAN,MAAA,SA8IsBsxB,EAAejvB,EAAakvB,GAG1C,GAFAvJ,GAAasJ,GAAS,GAAKA,EAAQ7vB,KAAK68B,kBAEpCj8B,EAAM,GAOV,GAAIkvB,EAAGtV,OAAO9M,GAASE,OAAQ,CAC3B,IAAMuuB,EAAWn8B,KAAKuvB,SAASM,GAG/BsM,EAASrI,OAAOlzB,QAEhBZ,KAAKuvB,SAASM,GAAOvpB,IAAI1F,EAAKkvB,KA9J1C,CAAAjxB,IAAA,cAAAN,MAAA,SAyKuBsxB,EAAexgB,EAAkBgtB,EAAgBvM,GAChE,MAAM,IAAIhH,KA1KlB,CAAAjqB,IAAA,qBAAAN,MAAA,SA6K8B8+B,EAAkBC,EAAgBzN,GAAiB,OAAO,IAAI/G,KA7K5F,CAAAjqB,IAAA,aAAAN,MAAA,SA8KsB8+B,EAAkBC,GAAkB,OAAO,IAAIxU,KA9KrE,CAAAjqB,IAAA,WAAAN,MAAA,WA+KmB,IAAAsd,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IACX,QAAAiX,EAAAC,EAAAC,IAAoBlc,KAAKuvB,YAAzB1T,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAAmC,KAAxBgU,EAAwB7T,EAAAzd,MAC/BsxB,EAAM0N,SAFC,MAAAnhB,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,MA/KnB,CAAAld,IAAA,YAAAN,MAAA,WAoLyB,OAAO,IAAIuqB,KApLpC,CAAAjqB,IAAA,UAAAN,MAAA,WAqLuB,OAAO,IAAIuqB,KArLlC,CAAAjqB,IAAA,aAAAN,MAAA,SAuLsBqC,GAAe,OAAO,IAAIkoB,KAvLhD,CAAAjqB,IAAA,kBAAAN,MAAA,SA2L2BsxB,EAAejvB,EAAa48B,GAI/C,IAAK,IAAMC,EAAS,CAACl/B,MAAOqC,GAAMZ,KAAKm9B,0BAA0BtN,EAAO4N,IAAWA,EAAOl/B,OAAS,GAAI,CACnG,IAAMuxB,EAAK9vB,KAAK09B,WAAW7N,EAAO4N,EAAOl/B,OACzC,OAAQuxB,EAAG5uB,MACP,KAAK6I,GAAY2E,SACb,QAAIohB,EAAG1kB,SAAWqyB,EAAOl/B,MAAQqC,KAGjC48B,EAAQj/B,MAAQk/B,EAAOl/B,OAChB,GAEX,KAAKwL,GAAYyE,IACjB,KAAKzE,GAAY6E,KACjB,KAAK7E,GAAY8E,OACjB,KAAK9E,GAAY0E,KACjB,KAAK1E,GAAY2B,KACb,OAAO,EAEX,KAAK3B,GAAYY,MACjB,KAAKZ,GAAY+E,aAEb,SACJ,QACI,MAAM,IAAIvM,MAAJ,wBAAAC,OAAkCstB,EAAG5uB,QAIvD,OAAO,IAzNf,CAAArC,IAAA,mBAAAN,MAAA,SA4N4BqC,GACpB,OAA2C,IAApCZ,KAAK29B,qBAAqB/8B,KA7NzC,CAAA/B,IAAA,6BAAAN,MAAA,SAgOsCqC,GAC9B,OAAqD,IAA9CZ,KAAK49B,+BAA+Bh9B,KAjOnD,CAAA/B,IAAA,uBAAAN,MAAA,SAwOgCqC,GACxB,IAAK,IAAIpC,EAAI,EAAGA,EAAIwB,KAAK68B,eAAgBr+B,IAAK,CAC1C,IAAMsxB,EAAK9vB,KAAK09B,WAAWl/B,EAAGoC,GAC9B,GAAIkvB,EAAG5uB,OAAS6I,GAAYyE,KAAOshB,EAAG5uB,OAAS6I,GAAY0E,KACvD,OAAOjQ,EAGf,OAAQ,IA/OhB,CAAAK,IAAA,iCAAAN,MAAA,SAsP0CqC,GAClC,IAAK,IAAIpC,EAAI,EAAGA,EAAIwB,KAAK68B,eAAgBr+B,IAAK,CAC1C,IAAMsxB,EAAK9vB,KAAK09B,WAAWl/B,EAAGoC,GAC9B,GAAIkvB,EAAG5uB,OAAS6I,GAAYyE,KACxBshB,EAAG5uB,OAAS6I,GAAY0E,MACxBqhB,EAAG5uB,OAAS6I,GAAY2E,SACxB,OAAOlQ,EAGf,OAAQ,MA/PhBu9B,EAAA,GAmQe8B,GAAA,gBMvgBFC,GAAb,oBAAAC,IAAA3hC,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA+9B,GAAA,OAAA3hC,OAAA2K,EAAA,KAAA3K,CAAA2hC,EAAA,OAAAl/B,IAAA,2BAAAN,MAAA,SAE2Cy/B,EAAeC,GAElD,IAAIC,EAAqB,GACrBC,EAAoB,EACpBC,EAAkB,EAClBnmB,EAAQ,EAIZ,OAA8E,KAArEkmB,EAAoBF,EAAYrD,QAAQ,KAAMwD,IAEnDF,GAAcD,EAAYI,OAAOpmB,EAAOkmB,EAAoBC,GAC5DnmB,GAASkmB,EAAoBC,EAE7BA,EAAkBH,EAAYrD,QAAQ,KAAMuD,GAC5CC,GAAwC,IAArBA,EAAyBH,EAAYhiC,OAASmiC,EAAkB,EACnFnmB,GAASmmB,EAAkBD,EAE/BD,GAAcD,EAAYI,OAAOpmB,EAAOgmB,EAAYhiC,OAASmiC,GAG7D,IAAM9d,EAAY0d,EAAInB,eACtBmB,EAAIM,WACJN,EAAIO,aAAaje,GAGjBtgB,KAAKw+B,mCAAmCR,EAAKE,EAAYh0B,GAAgBoW,KA5BjF,CAAAzhB,IAAA,qCAAAN,MAAA,SAgCQy/B,EAAeE,EAAoBnzB,EAAkBuV,GAqBrD,IAPA,IAAMme,EAAc,SAACt2B,GACjB,OAAoB,IAAbA,EAAElM,QAGPyiC,EAAWR,EAAWpc,MAAM,KAC7BO,IAAI,SAACla,GAAD,OAAOA,EAAEw2B,SACbC,OAAOH,GACHI,EAAe,EAAGA,EAAeH,EAASziC,OAAQ4iC,IAQvD,IAPA,IAAMC,EAAUJ,EAASG,GAInBE,EAAeD,EAAQhd,MAAM,MAC9BO,IAAI,SAACla,GAAD,OAAOA,EAAEw2B,SACbC,OAAOH,GACHO,EAAY,EAAGA,EAAYD,EAAa9iC,OAAQ+iC,IASrD,IARA,IAAMC,EAAOF,EAAaC,GAGpBE,EAAqBF,EAAYD,EAAa9iC,OAC9CiR,GAAQ2xB,EAAeK,GAAsBzxB,GAC7CqL,EAAUzL,GAAYD,cAAcF,GAGjCiyB,EAAa,EAAGA,EAAa7e,EAAW6e,IAAc,CAC3D,IAAMC,EAAWH,EAAKI,OAAOF,GACvBrP,EAAK9vB,KAAKs/B,iBAAiBF,EAAUpB,EAAKmB,EAAYrmB,GAKxDgX,EAAG5uB,OAAS6I,GAAYY,OAAsB,MAAby0B,IACjCtP,EAAG/kB,GAAKA,EACRizB,EAAIuB,WAAWJ,EAAYrmB,EAASgX,IAOpD,IAAK,IAAItxB,EAAI,EAAGA,EAAIw/B,EAAInB,eAAgBr+B,IAAK,CAGzC,IAAMqxB,EAAQmO,EAAIzO,SAAS/wB,GAHcqd,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAIzC,QAAAiX,EAAAC,EAAAC,IAAwB2T,KAAxBhU,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAA+B,KAAA2jB,EAAApjC,OAAAqjC,GAAA,KAAArjC,CAAA4f,EAAAzd,MAAA,GAAnBqC,EAAmB4+B,EAAA,GAAdnP,EAAcmP,EAAA,GAC3B,GAAInP,EAAGnvB,OAAS6I,GAAY2E,UAAY2hB,EAAGjlB,WAAakC,GAAc,CAClE,IAAMoyB,EAAOryB,GAAYoC,cAAc7O,GACvC+K,QAAQya,IAAR,sEAAA5jB,OAAkFk9B,IAClF1B,EAAI2B,cAAcnhC,EAAGoC,KARY,MAAAwb,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,OAtFrD,CAAAld,IAAA,mBAAAN,MAAA,SA4GmC6gC,EACArN,EACAlC,EACA/W,GAC3B,IAAIgX,EAAcpiB,GAAS0uB,WAE3B,OAAQgD,GACJ,IAAK,IAAKtP,EAAKpiB,GAAS0uB,WAAY,MACpC,IAAK,IAAKtM,EAAKpiB,GAASkyB,iBAAkB,MAC1C,IAAK,IACL,IAAK,IACD9P,EAAmB,MAAbsP,EAAoB1xB,GAASmyB,sBAAwBnyB,GAASoyB,sBAGpEhQ,EAAG1kB,SAAWkC,GACd,MACJ,IAAK,IAED,IAAMkwB,EAAU,CAACj/B,MAAO,GACxB,GAAKwzB,EAAGgO,gBAAgBlQ,EAAO/W,EAAS0kB,GAEjC,CACH,IAAMwC,EAAWjO,EAAGkO,YAAYpQ,EAAO2N,EAAQj/B,OAC/C,QAAiBwG,IAAbi7B,EACA,MAAM,IAAIz9B,MAAJ,uCAAAC,OAAiDqtB,EAAjD,MAAArtB,OAA2Dg7B,EAAQj/B,QAE7EyhC,EAAS50B,SAAW0N,EAAU0kB,EAAQj/B,WANtCoN,QAAQgS,KAAR,wBAAAnb,OAAqCqtB,EAArC,iBAAArtB,OAA0DsW,IAS9D,MACJ,IAAK,IAAKgX,EAAKpiB,GAASwyB,kBAAmB,MAC3C,IAAK,IAAKpQ,EAAKpiB,GAASyyB,0BAA2B,MACnD,IAAK,IAAKrQ,EAAKpiB,GAAS0yB,kBAAmB,MAC3C,IAAK,IAAKtQ,EAAKpiB,GAAS2yB,kBAAmB,MAC3C,QAEIvQ,EAAKpiB,GAAS0uB,WACd,MAIR,OAAOtM,MArJfiO,EAAA,IDGA,SAAYlC,GACRA,IAAA,sBACAA,IAAA,4BACAA,IAAA,sBACAA,IAAA,gBACAA,IAAA,yBALJ,CAAYA,QAAU,KAYf,IAAMyE,GAAb,WAyCI,SAAAC,EAAYC,EAAkBC,GAAUrkC,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAugC,GApCjCvgC,KAAA6oB,WAAyB,IAAI1K,GAE7Bne,KAAAuhB,UAAuBzB,GAAU3V,QAEjCnK,KAAA0gC,cAAwB,GAMxB1gC,KAAA2gC,YAAsB,GAEtB3gC,KAAA4gC,WAAqB,GAErB5gC,KAAA0hB,WAAyBxB,GAAW/V,QAEpCnK,KAAA6gC,OAAiB,EAGjB7gC,KAAA8gC,OAAiB,GAEjB9gC,KAAA+gC,UAAoB,GAEpB/gC,KAAAghC,eAAyBnF,GAAWoF,OAEpCjhC,KAAAkhC,gBAA0B,EAG1BlhC,KAAAmhC,gBAA0B,EAGzBnhC,KAAAwgC,SAAqB,IAAI3C,GAGzB79B,KAAAohC,kBAA4B,EAGhCphC,KAAKqhC,mBAAqBb,EAC1BxgC,KAAKygC,KAAOA,EA3CpB,OAAArkC,OAAA2K,EAAA,KAAA3K,CAAAmkC,EAAA,EAAA1hC,IAAA,cAAAN,MAAA,WA8C2B,OAAOyB,KAAKwgC,WA9CvC,CAAA3hC,IAAA,wBAAAN,MAAA,WA+CqC,OAAOyB,KAAKqhC,qBA/CjD,CAAAxiC,IAAA,mBAAAN,MAAA,WAgDgC,OAAOyB,KAAKohC,mBAhD5C,CAAAviC,IAAA,gBAAAN,MAAA,WAiD6B,OAAOyB,KAAK6oB,WAAWnL,QAAU1d,KAAKygC,KAAK9a,WAAa3lB,KAAK6oB,aAjD1F,CAAAhqB,IAAA,aAAAN,MAAA,WAoDYyB,KAAKohC,mBAMTphC,KAAKohC,kBAAmB,EACxBphC,KAAKwgC,SAASjC,aAAarb,GAAQoe,iBAAiBthC,KAAKuhB,WAAWjB,WACpEwd,GAAayD,yBAAyBvhC,KAAKwgC,SAAUxgC,KAAKqhC,uBA5DlE,CAAAxiC,IAAA,aAAAN,MAAA,WAsEQ,GAAIyB,KAAKuhB,YAAczB,GAAU3V,QAAS,CACtC,IAAMq3B,EAAkBxhC,KAAK0gC,cAC7B/0B,QAAQgS,KAAR,sCAAAnb,OAAmDg/B,EAAnD,sBACOxhC,KAAK0gC,cAIZ1gC,KAAK0hB,WAAexB,GAAW/V,QAI/BnK,KAAK0hB,aAAexB,GAAW/V,UACZ,IAAfnK,KAAK6gC,MACL7gC,KAAK0hB,WAAaxB,GAAWa,SACtB/gB,KAAK6gC,OAAS,EACrB7gC,KAAK0hB,WAAaxB,GAAWc,KACtBhhB,KAAK6gC,OAAS,EACrB7gC,KAAK0hB,WAAaxB,GAAWe,OAE7BjhB,KAAK0hB,WAAaxB,GAAWgB,MAIjClhB,KAAK6gC,UA7FjBN,EAAA,GAoGekB,GAAA,GEzHFC,GAAb,WAmDI,SAAAC,IAAAvlC,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA2hC,GAhDO3hC,KAAA4hC,SAAW,GACX5hC,KAAA6hC,UAAY,GAEZ7hC,KAAA8hC,UAAY,GACZ9hC,KAAA+hC,SAAW,GACX/hC,KAAAgiC,OAAS,GACThiC,KAAAiiC,kBAAoB,GACpBjiC,KAAAkiC,iBAAmB,GACnBliC,KAAAmiC,eAAiB,GAGjBniC,KAAAoiC,QAAU,EAEVpiC,KAAAqiC,MAAQ,GACRriC,KAAA8gC,OAAS,GACT9gC,KAAAsiC,OAAS,GAGTtiC,KAAAuiC,eAAiB,EACjBviC,KAAAwiC,oBAAsB,EACtBxiC,KAAAyiC,qBAAuB,EACvBziC,KAAA0iC,eAAiB,EACjB1iC,KAAAkhC,gBAAkB,EAClBlhC,KAAAmhC,gBAAkB,EAOlBnhC,KAAA2lB,WAAyB,IAAIxH,GAI7Bne,KAAA2iC,YAAc,EAEd3iC,KAAA4iC,WAAa,EAEb5iC,KAAA6iC,oBAAsB,EAQrB7iC,KAAA8iC,kBAAoB,kCAGxB9iC,KAAK+iC,YAAc,GACnB,IAAK,IAAIhnC,EAAI,EAAGA,EAAI+jB,GAAUhW,IAAK/N,IAC/BiE,KAAK+iC,YAAYhnC,GAAK,GAE1BiE,KAAK2oB,MAAQ,GAxDrB,OAAAvsB,OAAA2K,EAAA,KAAA3K,CAAAulC,EAAA,EAAA9iC,IAAA,WAAAN,MAAA,SA2DoBoqB,GAEZ3oB,KAAK2oB,MAAMxsB,KAAKwsB,GAChB3oB,KAAK+iC,YAAYpa,EAAMpH,WAAWplB,KAAKwsB,KA9D/C,CAAA9pB,IAAA,WAAAN,MAAA,WAgEiC,OAAOyB,KAAK2oB,MAAM1sB,OAAS,IAhE5D,CAAA4C,IAAA,WAAAN,MAAA,SAiEoB0Z,GAAiB,OAAOjY,KAAK2oB,MAAM1Q,KAjEvD,CAAApZ,IAAA,cAAAN,MAAA,WAkE2B,OAAOyB,KAAK2oB,QAlEvC,CAAA9pB,IAAA,aAAAN,MAAA,WAqEQyB,KAAK2lB,WAAWqd,YAAW,GADd,IAAAnnB,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAGb,QAAAiX,EAAAC,EAAAC,IAAoBlc,KAAK2oB,SAAzB9M,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAAgC,KAArB8M,EAAqB3M,EAAAzd,MAC5BoqB,EAAME,WAAWma,YAAW,IAJnB,MAAA5mB,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,QApErB4lB,EAAA,GA4EesB,GAAA,GCnETC,GAAgB,QAgBtB,SAASC,GAAWC,GAChBA,EAAK3C,KAAKqB,UAAYsB,EAAKC,OAAO,GAGtC,SAASC,GAAcF,GACnBA,EAAK3C,KAAKsB,SAAWqB,EAAKC,OAAO,GAGrC,SAASE,GAAYH,GACjBA,EAAK3C,KAAKuB,OAASoB,EAAKC,OAAO,GAGnC,SAASG,GAAmBJ,GACxBA,EAAK3C,KAAKwB,kBAAoBmB,EAAKC,OAAO,GAG9C,SAASI,GAAsBL,GAC3BA,EAAK3C,KAAKyB,iBAAmBkB,EAAKC,OAAO,GAG7C,SAASK,GAAoBN,GACzBA,EAAK3C,KAAK0B,eAAiBiB,EAAKC,OAAO,GAE3C,SAASM,GAAWP,GAChBA,EAAK3C,KAAK4B,MAAQe,EAAKC,OAAO,GAElC,SAASO,GAAYR,GACjBA,EAAK3C,KAAKK,OAASsC,EAAKC,OAAO,GAEnC,SAASQ,GAAYT,GACjBz3B,QAAQC,MAAM,2BAElB,SAASk4B,GAAgBV,GACrBz3B,QAAQC,MAAM,oCAElB,SAASm4B,GAAgBX,GACrBz3B,QAAQC,MAAM,gCAElB,SAASo4B,GAAaZ,GAClBz3B,QAAQC,MAAM,6BAElB,SAASq4B,GAAWb,GAChBz3B,QAAQC,MAAM,+BAElB,SAASs4B,GAAYd,GACjBA,EAAK3C,KAAK9a,WAAW1L,UAAUoH,GAAQW,cAAcohB,EAAKC,OAAO,KAErE,SAASc,GAAUf,GACfA,EAAKgB,WAAa,GAClBhB,EAAKgB,WAAaC,GAAaC,UAAUlB,EAAKC,OAAO,IAEzD,SAASkB,GAAWnB,GAChBA,EAAKjtB,MAAQ,GACbitB,EAAKjtB,MAAQkuB,GAAaG,WAAWpB,EAAKC,OAAO,IAErD,SAASoB,GAAYrB,GACjBiB,GAAaK,cAActB,EAAK3C,KAAK9a,WAAYyd,EAAKC,OAAO,IAEjE,SAASsB,GAAoBvB,GACzBiB,GAAaO,sBAAsBxB,EAAK3C,KAAK9a,WAAYyd,EAAKC,OAAO,IAEzE,SAASwB,GAAgBzB,GACrBiB,GAAaS,kBAAkB1B,EAAK3C,KAAK9a,WAAYyd,EAAKC,OAAO,IAErE,SAAS0B,GAAqB3B,IAI9B,SAAS4B,GAAiB5B,GACtBA,EAAK3C,KAAK+B,oBAAsBnhB,GAAQ4jB,gBAAgB7B,EAAKC,OAAO,IAExE,SAAS6B,GAAkB9B,GACvBA,EAAK3C,KAAKgC,qBAAuBphB,GAAQ4jB,gBAAgB7B,EAAKC,OAAO,IAEzE,SAAS8B,GAAgB/B,GAEE,MAAnBA,EAAKC,OAAO,GACZD,EAAK3C,KAAKiC,eAAiB7G,GAAWuJ,QAEtChC,EAAK3C,KAAKiC,eAAiB7G,GAAWwJ,UACtCjC,EAAK3C,KAAKS,gBAAkB7f,GAAQW,cAAcohB,EAAKC,OAAO,IAE1DD,EAAKC,OAAOpnC,OAAS,GAAwB,KAAnBmnC,EAAKC,OAAO,GACtCD,EAAK3C,KAAKU,gBAAkBiC,EAAK3C,KAAKS,gBAEtCkC,EAAK3C,KAAKU,gBAAkB9f,GAAQW,cAAcohB,EAAKC,OAAO,KAI1E,SAASiC,GAAgBlC,IAGzB,SAASmC,GAAenC,IAIxB,SAASoC,GAAepC,IAGxB,SAASqC,GAAerC,IAGxB,SAASsC,GAAatC,IAOtB,IAAMuC,GAA4C,IAAI/gC,EAAAnB,EAAI,CACtD,CAAC,QAAS0/B,IACV,CAAC,WAAYG,IACb,CAAC,SAAUC,IACX,CAAC,gBAAiBC,IAClB,CAAC,mBAAoBC,IACrB,CAAC,iBAAkBC,IACnB,CAAC,QAASC,IACV,CAAC,SAAUC,IACX,CAAC,SAAUC,IACX,CAAC,aAAcC,IAEf,CAAC,aAAcC,IACf,CAAC,UAAWC,IACZ,CAAC,QAASC,IACV,CAAC,SAAUC,IACX,CAAC,OAAQC,IACT,CAAC,QAASI,IACV,CAAC,UAAWA,IACZ,CAAC,SAAUE,IACX,CAAC,iBAAkBE,IACnB,CAAC,aAAcE,IACf,CAAC,kBAAmBE,IACpB,CAAC,cAAeC,IAChB,CAAC,eAAgBE,IACjB,CAAC,aAAcC,IACf,CAAC,aAAcG,IAKf,CAAC,aAAcC,IACf,CAAC,YAAaC,IACd,CAAC,YAAaC,IAEd,CAAC,UAAWC,MAiBHrB,GAAb,oBAAAuB,IAAAxpC,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA4lC,GAAA,OAAAxpC,OAAA2K,EAAA,KAAA3K,CAAAwpC,EAAA,OAAA/mC,IAAA,YAAAN,MAAA,SAQ4B0gC,EAAc4G,GAIlC,IAAMtpB,EAAS0iB,EAAK6G,QAAQ,iBAAkB,IAE9C,OAAIvpB,IAAW0iB,EACJ5d,GAAQW,cAAcid,GAAQ4G,EAElCxkB,GAAQW,cAAcid,KAjBrC,CAAApgC,IAAA,iBAAAN,MAAA,SA+BQgjB,EACAof,EACAjf,EACAmf,EACAL,EACAC,GAEA,IAAM9X,EAAQ,IAAI8Y,GAAMjB,EAAUC,GAGlC,OAAQlf,GACJ,IAAK,kBACDA,EAAY,aACZ,MACJ,IAAK,OACDA,EAAY,cACZ,MA4BR,OAxBAoH,EAAMpH,UAAYF,GAAQ0kB,kBAAkBxkB,GAC5CoH,EAAM+X,cAAgBnf,EACtBoH,EAAMgY,YAAcA,EACpBhY,EAAMmY,OAASH,EACfhY,EAAMoY,UAAYJ,EAClBhY,EAAMjH,WAAaL,GAAQ2kB,2BAA2BtkB,GAIlDiH,EAAMjH,aAAexB,GAAWgB,OACZ,YAAhByf,GAA6C,cAAhBA,IAC7BhY,EAAMjH,WAAaxB,GAAWiB,YAGlCwH,EAAMjH,aAAexB,GAAW/V,UAChCwe,EAAMjH,WAAaxB,GAAWkB,MAEb,IAAjByf,EAAM5kC,SACN4kC,EAAQ,KAEZlY,EAAMkY,MAAQxf,GAAQU,YAAY8e,GAElClY,EAAMqa,aAECra,IA3Ef,CAAA9pB,IAAA,YAAAN,MAAA,SAoF4B0gC,GAAsC,IAAxB4G,EAAwB98B,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,IAAD,EACnDk9B,EAA8B,GAE9BC,EAAuBjH,EAAKnd,MAAM,KAHkBjG,GAAA,EAAAC,GAAA,EAAAC,OAAAhX,EAAA,IAI1D,QAAAiX,EAAAC,EAAAC,IAAyBgqB,KAAzBrqB,GAAAG,EAAAC,EAAA1B,QAAA4B,MAAAN,GAAA,EAA+C,KAApCra,EAAoCwa,EAAAzd,MACrC4nC,EAAuB3kC,EAAWsgB,MAAM,KAC9C,GAAoC,IAAhCqkB,EAAqBlqC,OAAzB,CAKA,IAAMiR,EAAOlN,KAAKomC,UAAUD,EAAqB,GAAIN,GAC/CQ,EAAShlB,GAAQW,cAAcmkB,EAAqB,IAC3C,IAAXE,EAIJJ,EAAY9pC,KAAK,CAAC+Q,EAAMm5B,IAHpB16B,QAAQusB,MAAR,sCAPAvsB,QAAQusB,MAAR,qCAAA11B,OAAmDhB,EAAnD,4CAPkD,MAAA4a,GAAAN,GAAA,EAAAC,EAAAK,EAAA,YAAAP,GAAA,MAAAI,EAAAI,QAAAJ,EAAAI,SAAA,WAAAP,EAAA,MAAAC,GAmB1D,OAAOkqB,IAvGf,CAAApnC,IAAA,aAAAN,MAAA,SAgH6B0gC,GAAsC,IAAxB4G,EAAwB98B,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,IAAD,EACpDu9B,EAAe,GAEfC,EAAyBtH,EAAKnd,MAAM,KAHiBtF,GAAA,EAAAC,GAAA,EAAAC,OAAA3X,EAAA,IAI3D,QAAA4X,EAAAC,EAAAV,IAAyBqqB,KAAzB/pB,GAAAG,EAAAC,EAAArC,QAAA4B,MAAAK,GAAA,EAAiD,KAAtChb,EAAsCmb,EAAApe,MACvCioC,EAAoBhlC,EAAWsgB,MAAM,KAC3C,GAAiC,IAA7B0kB,EAAkBvqC,OAAtB,CAKA,IAAMwqC,EAAazmC,KAAKomC,UAAUI,EAAkB,GAAIX,GAClDa,EAAgBrlB,GAAQW,cAAcwkB,EAAkB,IACxC,IAAlBE,EAIJJ,EAAanqC,KAAK,CAACsqC,EAAYC,IAH3B/6B,QAAQusB,MAAR,iDAPAvsB,QAAQusB,MAAR,sCAAA11B,OAAoDhB,EAApD,4CAPmD,MAAA4a,GAAAK,GAAA,EAAAC,EAAAN,EAAA,YAAAI,GAAA,MAAAI,EAAAP,QAAAO,EAAAP,SAAA,WAAAI,EAAA,MAAAC,GAmB3D,OAAO4pB,IAnIf,CAAAznC,IAAA,gBAAAN,MAAA,SA4IgCy/B,EAAiBiB,GAAsC,IAAxB4G,EAAwB98B,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,IAAD,EACxE49B,EAAwB1H,EAAKnd,MAAM,KADsCkO,GAAA,EAAAC,GAAA,EAAAC,OAAAnrB,EAAA,IAE/E,QAAAorB,EAAAC,EAAAlU,IAAyByqB,KAAzB3W,GAAAG,EAAAC,EAAA7V,QAAA4B,MAAA6T,GAAA,EAAgD,KAArCxuB,EAAqC2uB,EAAA5xB,MACtCqoC,EAAmBplC,EAAWsgB,MAAM,KAC1C,GAAgC,IAA5B8kB,EAAiB3qC,OAArB,CAMA,IAAMwqC,EAAazmC,KAAKomC,UAAUQ,EAAiB,GAAIf,GACjDa,EAAgBrlB,GAAQW,cAAc4kB,EAAiB,IACzDF,GAAiB,EACjB/6B,QAAQusB,MAAR,yCAAA11B,OAAuDikC,EAAvD,aAAAjkC,OAA6EkkC,EAA7E,eAGJ1I,EAAIpgB,WAAW,IAAI5J,GAAalI,GAAYsB,cAAcq5B,GAAaC,SAVnE/6B,QAAQusB,MAAR,uCAAA11B,OAAqDhB,EAArD,4CANuE,MAAA4a,GAAA6T,GAAA,EAAAC,EAAA9T,EAAA,YAAA4T,GAAA,MAAAI,EAAA/T,QAAA+T,EAAA/T,SAAA,WAAA4T,EAAA,MAAAC,MA5IvF,CAAArxB,IAAA,wBAAAN,MAAA,SAsKwCy/B,EAAiBiB,GAAsC,IAAxB4G,EAAwB98B,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,IAAD,EAChF89B,EAAM5H,EAAKnd,MAAM,KADgEmQ,GAAA,EAAAC,GAAA,EAAAC,OAAAptB,EAAA,IAEvF,QAAAqtB,EAAAC,EAAAnW,IAAiB2qB,KAAjB5U,GAAAG,EAAAC,EAAA9X,QAAA4B,MAAA8V,GAAA,EAAsB,KAAX6U,EAAW1U,EAAA7zB,MACZwoC,EAAMD,EAAGhlB,MAAM,KACrB,GAAIilB,EAAI9qC,OAAS,EACb0P,QAAQusB,MAAR,mDAAA11B,OAAiEukC,EAAI9qC,OAArE,yBADJ,CAKA,IAAMiR,EAAOlN,KAAKomC,UAAUW,EAAI,GAAIlB,GAC9BtzB,EAAY8O,GAAQU,YAAYglB,EAAI,IACpCv0B,EAAc6O,GAAQU,YAAYglB,EAAI,IAExC75B,EAAO,EACPvB,QAAQusB,MAAR,wDAAA11B,OAAsE0K,EAAtE,cAGAqF,EAAY,EAEZ5G,QAAQusB,MAAR,wDAAA11B,OAAsE0K,EAAtE,gBAAA1K,OAAyF+P,EAAzF,cAGAC,EAAc,EAEd7G,QAAQusB,MAAR,wDAAA11B,OAAsE0K,EAAtE,kBAAA1K,OAA2FgQ,EAA3F,cAIJwrB,EAAIpgB,WAAW,IAAIzL,GAAqBrG,GAAYsB,cAAcF,GAAOqF,EAAWC,MA5BD,MAAA4J,GAAA8V,GAAA,EAAAC,EAAA/V,EAAA,YAAA6V,GAAA,MAAAI,EAAAhW,QAAAgW,EAAAhW,SAAA,WAAA6V,EAAA,MAAAC,MAtK/F,CAAAtzB,IAAA,oBAAAN,MAAA,SA4MoCy/B,EAAiBiB,GAAsC,IAAxB4G,EAAwB98B,UAAA9M,OAAA,QAAA8I,IAAAgE,UAAA,GAAAA,UAAA,IAAD,EAC5Ei+B,EAA4B/H,EAAKnd,MAAM,KADsC8Q,GAAA,EAAAC,GAAA,EAAAC,OAAA/tB,EAAA,IAEnF,QAAAguB,EAAAC,EAAA9W,IAAyB8qB,KAAzBpU,GAAAG,EAAAC,EAAAzY,QAAA4B,MAAAyW,GAAA,EAAoD,KAAzCpxB,EAAyCuxB,EAAAx0B,MAC1C0oC,EAAuBzlC,EAAWsgB,MAAM,KAC9C,GAAoC,IAAhCmlB,EAAqBhrC,OAAzB,CAMA,IAAMirC,EAAgBlnC,KAAKomC,UAAUa,EAAqB,GAAIpB,GAGxDj0B,EAAQ4Q,KAASykB,EAAqB,GAAI,IAChD,IAAIxkB,MAAM7Q,GAAV,CAGqByP,GAAQ8lB,MAAMv1B,EAAO,EAAG1F,IAC7C8xB,EAAIpgB,WAAW,IAAIpM,GAAiB1F,GAAYsB,cAAc85B,GAAgBt1B,UAZ1EjG,QAAQusB,MAAR,2CAAA11B,OAAyDhB,EAAzD,4CAN2E,MAAA4a,GAAAyW,GAAA,EAAAC,EAAA1W,EAAA,YAAAwW,GAAA,MAAAI,EAAA3W,QAAA2W,EAAA3W,SAAA,WAAAwW,EAAA,MAAAC,MA5M3F,CAAAj0B,IAAA,sBAAAN,MAAA,SAwOsCy/B,EAAiB/nB,EAAsBE,GAOrE,IAAIjD,EAAM,EAENk0B,EAAW,EAEXC,GAAa,EACbC,GAAW,EAEXC,EAAa,EAEbC,EAAU,EAORC,EAAe,SAAChkC,EAA8Bw3B,GAA/B,OAAwEx3B,EAAE,GAAKw3B,EAAE,IACtGhlB,EAAK2jB,KAAK6N,GACVtxB,EAAMyjB,KAAK6N,GAQX,IAAIC,EAAY,EACVC,EAAUxxB,EAAMla,OAlCoEg3B,GAAA,EAAAC,GAAA,EAAAC,OAAApuB,EAAA,IAmC1F,QAAAquB,EAAAC,EAAAnX,IAAuB/F,KAAvB8c,GAAAG,EAAAC,EAAA9Y,QAAA4B,MAAA8W,GAAA,EAA8B,KAAnB2U,EAAmBxU,EAAA70B,MAC1B,GAAIqpC,EAAS,IAAM,EACf,MAEJ5J,EAAI6J,cAAcD,EAAS,IAC3BF,KAxCsF,MAAAtrB,GAAA8W,GAAA,EAAAC,EAAA/W,EAAA,YAAA6W,GAAA,MAAAI,EAAAhX,QAAAgX,EAAAhX,SAAA,WAAA6W,EAAA,MAAAC,GA+C1F,IAAI2U,EAAW,EACTC,EAAS9xB,EAAKha,OAhDsEs3B,GAAA,EAAAC,GAAA,EAAAC,OAAA1uB,EAAA,IAiD1F,QAAA2uB,EAAAC,EAAAzX,IAAsBjG,KAAtBsd,GAAAG,EAAAC,EAAApZ,QAAA4B,MAAAoX,GAAA,EAA4B,KAAjByU,EAAiBtU,EAAAn1B,MACxB,GAAIypC,EAAQ,IAAM,EACd,MAEJ90B,EAAM80B,EAAQ,GACV90B,EAAM,GAAK80B,EAAQ,GAAK,GACxBr8B,QAAQC,MAAM,gFAElBk8B,KAzDsF,MAAA1rB,GAAAoX,GAAA,EAAAC,EAAArX,EAAA,YAAAmX,GAAA,MAAAI,EAAAtX,QAAAsX,EAAAtX,SAAA,WAAAmX,EAAA,MAAAC,GA6D9E,IAARvgB,IAEI40B,IAAaC,GAEb70B,EAAM,GACNvH,QAAQC,MAAM,mDAGdsH,EAAM+C,EAAK6xB,GAAU,GACrBA,IACAn8B,QAAQC,MAAM,+FAMlBsH,EAAM,GAAKA,GAAOgwB,IAClBlF,EAAIpgB,WAAW,IAAI9K,GAAWhH,GAAYsB,cAAc,GAAI8F,IAIhE,MAAO40B,EAAWC,GAAUL,EAAYC,EAAS,CAG7C,IAAMM,EAAeP,IAAcC,GAC9BG,EAAWC,GAAU9xB,EAAK6xB,GAAU,IAAM3xB,EAAMuxB,GAAW,GAC1D7Q,EAASoR,EAAchyB,EAAK6xB,GAAY3xB,EAAMuxB,GAKhDx0B,GAAOgwB,KACPsE,GAAoC,IAAxB3Q,EAAO,GAAKuQ,GAAiBl0B,EAIrCm0B,GAAa,GAAKn0B,EAAM,GAAKs0B,EAAU,IAEvCF,EAAUzQ,EAAO,GAAM2Q,EAAUt0B,EAAM,GAEvC8qB,EAAIpgB,WAAW,IAAI3N,GAAYnE,GAAYsB,cAAci6B,GACrDC,EAAUD,GAAW,IAIrBn0B,IAAQq0B,GACRvJ,EAAIpgB,WAAW,IAAI9K,GAAWhH,GAAYsB,cAAci6B,GAAYn0B,IAGxEm0B,GAAa,IAKrBD,EAAWvQ,EAAO,GAGdoR,GAEIZ,EAAY,IAAMxQ,EAAO,GAAK,GAAKA,EAAO,GAAKqM,KAE/CmE,EAAYxQ,EAAO,GACnB0Q,EAAar0B,EACbs0B,EAAU,GACHH,EAAY,GAGnBrJ,EAAIpgB,WAAW,IAAI9K,GAAWhH,GAAYsB,cAAcypB,EAAO,IAAKA,EAAO,KAE/E3jB,EAAM2jB,EAAO,GACbiR,MAGIT,EAAY,GAAKxQ,EAAO,GAAK,GAE7BwQ,EAAYxQ,EAAO,GACnB0Q,EAAar0B,EACbs0B,EAAU3Q,EAAO,IACVwQ,EAAY,EAGnBrJ,EAAIpgB,WAAW,IAAIrK,GAAYzH,GAAYsB,cAAcypB,EAAO,IAAKA,EAAO,MAI5E2Q,GAAW3Q,EAAO,GAKdA,EAAO,GAAK,GAAK2Q,EAAU,IAC3BF,EAAUzQ,EAAO,GAEjBmH,EAAIpgB,WAAW,IAAI3N,GAAYnE,GAAYsB,cAAci6B,GACrDC,EAAUD,GAAW,IACzBrJ,EAAIpgB,WAAW,IAAIrK,GAAYzH,GAAYsB,cAAcypB,EAAO,IAAK2Q,IAIjEt0B,EAAM,GAAKA,EAAMgwB,IAEjBmE,EAAYxQ,EAAO,GAEnB2Q,EAAU,IAKNt0B,IAAQq0B,GAERvJ,EAAIpgB,WAAW,IAAI3N,GAAYnE,GAAYsB,cAAci6B,GAAYn0B,GAAK,IAE9Em0B,GAAa,KAIzBK,KAMJL,GAAa,IAMTC,EAJAp0B,EAAM,GAAKA,EAAMgwB,GAIP,SAGAkE,EAAYI,EAAUt0B,EAAM,GAG1C8qB,EAAIpgB,WAAW,IAAI3N,GAAYnE,GAAYsB,cAAci6B,GACpDC,EAAUD,GAAW,IAGtBn0B,IAAQq0B,GACRvJ,EAAIpgB,WAAW,IAAI9K,GAAWhH,GAAYsB,cAAci6B,GAAYn0B,OAhbpF,CAAArU,IAAA,kBAAAN,MAAA,SA0bkC2pC,GAU1B,IATA,IAAMzH,EAAO,IAAIwC,GAEXkF,EAA8B,CAChC1H,OACA4C,OAAQ,GACRe,WAAY,GACZjuB,MAAO,IAGFpa,EAAI,EAAGA,EAAImsC,EAAQE,eAAgBrsC,IAAK,CAC7C,IAAMssC,EAAYH,EAAQI,aAAavsC,GACjCsnC,EAAS6E,EAAQK,SAASxsC,GAC1BysC,EAAYnF,EAAO,GAAGoF,cAC5BN,EAAe9E,OAASA,EAExB,IAAMqF,EAAU/C,GAAgBxnC,IAAIqqC,GACpC,QAAgBzjC,IAAZ2jC,EACAA,EAAQP,QAEL,GAAkB,UAAdK,GAAuC,WAAdA,EAAwB,CACxD,GAAIH,EAAY,EACZ,MAAM,IAAI9lC,MAAJ,gBAAAC,OAA0B6lC,EAA1B,yDAGV,IAAM1f,EAAQ3oB,KAAK2oC,eACftF,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACPA,EAAO,GACP5C,GAEJ9X,EAAMigB,aACNnI,EAAKoI,SAASlgB,IAGtB,IAAK8X,EAAKqI,WACN,MAAM,IAAIvmC,MAAM,mCAkBpB,OAdAvC,KAAK+oC,oBAAoBtI,EAAK9a,WAAYwiB,EAAe/D,WAAY+D,EAAehyB,OAIpFnW,KAAKgjC,aAGLvC,EAAKuC,aAOEvC,IAlff,CAAA5hC,IAAA,aAAAN,MAAA,gBAAAqnC,EAAA,GAgjBeoD,GAAA,GC7uBFC,GAAb,WAII,SAAAC,EAAYztC,GAAYW,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAkpC,GAFhBlpC,KAAA+5B,OAAqB,GAGzB/5B,KAAKmpC,WAAW1tC,GAAM,GAL9B,OAAAW,OAAA2K,EAAA,KAAA3K,CAAA8sC,EAAA,EAAArqC,IAAA,WAAAN,MAAA,SASoB6qC,EAAoBC,GAChC,OAAOrpC,KAAK+5B,OAAOqP,GAAYC,KAVvC,CAAAxqC,IAAA,WAAAN,MAAA,SAcoB6qC,GACZ,OAAOppC,KAAK+5B,OAAOqP,KAf3B,CAAAvqC,IAAA,eAAAN,MAAA,WAmBQ,OAAOyB,KAAK+5B,OAAO99B,SAnB3B,CAAA4C,IAAA,eAAAN,MAAA,SAsBwB6qC,GAChB,OAAOppC,KAAK+5B,OAAOqP,GAAYntC,SAvBvC,CAAA4C,IAAA,aAAAN,MAAA,SA4BuB+qC,EAAaC,GAC5B,IAAIC,GAAwB,EACxBztC,EAAY,EACZ0tC,EAAyB,GAE7B,MAAO1tC,EAAIutC,EAAIrtC,OAEX,GAAIF,EAAI,EAAIutC,EAAIrtC,QAAqB,MAAXqtC,EAAIvtC,IAA6B,OAAfutC,EAAIvtC,EAAI,GAChD,GACIA,UAEGA,EAAIutC,EAAIrtC,QAAqB,OAAXqtC,EAAIvtC,SAQ5BytC,GAA2B,MAAXF,EAAIvtC,KACrBiE,KAAK0pC,WACLF,GAAe,GAGdA,GAWU,MAAXF,EAAIvtC,IAAyB,MAAXutC,EAAIvtC,IACtBiE,KAAK2pC,SAASF,GAIH,MAAXH,EAAIvtC,IAAyB,MAAXutC,EAAIvtC,GAOX,MAAXutC,EAAIvtC,IASJwtC,GAAYxtC,EAAIutC,EAAIrtC,QAAqB,OAAXqtC,EAAIvtC,MAChCA,EAEFA,EAAIutC,EAAIrtC,QACRwtC,EAAattC,KAAKmtC,EAAIvtC,QAZtBytC,GAAe,IACbztC,MARAA,EACF0tC,EAAe,KAjBXF,GAAuB,OAAXD,EAAIvtC,GAChBA,GAAK,IAEHA,EAqCVytC,GACAxpC,KAAK2pC,SAASF,KA9F1B,CAAA5qC,IAAA,WAAAN,MAAA,SAmGqBqrC,GACb5pC,KAAK+5B,OAAO/5B,KAAK+5B,OAAO99B,OAAS,GAAGE,KAAMytC,EAAMC,KAAK,IAAIlL,UApGjE,CAAA9/B,IAAA,WAAAN,MAAA,WAyGQyB,KAAK+5B,OAAO59B,KAAK,QAzGzB+sC,EAAA,GA4GeY,GAAA,GCpETC,GAA0B,2DAE1BC,GAAmB5tC,OAAA,CAAA6tC,SAAA,aAAAC,SAAA,qBAAYC,yBAA2BJ,GAC1DK,GAAsBhuC,OAAA,CAAA6tC,SAAA,aAAAC,SAAA,qBAAYG,6BAA+B,aACjEC,GAAyB,CAACxsC,KAAM,mBAAoBysC,YAAa,GAAIC,YAAa,IAWlFC,GAAN,SAAAhV,GADA,SAAAiV,IAAA,IAAA7iC,EAAA,OAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA0qC,kEAES7iC,EAAAmvB,aAAe,UACfnvB,EAAA4uB,MAAgB,CACrB,CACE34B,KAAM,UACNm5B,OAAQ,KAILpvB,EAAAsvB,cAAgB,UAChBtvB,EAAAovB,OAAkB,CACvB,CACEn5B,KAAM,UACNysC,YAAa,UACbC,YAAa,YAIV3iC,EAAA0hB,eAAyB,EACzB1hB,EAAA8gB,MAAiB,GApB1B9gB,EACA,OAAAzL,OAAAmU,EAAA,KAAAnU,CAAAsuC,EAAAjV,GAAAr5B,OAAA2K,EAAA,KAAA3K,CAAAsuC,EAAA,EAAA7rC,IAAA,UAAAN,MAAA,WAsBI,MAAO,KAtBX,CAAAM,IAAA,UAAAN,MAAA,WAyBgB,IAAAoT,EAAA3R,KAEZ43B,GAAAn0B,EAAMtF,IAAN,GAAAqE,OAAa,oBAAbA,OAAoC4nC,KAAuBtS,KAAK,SAACC,GAC/DpmB,EAAK8kB,MAAQsB,EAASt8B,KAEtBkW,EAAK8kB,MAAMvvB,QAAQ,SAACyjC,GAClBA,EAAK1T,OAAO2T,QAAQN,MAGtB34B,EAAKqlB,aAAerlB,EAAK8kB,MAAM,GAAG34B,KAElC6T,EAAKslB,OAAStlB,EAAK8kB,MAAM,GAAGQ,OAC5BtlB,EAAKwlB,cAAgBmT,GAAuBxsC,OAC3C+sC,MAAM,SAAC3S,GACRvsB,QAAQusB,MAAR,qCAAA11B,OAAmD01B,QAvCzD,CAAAr5B,IAAA,WAAAN,MAAA,SA2CmBT,GACf,IAAMgtC,EAAY9qC,KAAKy2B,MAAMsU,KAAK,SAACJ,GAAD,OAAUA,EAAK7sC,OAASA,IAC1D,QAAkBiH,IAAd+lC,EACF,MAAM,IAAIvoC,MAAJ,iCAAAC,OAA2C1E,IAEnD,OAAOgtC,IAhDX,CAAAjsC,IAAA,YAAAN,MAAA,SAmDoBT,GAChB,IAAMktC,EAAahrC,KAAKi3B,OAAO8T,KAAK,SAACE,GAAD,OAAWA,EAAMntC,OAASA,IAC9D,QAAmBiH,IAAfimC,EACF,MAAM,IAAIzoC,MAAJ,kCAAAC,OAA4C1E,IAEpD,OAAOktC,IAxDX,CAAAnsC,IAAA,kBAAAN,MAAA,SA2D0B2sC,GACtBlrC,KAAKi3B,OAASj3B,KAAKmrC,SAASnrC,KAAKg3B,cAAcC,OAC/Cj3B,KAAKm3B,cAAgBn3B,KAAKi3B,OAAO,GAAGn5B,OA7DxC,CAAAe,IAAA,mBAAAN,MAAA,SAgE2B2sC,GACvB,IAAME,EAAWprC,KAAKg3B,aAChBiU,EAAQjrC,KAAKqrC,UAAUrrC,KAAKm3B,eAElC,GAAI8T,IAAUX,GAAd,CAEA,IAAMgB,EAA4B,OAAtBL,EAAMV,YAAuB,KACvC,GAAA/nC,OAAG+oC,mBAAmBH,GAAtB,KAAA5oC,OAAmC+oC,mBAAmBN,EAAMntC,MAA5D,QAAA0E,OACG+oC,mBAAmBN,EAAMV,cACxBiB,EAAU,GAAAhpC,OAAG+oC,mBAAmBH,GAAtB,KAAA5oC,OAAmC+oC,mBAAmBN,EAAMntC,OAA5D,IAAA0E,OACI+oC,mBAAmBN,EAAMT,cACvCiB,EAAkB,CAACH,MAAKE,WAC9BxrC,KAAK0rC,YAAYD,GAEjBzrC,KAAK2rC,MAAM,cAAeF,MA9E9B,CAAA5sC,IAAA,mBAAAN,MAAA,SAiF2B2sC,GACvB,IAAMU,EAAa5rC,KAAKupB,cAKxB,GAAmB,OAAfqiB,QACsB7mC,IAAtBygB,GAAUC,QAAd,CAEA,IAAMkD,EAAQ3oB,KAAK2oB,MAAMijB,GACzBpmB,GAAU+D,cAAgB/D,GAAUC,QAAQomB,cAAcjR,QAAQjS,GAElE3oB,KAAK2rC,MAAM,cAAehjB,MA7F9B,CAAA9pB,IAAA,mBAAAN,MAAA,SAgG2B6Z,GACvB,SAAA5V,OAAU4V,EAAKyoB,MAAf,OAAAr+B,OAA0B4V,EAAKuoB,eAjGnC,CAAA9hC,IAAA,oBAAAN,MAAA,SAmG4B6Z,GAAe,OAAOpY,KAAK2oB,MAAMiS,QAAQxiB,KAnGrE,CAAAvZ,IAAA,cAAAN,MAAA,SAyGsBktC,GAAe,IAG7B7hB,EAH6BtX,EAAAtS,KACjC,GAAiB,OAAbyrC,EAAKH,IAAgB,MAAM,IAAI/oC,MAAM,6BAGzC,IAeIupC,EAfEC,EAAc,GAAAvpC,OAAMwnC,GAAN,UAAAxnC,OAA+BipC,EAAKD,SAClDQ,EAAK7S,GAAe8S,aAAaF,GACpCjU,KAAK,SAACoU,GACL,IAAMhE,EAAU,IAAI4B,GAAQoC,GAC5BtiB,EAAUof,GAAamD,gBAAgBjE,GACvCv8B,QAAQya,IAAI,kBAGZ9T,EAAKqW,MAAQiB,EAAQiiB,cACrBv5B,EAAKiX,cAAgB,IAEtBshB,MAAM,SAAC3S,GACNvsB,QAAQusB,MAAR,+BAAA11B,OAA6CupC,EAA7C,OAAAvpC,OAAiE01B,MAI/DkU,EAAe,GAAA5pC,OAAMwnC,GAAN,UAAAxnC,OAA+BipC,EAAKH,KACnDe,EAAKlT,GAAemT,kBAAkBF,GAAiB,GAC1DtU,KAAK,SAACyU,GACLT,EAAUS,EACV5gC,QAAQya,IAAI,kBAEbykB,MAAM,SAAC3S,GACNvsB,QAAQusB,MAAR,gCAAA11B,OAA8C4pC,EAA9C,OAAA5pC,OAAmE01B,MAIvES,GAAAl1B,EAAQ+oC,IAAI,CAACR,EAAIK,IACdvU,KAAK,WACJ,GAAgB,OAAZlO,EAAoB,MAAM,IAAIrnB,MAAM,8BACxC,GAAgB,OAAZupC,EAAoB,MAAM,IAAIvpC,MAAM,8BACxCijB,GAAUinB,SAAS7iB,EAASkiB,EAASx5B,EAAKo6B,MAAMprC,QAEjDupC,MAAM,SAAC3S,GACNvsB,QAAQusB,MAAR,kCAAA11B,OAAgD01B,MAEpDvsB,QAAQya,IAAI,kBAAqBqlB,EAAKH,SAjJ1CZ,EAAA,CAA0BjrC,EAAA,YAApBgrC,GAAW1U,EAAA,MADhBC,EAAA,MACKyU,IAoJS,IAAAkC,GAAA,GC7MuaC,GAAA,wCCOlbC,GAAYzwC,OAAAi6B,GAAA,KAAAj6B,CACdwwC,GACArW,GACAgB,IACF,EACA,KACA,WACA,MAIeuV,GAAAD,GAAiB,QAKhCE,KAAkBF,GAAS,CAAGG,WAAA,mCCjBjBC,GAAb,oBAAAC,IAAA9wC,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAAktC,GAAA,OAAA9wC,OAAA2K,EAAA,KAAA3K,CAAA8wC,EAAA,OAAAruC,IAAA,YAAAN,MAAA,WAQQ,IAAM4uC,GAAY,EACZC,GAAO,EAIP9gC,EAAWkZ,GAAUlZ,SACrBwb,EAAkBxb,EAASgR,aAM3BmjB,EAAOjb,GAAUC,QACvB,QAAa1gB,IAAT07B,EAAJ,CACA,IAAM3c,EAAS2c,EAAK9a,WACdoM,EAAK0O,EAAKnV,SAAS9F,GAAU+D,eAAeyI,cAG5C3U,EAAWyG,EAAOoE,+BAA+BJ,GACjDulB,EAAU3jC,KAAKkS,IAAI,EAAGvO,GAAYwY,wBAAwBxI,IAKhE,GAJIgwB,EAAUH,EAAaI,iBACvBttC,KAAKstC,eAAiBD,GAGtBD,EAAM,CACN,IAAIG,GAAW,EAKT3sC,EAAM,CAACrC,MAAO,GAMpB,GALAk9B,GAAsC1J,EAAInxB,EAAKZ,KAAKstC,eAAiB,EAAGD,EAAU,EAAG,SAACjvC,GAC9E2zB,EAAGyb,2BAA2BpvC,EAAEG,SAChCgvC,EAAUnvC,EAAEG,UAGH,IAAbgvC,GAAkBzpB,EAAO/J,gBAAgBwzB,GAAU,CACnD,IAAME,EAAWpgC,GAAYoC,cAAc89B,GACrCG,EAAa5pB,EAAO3G,+BAA+BswB,GACvBnhC,EAASgR,aAI3Ctd,KAAK2tC,UAAU/jC,QAIvB,GAAIujC,IAAsC,IAAzBntC,KAAKstC,eAAuB,CACzC,IAAMM,EAA0B,CAACrvC,MAAO,GAClCsvC,EAAuB,CAACtvC,MAAO,GAC/BuvC,EAA2B,CAACvvC,MAAO,GACzCulB,EAAOiqB,wBAAwBb,EAAaI,eAAgBM,EACxDC,EAAsBC,GAE1B,IAAME,EAAsB,CAACzvC,MAAO,GAC9B0vC,EAAmB,CAAC1vC,MAAO,GAC3B2vC,EAAuB,CAAC3vC,MAAO,GACrCulB,EAAOiqB,wBAAwBV,EAASW,EACpCC,EAAkBC,GAEtB,IAAIC,GAAgB,EAChBC,GAAiB,EASrB,GANIR,EAAwBrvC,QAAUyvC,EAAoBzvC,OACtDsvC,EAAqBtvC,QAAU0vC,EAAiB1vC,QAC5C4vC,EAAed,EAAUa,EAAqB3vC,MAC9C6vC,EAAiBJ,EAAoBzvC,MAAQqvC,EAAwBrvC,MAAQ,IAG/D,IAAlB4vC,EAAqB,CACrB,IAAME,EAAWhhC,GAAYoC,cAAc0+B,GACrCG,EAAaxqB,EAAO3G,+BAA+BkxB,GACvB/hC,EAASgR,aAIvC8wB,EACAziC,QAAQya,IAAI,qBAEZza,QAAQya,IAAI,mBAIxB8mB,EAAaI,eAAiBD,OA5FtCH,EAAA,GACkBD,GAAAK,gBAAkB,EAClBL,GAAAU,UAAY,IAAIvV,GAAA,QAAK,CAC/BC,IAAK,CAACkW,GAAA9qC,GACN+qC,OAAQ,KA2FD,IAAAC,GAAA,GC9FFC,GAAiB,IAAI3uB,GAG5B4uB,+GAIqBC,GAKnBC,EAASC,cACT,IAAM7nC,EAAYynC,GAAeK,eACjCF,EAASG,WAAa/nC,EAClB4nC,EAASG,UAAY,IACrBH,EAASG,UAAY,EACrBH,EAASC,YAAc,GAI3BxoB,GAASnf,OAAOF,GAEhBue,GAAUre,OAAOF,GACjBwnC,GAAaQ,YAEThqC,GAAUiqC,kBAAoBlvC,KAAKmvC,aAEnClqC,GAAUmqC,gBAEVpvC,KAAKmvC,YAAa,GAGtB9nC,GAAUF,OAAOF,YA7BP0nC,GAAAQ,YAAa,EACbR,GAAAG,YAAc,EACdH,GAAAK,UAAY,EAiCf,IAAAK,GAAA,ICaf,WACE,SAASC,IACUlwC,OAAOmwC,sBAAuBD,GAG/CD,GAASG,SAAS,GAGpBF,KARF,GAoBAlwC,OAAOqwC,WAAa7oB,GACpBxnB,OAAOurB,UAAYnF,GACnBpmB,OAAOinB,SAAWC,GAUlB,IAAMopB,GAAN,SAAAja,GAPA,SAAAka,IAAA,IAAA9nC,EAAA,OAAAzL,OAAAsI,EAAA,KAAAtI,CAAA4D,KAAA2vC,kEAQS9nC,EAAAvG,KAAO,EARhBuG,EAOA,OAAAzL,OAAAmU,EAAA,KAAAnU,CAAAuzC,EAAAla,GAAAr5B,OAAA2K,EAAA,KAAA3K,CAAAuzC,EAAA,EAAA9wC,IAAA,YAAAN,MAAA,WAII+nB,GAASspB,UAAU5vC,KAAK0sC,MAAMprC,QAJlC,CAAAzC,IAAA,iBAAAN,MAAA,WAQSinB,GAAUqqB,YAIbrqB,GAAU5b,OACV0c,GAASS,gBAJTvB,GAAU1R,QACVwS,GAASQ,kBAVf6oB,EAAA,CAAkBlwC,EAAA,YAAZiwC,GAAG3Z,EAAA,MAPR35B,OAAA45B,EAAA,KAAA55B,CAAU,CACT0B,KAAM,MACNgyC,WAAY,CACVpa,OAAAY,GACAoU,YAAAoC,OAGE4C,IAiBS,IAAAK,GAAA,GC5G0YC,GAAA,qICOrZC,GAAY7zC,OAAAi6B,GAAA,KAAAj6B,CACd4zC,GACAlwC,EACA2B,GACF,EACA,KACA,KACA,MAIeyuC,GAAAD,GAAiB,QAchClD,KAAkBkD,GAAS,CAAGE,QAAA,KAAKC,QAAA,KAAKC,cAAA,KAAWC,YAAA,KAASC,SAAA,KAAMC,WAAA,KAAQC,QAAAC,GAAA,KAAQC,cAAA,KAAWC,YAAA,KAASC,cAAAC,GAAA,OC5BtGrxC,EAAA,WAAIsxC,OAAOC,eAAgB,EAE3B,IAAIvxC,EAAA,WAAI,CACNwxC,OAAQ,SAACruB,GAAD,OAAOA,EAAEstB,OAChBgB,OAAO,8BCRVzzC,EAAAD,QAAiBJ,EAAA8B,EAAuB","file":"js/app.526bc4b7.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/simfile-viewer/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = __webpack_public_path__ + \"img/_Down_Tap_Note_16x8.884d6e62.png\";","module.exports = __webpack_public_path__ + \"img/Down_Hold_Body_Active.adc2d5a2.png\";","module.exports = __webpack_public_path__ + \"img/Down_Hold_Body_Inactive.623b36a7.png\";","module.exports = \"data:image/png;base64,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\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=style&index=0&id=1165683c&scoped=true&lang=css&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=style&index=0&id=1165683c&scoped=true&lang=css&\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"img/Fallback_Tap_Mine_8x1.47690a50.png\";","module.exports = __webpack_public_path__ + \"img/_Down_Receptor_Go_4x1.6a5930ce.png\";","module.exports = __webpack_public_path__ + \"img/Down_Roll_Body_Inactive.a6ed17c5.png\";","import Vue from 'vue';\r\nimport Vuetify from 'vuetify/lib';\r\nimport 'vuetify/src/stylus/app.styl';\r\n\r\nVue.use(Vuetify, {\r\n  iconfont: 'md',\r\n});\r\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-app',{attrs:{\"dark\":\"\"}},[_c('v-toolbar',{attrs:{\"app\":\"\"}},[_c('v-toolbar-title',{staticClass:\"headline text-uppercase\"},[_c('span',[_vm._v(\"Vuetify\")]),_c('span',{staticClass:\"font-weight-light\"},[_vm._v(\"MATERIAL DESIGN\")])]),_c('v-spacer'),_c('v-btn',{attrs:{\"flat\":\"\",\"href\":\"https://github.com/vuetifyjs/vuetify/releases/latest\",\"target\":\"_blank\"}},[_c('span',{staticClass:\"mr-2\"},[_vm._v(\"Latest Release\")])])],1),_c('v-content',[_c('v-container',[_c('v-layout',{attrs:{\"row\":\"\"}},[_c('v-flex',{attrs:{\"md6\":\"\"}},[_c('screen')],1),_c('v-flex',{attrs:{\"md6\":\"\"}},[_c('chart-picker')],1)],1),_c('v-flex',[_c('v-btn',{on:{\"click\":_vm.playPauseTrack}},[_vm._v(\"Play/Pause\")]),_c('v-btn',{on:{\"click\":_vm.seekTrack}},[_vm._v(\"Seek\")]),_c('v-text-field',{attrs:{\"type\":\"number\"},model:{value:(_vm.seek),callback:function ($$v) {_vm.seek=_vm._n($$v)},expression:\"seek\"}})],1)],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/** The width of a tap note sprite before any scaling. */\r\nexport const TAPNOTE_WIDTH_PX = 64;\r\n/** The height of a tap note sprite before any scaling. */\r\nexport const TAPNOTE_HEIGHT_PX = 64;\r\n/** The height of a hold note bottom cap before any scaling. */\r\nexport const HOLD_BOTTOM_CAP_HEIGHT_PX = 32;\r\n\r\n/** Tap note directions in rotation order from the down arrow. */\r\nexport enum TapNoteDirection {\r\n    DOWN,\r\n    LEFT,\r\n    UP,\r\n    RIGHT,\r\n}\r\n/** Translation function from direction index to lane index. */\r\nexport function directionToLaneIndex(direction: TapNoteDirection) {\r\n    switch (direction) {\r\n        case TapNoteDirection.DOWN: return 1;\r\n        case TapNoteDirection.LEFT: return 0;\r\n        case TapNoteDirection.UP: return 2;\r\n        case TapNoteDirection.RIGHT: return 3;\r\n        default: throw new Error(`unknown TapNoteDirection: ${direction}`);\r\n    }\r\n}\r\nexport function laneIndexToDirection(laneIndex: number) {\r\n    switch (laneIndex) {\r\n        case 0: return 1;\r\n        case 1: return 0;\r\n        case 2:\r\n        case 3:\r\n            return laneIndex;\r\n        default: throw new Error(`unknown laneIndex: ${laneIndex}`);\r\n    }\r\n}\r\n\r\n/** The margin on each side of the lane outside of the note tracks. */\r\nexport const LANE_MARGIN = 64;\r\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"pixi-renderer\"},[_c('canvas',{ref:\"renderCanvas\"}),_vm._t(\"default\")],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","// Player number stuff\r\nexport enum PlayerNumber {\r\n    PLAYER_1 = 0,\r\n    PLAYER_2,\r\n    NUM,\t// leave this at the end\r\n    Invalid,\r\n}\r\nexport const NUM_PLAYERS = PlayerNumber.NUM;\r\nexport const PLAYER_INVALID = PlayerNumber.Invalid;\r\n","import * as PIXI from 'pixi.js-legacy';\r\nimport { TAPNOTE_WIDTH_PX, TAPNOTE_HEIGHT_PX, HOLD_BOTTOM_CAP_HEIGHT_PX } from './entities/EntitiesConstants';\r\nimport SCREENMAN from './ScreenManager';\r\n\r\n// Images used for sprites\r\n// Tap notes\r\nimport DownReceptor from '@/assets/noteskins/USWCelETT/_Down_Receptor_Go_4x1.png';\r\nimport DownTapNote from '@/assets/noteskins/USWCelETT/_Down_Tap_Note_16x8.png';\r\nimport TapMine from '@/assets/noteskins/common/Fallback_Tap_Mine_8x1.png';\r\n// Holds\r\nimport DownHoldBodyActive from '@/assets/noteskins/USWCelETT/Down_Hold_Body_Active.png';\r\nimport DownHoldBodyInactive from '@/assets/noteskins/USWCelETT/Down_Hold_Body_Inactive.png';\r\nimport DownHoldBottomCapActive from '@/assets/noteskins/USWCelETT/Down_Hold_BottomCap_active.png';\r\nimport DownHoldBottomCapInactive from '@/assets/noteskins/USWCelETT/Down_Hold_BottomCap_inactive.png';\r\n// Rolls\r\nimport DownRollBodyActive from '@/assets/noteskins/USWCelETT/_Down_Roll_Body_active_4x1.png';\r\nimport DownRollBodyInactive from '@/assets/noteskins/USWCelETT/Down_Roll_Body_Inactive.png';\r\nimport DownRollBottomCapActive from '@/assets/noteskins/USWCelETT/_Down_Roll_BottomCap_active_4x1.png';\r\nimport DownRollBottomCapInactive from '@/assets/noteskins/USWCelETT/Down_Roll_BottomCap_Inactive.png';\r\n\r\ninterface LoadSpriteInfo {\r\n    name: string;\r\n    textureUrl: string;\r\n    width: number;\r\n    height: number;\r\n    numSprites: number;\r\n    numAnimFrames: number;\r\n    animLength: number; // number of frames before advancing to the next anim sprite\r\n    animLoop: boolean;\r\n}\r\n\r\nexport interface GameSpriteInfo {\r\n    name: string;\r\n    width: number;\r\n    height: number;\r\n    animLength: number;\r\n    animLoop: boolean;\r\n    textures: PIXI.Texture[][]; // sprites can have sub-sprites (i.e. all the arrow colours)\r\n}\r\n\r\n// Tap note resources\r\nexport const DOWN_TAP_NOTE_SHEET_NAME = 'DownTapNoteSheet';\r\nexport const DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME = 'DownReceptorSheet';\r\nexport const TAP_MINE_SHEET_NAME = 'TapMineSheet';\r\n\r\n// Hold note resources\r\nexport const DOWN_HOLD_BODY_ACTIVE_SHEET_NAME = 'DownHoldBodyActiveSheet';\r\nexport const DOWN_HOLD_BODY_INACTIVE_SHEET_NAME = 'DownHoldBodyInactiveSheet';\r\nexport const DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME = 'DownHoldBottomCapActiveSheet';\r\nexport const DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME = 'DownHoldBottomCapInactiveSheet';\r\n\r\n// Roll note resources\r\nexport const DOWN_ROLL_BODY_ACTIVE_SHEET_NAME = 'DownRollBodyActiveSheet';\r\nexport const DOWN_ROLL_BODY_INACTIVE_SHEET_NAME = 'DownRollBodyInactiveSheet';\r\nexport const DOWN_ROLL_BOTTOM_CAP_ACTIVE_SHEET_NAME = 'DownRollBottomCapActiveSheet';\r\nexport const DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME = 'DownRollBottomCapInactiveSheet';\r\n\r\n/** List of all the textures we need to load. */\r\nconst SPRITE_DEFINITIONS: LoadSpriteInfo[] = [\r\n    // Tap notes\r\n    {\r\n        name: DOWN_TAP_NOTE_SHEET_NAME,\r\n        textureUrl: DownTapNote,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: TAPNOTE_HEIGHT_PX,\r\n        numSprites: 8,\r\n        numAnimFrames: 16,\r\n        animLength: 2,\r\n        animLoop: true,\r\n    },\r\n    {\r\n        name: DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME,\r\n        textureUrl: DownReceptor,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: TAPNOTE_HEIGHT_PX,\r\n        numSprites: 1,\r\n        numAnimFrames: 4,\r\n        animLength: 30,\r\n        animLoop: true,\r\n    },\r\n    {\r\n        name: TAP_MINE_SHEET_NAME,\r\n        textureUrl: TapMine,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: TAPNOTE_HEIGHT_PX,\r\n        numSprites: 1,\r\n        numAnimFrames: 8,\r\n        animLength: 3,\r\n        animLoop: true,\r\n    },\r\n    // Holds\r\n    {\r\n        name: DOWN_HOLD_BODY_ACTIVE_SHEET_NAME,\r\n        textureUrl: DownHoldBodyActive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: 128,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n    {\r\n        name: DOWN_HOLD_BODY_INACTIVE_SHEET_NAME,\r\n        textureUrl: DownHoldBodyInactive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: 128,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n    {\r\n        name: DOWN_HOLD_BOTTOM_CAP_ACTIVE_SHEET_NAME,\r\n        textureUrl: DownHoldBottomCapActive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n    {\r\n        name: DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME,\r\n        textureUrl: DownHoldBottomCapInactive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n    // Rolls\r\n    // {\r\n    //     name: DOWN_ROLL_BODY_ACTIVE_SHEET_NAME,\r\n    //     textureUrl: DownRollBodyActive,\r\n    //     width: TAPNOTE_WIDTH_PX,\r\n    //     height: 256,\r\n    //     numSprites: 1,\r\n    //     numAnimFrames: 1,\r\n    //     animLength: 1,\r\n    //     animLoop: false,\r\n    // },\r\n    {\r\n        name: DOWN_ROLL_BODY_INACTIVE_SHEET_NAME,\r\n        textureUrl: DownRollBodyInactive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: 256,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n    // {\r\n    //     name: DOWN_ROLL_BOTTOM_CAP_ACTIVE_SHEET_NAME,\r\n    //     textureUrl: DownRollBottomCapActive,\r\n    //     width: TAPNOTE_WIDTH_PX,\r\n    //     height: HOLD_BOTTOM_CAP_HEIGHT_PX,\r\n    //     numSprites: 1,\r\n    //     numAnimFrames: 1,\r\n    //     animLength: 1,\r\n    //     animLoop: false,\r\n    // },\r\n    {\r\n        name: DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME,\r\n        textureUrl: DownRollBottomCapInactive,\r\n        width: TAPNOTE_WIDTH_PX,\r\n        height: HOLD_BOTTOM_CAP_HEIGHT_PX,\r\n        numSprites: 1,\r\n        numAnimFrames: 1,\r\n        animLength: 1,\r\n        animLoop: false,\r\n    },\r\n];\r\n\r\n/** Handles loading the resources we need to make things happen. */\r\nclass ResourceManager {\r\n    // Singleton\r\n    public static getInstance() {\r\n        if (!ResourceManager.instance) {\r\n            ResourceManager.instance = new ResourceManager();\r\n        }\r\n        return ResourceManager.instance;\r\n    }\r\n    private static instance: ResourceManager;\r\n\r\n    /** Stores all the textures we load, indexed by their identifiers.\r\n     * The textures are animated if there is more than one texture in the list.\r\n     * Stores other sprite metadata for convenience.\r\n     */\r\n    private spriteInfo: Map<string, GameSpriteInfo> = new Map();\r\n\r\n    /** Have we finished loading everything? */\r\n    private doneLoading = false;\r\n\r\n    // Private constructor for singleton pattern\r\n    private constructor() {}\r\n\r\n    public isDoneLoading() { return this.doneLoading; }\r\n    public getSpriteInfo(name: string) {\r\n        const spriteTextures = this.spriteInfo.get(name);\r\n        if (spriteTextures === undefined) {\r\n            throw new Error(`Could not find info for unknown sprite ${name}`);\r\n        }\r\n        return spriteTextures;\r\n    }\r\n\r\n    public loadSprites() {\r\n        // Load the sprites we'll need\r\n        const loader = SCREENMAN.getPixiApp().loader;\r\n        for (const spriteInfo of SPRITE_DEFINITIONS) {\r\n            loader.add(spriteInfo.name, spriteInfo.textureUrl);\r\n        }\r\n        // TODO: use loader.on.('progress', callbackFunc) to do a loading bar\r\n        loader.load(this.onLoad.bind(this));\r\n    }\r\n\r\n    /** Things to do when our textures finish loading. */\r\n    private onLoad() {\r\n        for (const spriteInfo of SPRITE_DEFINITIONS) {\r\n            this.extractTexturesFromSpriteSheet(spriteInfo);\r\n        }\r\n\r\n        this.doneLoading = true;\r\n    }\r\n\r\n    /** Extract animated textures from a sprite sheet. Add them to the global lookup.\r\n     * @param sprite: information describing how to extract the sprite.\r\n     */\r\n    private extractTexturesFromSpriteSheet(sprite: LoadSpriteInfo) {\r\n        const spriteTexture = SCREENMAN.getPixiApp().loader.resources[sprite.name].texture;\r\n\r\n        const sprites: PIXI.Texture[][] = [];\r\n        for (let s = 0; s < sprite.numSprites; s++) {\r\n            const spriteAnimTextures: PIXI.Texture[] = [];\r\n            for (let f = 0; f < sprite.numAnimFrames; f++) {\r\n                // Define a rectangle at the point we want to extract from\r\n                const rectangle = new PIXI.Rectangle(\r\n                    f * sprite.width,\r\n                    s * sprite.height,\r\n                    sprite.width,\r\n                    sprite.height,\r\n                );\r\n                // Clone that rectangle out of the original texture into a new smaller one\r\n                const spriteFrame = new PIXI.Texture(spriteTexture.baseTexture, rectangle);\r\n                spriteAnimTextures.push(spriteFrame);\r\n            }\r\n            // Store the sprite for later use\r\n            sprites.push(spriteAnimTextures);\r\n        }\r\n\r\n        this.spriteInfo.set(sprite.name, {\r\n            name: sprite.name,\r\n            width: sprite.width,\r\n            height: sprite.height,\r\n            animLength: sprite.animLength,\r\n            animLoop: sprite.animLoop,\r\n            textures: sprites,\r\n        });\r\n    }\r\n}\r\nconst RESOURCEMAN = ResourceManager.getInstance();\r\nexport default RESOURCEMAN;\r\n","import Entity from './Entity';\r\n\r\ninterface ScreenManagerOptions {\r\n    renderCanvas: HTMLCanvasElement;\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n/** Responsible for managing all game entities. */\r\nexport class EntityManager {\r\n    // Singleton\r\n    public static getInstance() {\r\n        if (!EntityManager.instance) {\r\n            EntityManager.instance = new EntityManager();\r\n        }\r\n        return EntityManager.instance;\r\n    }\r\n    private static instance: EntityManager;\r\n\r\n    private entities: Entity[] = [];\r\n\r\n    // Private constructor for singleton\r\n    private constructor() {}\r\n\r\n    public registerEntity(entity: Entity) {\r\n        this.entities.push(entity);\r\n        return this;\r\n    }\r\n\r\n    public deregisterEntity(entity: Entity) {\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            if (this.entities[i] === entity) {\r\n                // TODO: Not the most efficient implementation. Change later.\r\n                this.entities.splice(i, 1);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** Update all the entities we know about. */\r\n    public update(deltaTime: number) {\r\n        this.entities.forEach((entity) => {\r\n            entity.update(deltaTime);\r\n        });\r\n        return this;\r\n    }\r\n}\r\nconst ENTITYMAN = EntityManager.getInstance();\r\nexport default ENTITYMAN;\r\n","import ENTITYMAN from './EntityManager';\r\nimport NoteField from './NoteField';\r\n\r\n// The base class for all game entities\r\nabstract class Entity {\r\n    constructor() {\r\n        ENTITYMAN.registerEntity(this);\r\n    }\r\n\r\n    /** All entities must implement an update loop, even if it does nothing. */\r\n    public abstract update(deltaTime: number): this;\r\n\r\n    /** Destroys the current entity and unregisters it. */\r\n    public destroy() {\r\n        // TODO: look into what is necessary to recursively destroy a JS object\r\n        ENTITYMAN.deregisterEntity(this);\r\n    }\r\n}\r\nexport default Entity;\r\n","import * as PIXI from 'pixi.js-legacy';\r\nimport RESOURCEMAN, { GameSpriteInfo } from '../ResourceManager';\r\nimport SCREENMAN from '../ScreenManager';\r\nimport Entity from './Entity';\r\n\r\n/** Interface that describes anything that is drawable, including groups of sprites. */\r\nexport interface Drawable {\r\n    addToStage(): this;\r\n    removeFromStage(): this;\r\n    isOnStage(): boolean;\r\n    destroy(): void;\r\n}\r\n\r\n// Class to parent all sprite subsets\r\nclass GameSprite extends Entity implements Drawable {\r\n    public static checkDependencies() {\r\n        // We can't do anything if the resource manager isn't initialised\r\n        if (!RESOURCEMAN.isDoneLoading()) { throw new Error('RESOURCEMAN has not finished loading'); }\r\n    }\r\n\r\n    protected sprite: PIXI.Sprite;\r\n    protected onStage: boolean;\r\n\r\n    public constructor(sprite: PIXI.Sprite) {\r\n        super();\r\n\r\n        this.sprite = sprite;\r\n        this.onStage = false;\r\n\r\n        this.sprite.zIndex = 0;  // be explicit\r\n\r\n        // Anchor rotation around the center point\r\n        this.sprite.anchor.x = 0.5;\r\n        this.sprite.anchor.y = 0.5;\r\n    }\r\n\r\n    public destroy() {\r\n        this.removeFromStage();\r\n        super.destroy();\r\n    }\r\n\r\n    public isOnStage() { return this.onStage; }\r\n    public getSprite() { return this.sprite; }\r\n    public setPos(x: number, y: number) {\r\n        this.sprite.x = x;\r\n        this.sprite.y = y;\r\n        return this;\r\n    }\r\n    public setPosX(x: number) {\r\n        this.sprite.x = x;\r\n        return this;\r\n    }\r\n    public setPosY(y: number) {\r\n        this.sprite.y = y;\r\n        return this;\r\n    }\r\n    public addToStage() {\r\n        if (this.onStage) { return this; }\r\n\r\n        this.onStage = true;\r\n        SCREENMAN.getPixiApp().stage.addChild(this.sprite);\r\n        return this;\r\n    }\r\n    public removeFromStage() {\r\n        if (!this.onStage) { return this; }\r\n\r\n        this.onStage = false;\r\n        SCREENMAN.getPixiApp().stage.removeChild(this.sprite);\r\n        return this;\r\n    }\r\n\r\n    public setZIndex(z: number) {\r\n        this.sprite.zIndex = z;\r\n        return this;\r\n    }\r\n\r\n    public update(deltaTime: number): this {\r\n        // Basic sprite does nothing\r\n        return this;\r\n    }\r\n}\r\nexport default GameSprite;\r\n","import * as PIXI from 'pixi.js-legacy';\r\nimport { GameSpriteInfo } from '../ResourceManager';\r\nimport GameSprite from './GameSprite';\r\n\r\n// Class representing all sprites that are animated\r\nclass AnimatedGameSprite extends GameSprite {\r\n    protected sprite: PIXI.AnimatedSprite;\r\n\r\n    public constructor(spriteInfo: GameSpriteInfo, spriteIndex = 0) {\r\n        const sprite = new PIXI.AnimatedSprite(spriteInfo.textures[spriteIndex]);\r\n        super(sprite);\r\n        this.sprite = sprite;\r\n\r\n        // Translate frames of animation into an animation speed modifier\r\n        this.sprite.animationSpeed = 1 / spriteInfo.animLength;\r\n        this.sprite.loop = spriteInfo.animLoop;\r\n    }\r\n\r\n    public getSprite(): PIXI.AnimatedSprite {\r\n        return this.sprite;\r\n    }\r\n}\r\nexport default AnimatedGameSprite;\r\n","import AnimatedGameSprite from './AnimatedGameSprite';\r\nimport RESOURCEMAN, { DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME } from '../ResourceManager';\r\nimport { TapNoteDirection, directionToLaneIndex, LANE_MARGIN, TAPNOTE_WIDTH_PX } from './EntitiesConstants';\r\nimport GameSprite from './GameSprite';\r\n\r\nexport const RECEPTOR_MARGIN_TOP_PX = 32;\r\n\r\nclass TapNoteReceptorSprite extends AnimatedGameSprite {\r\n    private direction: TapNoteDirection;\r\n\r\n    /** Create a new tap note receptor sprite.\r\n     * @param direction the direction the arrow should go in.\r\n     */\r\n    constructor(direction: TapNoteDirection) {\r\n        GameSprite.checkDependencies();\r\n        super(RESOURCEMAN.getSpriteInfo(DOWN_TAP_NOTE_RECEPTOR_SHEET_NAME));\r\n\r\n        this.direction = direction;\r\n        this.sprite.alpha = 0.75;\r\n        this.sprite.y = RECEPTOR_MARGIN_TOP_PX;\r\n\r\n        // Set the rotation based on the direction, using the down arrow as a reference\r\n        this.sprite.rotation = (90 * this.direction) * (Math.PI / 180);\r\n\r\n        // Set the x based on the note track\r\n        const laneIndex = directionToLaneIndex(this.direction);\r\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\r\n\r\n        this.sprite.play();\r\n    }\r\n\r\n    public getDirection() { return this.direction; }\r\n\r\n    public update(deltaTime: number) {\r\n        return this;\r\n    }\r\n}\r\nexport default TapNoteReceptorSprite;\r\n","import { PlayerNumber, PLAYER_INVALID } from './PlayerNumber';\r\n\r\n// Types for holding tap notes and scores\r\n\r\n// tslint:disable: max-classes-per-file\r\n\r\nexport class TapNoteResult {\r\n    // TODO: implement\r\n}\r\n\r\nexport class HoldNoteResult {\r\n    // TODO: implement\r\n}\r\n\r\n/** What is the TapNote's core type? */\r\nexport enum TapNoteType {\r\n    Empty, \t\t    /** There is no note here. */\r\n    Tap,\t\t    /** The player simply steps on this. */\r\n    HoldHead,\t    /** This is graded like the Tap type, but should be held. */\r\n    HoldTail,\t    /** In 2sand3s mode, holds are deleted and hold_tail is added. */\r\n    Mine,\t\t    /** In most modes, it is suggested to not step on these mines. */\r\n    Lift,\t\t    /** Lift your foot up when it crosses the target area. */\r\n    Attack,\t\t    /** Hitting this note causes an attack to take place. */\r\n    AutoKeysound,\t/** A special sound is played when this note crosses the target area. */\r\n    Fake,\t\t    /** This arrow can't be scored for or against the player. */\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n/** The list of a TapNote's sub types. */\r\nexport enum TapNoteSubType {\r\n    Hold,   /** The start of a traditional hold note. */\r\n    Roll,   /** The start of a roll note that must be hit repeatedly. */\r\n    // Mine,\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n// I'm not sure how useful this will be for a viewer - Struz\r\n/** The different places a TapNote could come from. */\r\nexport enum TapNoteSource {\r\n    Original,\t/** This note is part of the original NoteData. */\r\n    Addition,\t/** This note is additional note added by a transform. */\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n/** The various properties of a tap note. */\r\nexport class TapNote {\r\n    /** Factory for non-default TapNotes */\r\n    public static create(\r\n        type: TapNoteType,\r\n        subType: TapNoteSubType,\r\n        source: TapNoteSource): TapNote {\r\n        if (type > TapNoteType.Fake) {\r\n            console.debug(`Invalid tap note type ${type} (most likely) due to random vanish issues.`);\r\n            type = TapNoteType.Empty;\r\n        }\r\n        const tapNote = new TapNote();\r\n        tapNote.type = type;\r\n        tapNote.subType = subType;\r\n        tapNote.source = source;\r\n        return tapNote;\r\n    }\r\n\r\n    /** The core note type that is about to cross the target area. */\r\n    public type: TapNoteType = TapNoteType.Empty;\r\n    /** The sub type of the note. This is only used if the type is HoldHead. */\r\n    public subType: TapNoteSubType = TapNoteSubType.Invalid;\r\n    /** The originating source of the TapNote. */\r\n    public source: TapNoteSource = TapNoteSource.Original;\r\n    /** The result of hitting or missing the TapNote. */\r\n    public result: TapNoteResult = new TapNoteResult();\r\n    /** The Player that is supposed to hit this note. This is mainly for Routine Mode. */\r\n    public pn: PlayerNumber = PLAYER_INVALID;\r\n\r\n    // Empty until filled in by NoteData.  These exist so that the notefield\r\n    // doesn't have to call GetElapsedTimeFromBeat 2-6 times for every note\r\n    // during rendering. -Kyz\r\n    public occursAtSecond: number = 0;\r\n    public endSecond: number = 0;  // occursAtSecond plus duration\r\n    // highestSubtypeOnRow is for rendering a tap as a hold head if\r\n    // there is a hold head on the same row.  It needs to be a TapNoteSubType\r\n    // instead of a bool to handle rolls. -Kyz\r\n    public highestSubtypeOnRow: TapNoteSubType = TapNoteSubType.Hold;\r\n    // ommitted idInChart, idInColumn, rowId - as these are for passing to mods\r\n\r\n    // ommitted attackModifiers, attackDurationSeconds - these are for attacks\r\n\r\n    // ommitted keySoundIndex as we don't support keysounds\r\n\r\n    // also used for HoldHead only;\r\n    /** The duration of the hold in note rows. */\r\n    public duration: number = 0;\r\n    public holdResult: HoldNoteResult = new HoldNoteResult();\r\n\r\n    public equals(other: TapNote) {\r\n        if (this.type !== other.type ||\r\n            this.subType !== other.subType ||\r\n            this.source !== other.source ||\r\n            this.duration !== other.duration ||\r\n            this.pn !== other.pn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // This was a struct in C++ which allowed copy by assignation.\r\n    // We deep copy here to get the same result.\r\n    public copy(): TapNote {\r\n        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);\r\n    }\r\n}\r\n\r\n/** A collection of functions that manipulate note types and data. */\r\nexport class NoteHelpers {\r\n    public static beatToNoteRow(beatNum: number) {\r\n        return Math.round(beatNum * ROWS_PER_BEAT);\r\n    }\r\n    public static beatToNoteRowNotRounded(beatNum: number) {\r\n        return Math.trunc(beatNum * ROWS_PER_BEAT);\r\n    }\r\n    public static noteRowToBeat(row: number) {\r\n        return row / ROWS_PER_BEAT;\r\n    }\r\n\r\n    /**\r\n     * Scales the position.\r\n     * @param start - the starting row of the scaling region\r\n     * @param length - the length of the scaling region\r\n     * @param newLength - the new length of the scaling region\r\n     * @param position - the position to scale\r\n     * @return the scaled position\r\n     */\r\n    public static scalePosition(start: number, length: number, newLength: number, position: number): number {\r\n        if (position < start) {\r\n            return position;\r\n        }\r\n        if (position >= start + length) {\r\n            return position - length + newLength;\r\n        }\r\n        return start + (position - start) * newLength / length;\r\n    }\r\n\r\n    /**\r\n     * Convert the NoteType to a beat representation.\r\n     * @param nt the NoteType to check.\r\n     * @return the proper beat.\r\n     */\r\n    public static noteTypeToBeat(nt: NoteType) {\r\n        switch (nt) {\r\n            case NoteType.N_4TH:   return 1;\t    // quarter notes\r\n            case NoteType.N_8TH:   return 1 / 2;\t// eighth notes\r\n            case NoteType.N_12TH:  return 1 / 3;\t// quarter note triplets\r\n            case NoteType.N_16TH:  return 1 / 4;\t// sixteenth notes\r\n            case NoteType.N_24TH:  return 1.0 / 6;\t// eighth note triplets\r\n            case NoteType.N_32ND:  return 1 / 8;\t// thirty-second notes\r\n            case NoteType.N_48TH:  return 1 / 12;   // sixteenth note triplets\r\n            case NoteType.N_64TH:  return 1 / 16;   // sixty-fourth notes\r\n            case NoteType.N_192ND: return 1 / 48;   // sixty-fourth note triplets\r\n            case NoteType.Invalid: return 1 / 48;\r\n            default:\r\n                throw new Error(`Unrecognized note type: ${nt}`);\r\n        }\r\n    }\r\n\r\n    public static noteTypeToRow(nt: NoteType) {\r\n        switch (nt) {\r\n            case NoteType.N_4TH: return 48;\r\n            case NoteType.N_8TH: return 24;\r\n            case NoteType.N_12TH: return 16;\r\n            case NoteType.N_16TH: return 12;\r\n            case NoteType.N_24TH: return 8;\r\n            case NoteType.N_32ND: return 6;\r\n            case NoteType.N_48TH: return 4;\r\n            case NoteType.N_64TH: return 3;\r\n            case NoteType.N_192ND:\r\n            case NoteType.Invalid:\r\n                return 1;\r\n            default:\r\n                throw new Error(`Unrecognized note type: ${nt}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve the proper quantized NoteType for the note.\r\n     * @param row The row to check for.\r\n     * @return the quantized NoteType.\r\n     */\r\n    public static getNoteType(row: number): NoteType {\r\n        if (row % (ROWS_PER_MEASURE / 4) === 0) {\r\n            return NoteType.N_4TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 8) === 0) {\r\n            return NoteType.N_8TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 12) === 0) {\r\n            return NoteType.N_12TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 16) === 0) {\r\n            return NoteType.N_16TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 24) === 0) {\r\n            return NoteType.N_24TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 32) === 0) {\r\n            return NoteType.N_32ND;\r\n        } else if (row % (ROWS_PER_MEASURE / 48) === 0) {\r\n            return NoteType.N_48TH;\r\n        } else if (row % (ROWS_PER_MEASURE / 64) === 0) {\r\n            return NoteType.N_64TH;\r\n        }\r\n        return NoteType.N_192ND;\r\n    }\r\n\r\n    public static beatToNoteType(beat: number) {\r\n        return this.getNoteType(NoteHelpers.beatToNoteRow(beat));\r\n    }\r\n\r\n    /**\r\n     * Determine if the row has a particular type of quantized note.\r\n     * @param row the row in the Steps.\r\n     * @param t the quantized NoteType to check for.\r\n     * @return true if the NoteType is t, false otherwise.\r\n     */\r\n    public static isNoteOfType(row: number, t: NoteType) {\r\n        return this.getNoteType(row) === t;\r\n    }\r\n}\r\nexport default NoteHelpers;\r\n\r\n/**\r\n * The number of rows per beat.\r\n * This is a divisor for our \"fixed-point\" time/beat representation. It must be\r\n * evenly divisible by 2, 3, and 4, to exactly represent 8th, 12th and 16th notes.\r\n */\r\nexport const ROWS_PER_BEAT: number = 48;\r\n\r\n/** The max number of rows allowed for a Steps pattern. */\r\n// tslint:disable-next-line: no-bitwise\r\nexport const MAX_NOTE_ROW: number = (1 << 30);\r\n\r\n/** The list of quantized note types allowed at present. */\r\nexport enum NoteType {\r\n    N_4TH,\t /** quarter note */\r\n    N_8TH,\t /** eighth note */\r\n    N_12TH,\t /** quarter note triplet */\r\n    N_16TH,\t /** sixteenth note */\r\n    N_24TH,\t /** eighth note triplet */\r\n    N_32ND,\t /** thirty-second note */\r\n    N_48TH,  /** sixteenth note triplet */\r\n    N_64TH,\t /** sixty-fourth note */\r\n    N_192ND, /** sixty-fourth note triplet */\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n// STEPMANIA-TODO: Remove these constants that aren't time signature-aware\r\nexport const BEATS_PER_MEASURE = 4;\r\nexport const ROWS_PER_MEASURE = ROWS_PER_BEAT * BEATS_PER_MEASURE;\r\n\r\nexport class TapNotes {\r\n    public static EMPTY = TapNote.create(\r\n        TapNoteType.Empty, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_TAP = TapNote.create(\r\n        TapNoteType.Tap, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_LIFT = TapNote.create(\r\n        TapNoteType.Lift, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_HOLD_HEAD = TapNote.create(\r\n        TapNoteType.HoldHead, TapNoteSubType.Hold, TapNoteSource.Original);\r\n    public static ORIGINAL_ROLL_HEAD = TapNote.create(\r\n        TapNoteType.HoldHead, TapNoteSubType.Roll, TapNoteSource.Original);\r\n    public static ORIGINAL_MINE = TapNote.create(\r\n        TapNoteType.Mine, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_ATTACK = TapNote.create(\r\n        TapNoteType.Attack, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_AUTO_KEYSOUND = TapNote.create(\r\n        TapNoteType.AutoKeysound, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ORIGINAL_FAKE = TapNote.create(\r\n        TapNoteType.Fake, TapNoteSubType.Invalid, TapNoteSource.Original);\r\n    public static ADDITION_TAP = TapNote.create(\r\n        TapNoteType.Tap, TapNoteSubType.Invalid, TapNoteSource.Addition);\r\n    public static ADDITION_MINE = TapNote.create(\r\n        TapNoteType.Mine, TapNoteSubType.Invalid, TapNoteSource.Addition);\r\n\r\n    // The original code was in C++ so the above were structs that\r\n    // could be copied on assign. We use these functions to get around this.\r\n    public static newEmpty() { return this.EMPTY.copy(); }\r\n    public static newOriginalTap() { return this.ORIGINAL_TAP.copy(); }\r\n    public static newOriginalLift() { return this.ORIGINAL_LIFT.copy(); }\r\n    public static newOriginalHoldHead() { return this.ORIGINAL_HOLD_HEAD.copy(); }\r\n    public static newOriginalRollHead() { return this.ORIGINAL_ROLL_HEAD.copy(); }\r\n    public static newOriginalMine() { return this.ORIGINAL_MINE.copy(); }\r\n    public static newOriginalAttack() { return this.ORIGINAL_ATTACK.copy(); }\r\n    public static newOriginalAutoKeysound() { return this.ORIGINAL_AUTO_KEYSOUND.copy(); }\r\n    public static newOriginalFake() { return this.ORIGINAL_FAKE.copy(); }\r\n    public static newAdditionTap() { return this.ADDITION_TAP.copy(); }\r\n    public static newAdditionMine() { return this.ADDITION_MINE.copy(); }\r\n}\r\n","// Various structures to deal with segments of songs that have different timings\r\n// tslint:disable: max-classes-per-file\r\n\r\nimport NoteHelpers from './NoteTypes';\r\n\r\nexport enum TimingSegmentType {\r\n    BPM,\r\n    STOP,\r\n    DELAY,\r\n    TIME_SIG,\r\n    WARP,\r\n    LABEL,\r\n    TICKCOUNT,\r\n    COMBO,\r\n    SPEED,\r\n    SCROLL,\r\n    FAKE,\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n// XXX: dumb names\r\nexport enum SegmentEffectType {\r\n    Row,\t\t// takes effect on a single row\r\n    Range,\t    // takes effect for a definite amount of rows\r\n    Indefinite,\t// takes effect until the next segment of its type\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\nexport const ROW_INVALID = -1;\r\n\r\nexport abstract class TimingSegment {\r\n    // for our purposes, two floats within this level of error are equal\r\n    public static EPSILON: number = 1e-6;\r\n\r\n    /** Compare two numbers for equality.\r\n     * @param num1 A number.\r\n     * @param num2 Another number.\r\n     * @returns true if they are close enough to be equal, false otherwise.\r\n     */\r\n    public static compareFloat(num1: number, num2: number) {\r\n        if (Math.abs(num1 - num2) > this.EPSILON) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** The row in which this segment activates */\r\n    private startRow: number = 0;\r\n\r\n    constructor(beatOrRow = ROW_INVALID, isRow = true) {\r\n        // If it's a row, store it, otherwise convert it to a row\r\n        this.startRow = (isRow ? beatOrRow : NoteHelpers.beatToNoteRow(beatOrRow));\r\n    }\r\n\r\n    public abstract getType(): TimingSegmentType;\r\n    public abstract getEffectType(): SegmentEffectType;\r\n    public abstract isNotable(): boolean;\r\n    public abstract debugPrint(): void;\r\n\r\n    /**\r\n     * Scales itself.\r\n     * @param start Starting row\r\n     * @param length Length in rows\r\n     * @param newLength The new length in rows\r\n     */\r\n    public scale(start: number, length: number, newLength: number): void {\r\n        this.setRow(NoteHelpers.scalePosition(start, length, newLength, this.getRow()));\r\n    }\r\n\r\n    public getRow() { return this.startRow; }\r\n    public setRow(row: number) { this.startRow = row; }\r\n\r\n    public getBeat() { return NoteHelpers.noteRowToBeat(this.startRow); }\r\n    public setBeat(beat: number) { this.setRow(NoteHelpers.beatToNoteRow(beat)); }\r\n\r\n    public toString(dec: number) { return this.getBeat().toString(); }\r\n    public abstract getValues(): number[];\r\n\r\n    public lessThan(other: TimingSegment) {\r\n        return this.getRow() < other.getRow();\r\n    }\r\n\r\n    // overloads should not call this base version; derived classes\r\n    // should only compare contents, and this compares position.\r\n    public equals(other: TimingSegment): boolean {\r\n        return this.getRow() === other.getRow();\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a song needs to warp to a new beat.\r\n *\r\n * A warp segment is used to replicate the effects of Negative BPMs without\r\n * abusing negative BPMs. Negative BPMs should be converted to warp segments.\r\n * WarpAt=WarpToRelative is the format, where both are in beats.\r\n * (Technically they're both rows though.)\r\n */\r\nexport class WarpSegment extends TimingSegment {\r\n    private lengthRows: number;\r\n\r\n    constructor(startRow?: number, lengthRowsOrBeats?: number, isRows = true) {\r\n        // Do a poor man's overloaded constructor *sigh*\r\n        // constructor() is valid, constructor(row, lengthRows) is vaild,\r\n        // and constructor(row, lengthBeats) is valid.\r\n        // isRows defines whether lengthRowsOrBeats refers to rows or not\r\n        if (startRow === undefined) {\r\n            super();\r\n            this.lengthRows = 0;\r\n            return;\r\n        }\r\n        if (lengthRowsOrBeats === undefined) {\r\n            throw new Error('invalid constructor used - must provide nothing, or both optinoal parameters');\r\n        }\r\n        super(startRow, true);\r\n        if (isRows) {\r\n            this.lengthRows = lengthRowsOrBeats;\r\n        } else {\r\n            this.lengthRows = NoteHelpers.beatToNoteRow(lengthRowsOrBeats);\r\n        }\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.WARP; }\r\n    public getEffectType() { return SegmentEffectType.Range; }\r\n\r\n    public isNotable() { return this.lengthRows > 0; }\r\n\r\n    public getLengthRows() { return this.lengthRows; }\r\n    public getLengthBeats() { return NoteHelpers.noteRowToBeat(this.lengthRows); }\r\n    public getLength() { return this.getLengthBeats(); }\r\n\r\n    public setLengthRows(rows: number) { this.lengthRows = rows; }\r\n    public setLengthBeats(beats: number) { this.lengthRows = NoteHelpers.beatToNoteRow(beats); }\r\n\r\n    public scale(start: number, length: number, newLength: number) {\r\n        // XXX: this function is duplicated, there should be a better way\r\n        const startBeat    = this.getBeat();\r\n        const endBeat      = startBeat + this.getLength();\r\n        const newStartBeat = NoteHelpers.scalePosition(\r\n            NoteHelpers.noteRowToBeat(start),\r\n            NoteHelpers.noteRowToBeat(length),\r\n            NoteHelpers.noteRowToBeat(newLength),\r\n            startBeat);\r\n        const newEndBeat   = NoteHelpers.scalePosition(\r\n            NoteHelpers.noteRowToBeat(start),\r\n            NoteHelpers.noteRowToBeat(length),\r\n            NoteHelpers.noteRowToBeat(newLength),\r\n            endBeat);\r\n        this.setLengthBeats(newEndBeat - newStartBeat);\r\n        super.scale(start, length, newLength);\r\n    }\r\n\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const lengthRows = this.getLengthRows();\r\n        const lengthBeats = this.getLengthBeats();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${lengthRows} [${lengthBeats}])`);\r\n    }\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const length = this.getLength();\r\n        return `${beat}=${length}`;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [this.getLength()];\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof WarpSegment)) {\r\n            return false;\r\n        }\r\n        // If they differ in length, return false\r\n        if (!TimingSegment.compareFloat(this.lengthRows, other.lengthRows)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a chart is to have a different tickcount value\r\n * for hold notes.\r\n *\r\n * A tickcount segment is used to better replicate the checkpoint hold\r\n * system used by various based video games. The number is used to\r\n * represent how many ticks can be counted in one beat.\r\n */\r\nexport class TickcountSegment extends TimingSegment {\r\n    /** The default amount of ticks per beat. */\r\n    public static DEFAULT_TICK_COUNT = 4;\r\n\r\n    /** The amount of hold checkpoints counted per beat */\r\n    private ticksPerBeat: number;\r\n\r\n    constructor(startRow = ROW_INVALID, ticks = TickcountSegment.DEFAULT_TICK_COUNT) {\r\n        super(startRow, true);\r\n        this.ticksPerBeat = ticks;\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.TICKCOUNT; }\r\n    public getEffectType() { return SegmentEffectType.Indefinite; }\r\n    public isNotable() { return true; } // indefinite segments are always true\r\n\r\n    public getTicks() { return this.ticksPerBeat; }\r\n    public setTicks(ticks: number) { this.ticksPerBeat = ticks; }\r\n\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const ticks = this.getTicks();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${ticks})`);\r\n    }\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const ticks = this.getTicks();\r\n        return `${beat}=${ticks}`;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [this.getTicks()];\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof TickcountSegment)) {\r\n            return false;\r\n        }\r\n        // If they differ in tick count, return false\r\n        if (!TimingSegment.compareFloat(this.ticksPerBeat, other.ticksPerBeat)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a song changes its time signature.\r\n *\r\n * This only supports simple time signatures. The upper number\r\n * (called the numerator here, though this isn't properly a\r\n * fraction) is the number of beats per measure. The lower number\r\n * (denominator here) is the note value representing one beat.\r\n */\r\nexport class TimeSignatureSegment extends TimingSegment {\r\n    private numerator: number;\r\n    private denominator: number;\r\n\r\n    constructor(startRow = ROW_INVALID, numerator = 4, denominator = 4) {\r\n        super(startRow, true);\r\n        this.numerator = numerator;\r\n        this.denominator = denominator;\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.TIME_SIG; }\r\n    public getEffectType() { return SegmentEffectType.Indefinite; }\r\n    public isNotable() { return true; } // indefinite segments are always true\r\n\r\n    public getNum() { return this.numerator; }\r\n    public setNum(num: number) { this.numerator = num; }\r\n\r\n    public getDen() { return this.denominator; }\r\n    public setDen(den: number) { this.denominator = den; }\r\n\r\n    public set(num: number, den: number) { this.numerator = num; this.denominator = den; }\r\n\r\n    /**\r\n     * Retrieve the number of note rows per measure within the TimeSignatureSegment.\r\n     *\r\n     * With BeatToNoteRow(1) rows per beat, then we should have BeatToNoteRow(1)*m_iNumerator\r\n     * beats per measure. But if we assume that every BeatToNoteRow(1) rows is a quarter note,\r\n     * and we want the beats to be 1/m_iDenominator notes, then we should have\r\n     * BeatToNoteRow(1)*4 is rows per whole note and thus BeatToNoteRow(1)*4/m_iDenominator is\r\n     * rows per beat. Multiplying by m_iNumerator gives rows per measure.\r\n     * @returns the number of note rows per measure.\r\n     */\r\n    public getNoteRowsPerMeasure() {\r\n        return NoteHelpers.beatToNoteRow(1) * 4 * this.numerator / this.denominator;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the number of note rows per beat within the TimeSignatureSegment.\r\n     *\r\n     * This is just the number of note rows per measure, divided by the time signature\r\n     * denominator. For example, in a 4/4 time signature, there are 4 4th note beats\r\n     * in the measure.\r\n     */\r\n    public getNoteRowsPerBeat() {\r\n        return NoteHelpers.beatToNoteRow(1) * 4 / this.denominator;\r\n    }\r\n\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const num = this.getNum();\r\n        const den = this.getDen();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${num}/${den})`);\r\n    }\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const num = this.getNum();\r\n        const den = this.getDen();\r\n        return `${beat}=${num}=${den}`;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [this.getNum(), this.getDen()];\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof TimeSignatureSegment)) {\r\n            return false;\r\n        }\r\n        // If they differ in either numerator or denominator, return false\r\n        if (!TimingSegment.compareFloat(this.numerator, other.numerator)) {\r\n            return false;\r\n        }\r\n        if (!TimingSegment.compareFloat(this.denominator, other.denominator)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a song changes its BPM.\r\n */\r\nexport class BPMSegment extends TimingSegment {\r\n    /** The number of beats per second within this BPMSegment. */\r\n    private bps: number = 0;\r\n\r\n    constructor(startRow = ROW_INVALID, bpm = 0.0) {\r\n        super(startRow, true);\r\n        this.setBpm(bpm);\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.BPM; }\r\n    public getEffectType() { return SegmentEffectType.Indefinite; }\r\n    public isNotable() { return true; } // indefinite segments are always true\r\n\r\n    public getBps() { return this.bps; }\r\n    public getBpm() { return this.bps * 60.0; }\r\n\r\n    public setBps(bps: number) { this.bps = bps; }\r\n    public setBpm(bpm: number) { this.bps = bpm / 60.0; }\r\n\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const bpm = this.getBpm();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${bpm})`);\r\n    }\r\n\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const bpm = this.getBpm().toFixed(dec);\r\n        return `${beat}=${bpm}`;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [this.getBpm()];\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof BPMSegment)) {\r\n            return false;\r\n        }\r\n        // If they differ in bps, return false\r\n        if (!TimingSegment.compareFloat(this.bps, other.bps)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a song has a stop, DDR/ITG style.\r\n */\r\nexport class StopSegment extends TimingSegment {\r\n    /** The number of seconds to pause at the segment's row. */\r\n    private seconds: number;\r\n\r\n    constructor(startRow = ROW_INVALID, seconds = 0.0) {\r\n        super(startRow, true);\r\n        this.seconds = seconds;\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.STOP; }\r\n    public getEffectType() { return SegmentEffectType.Row; }\r\n    public isNotable() { return this.seconds > 0; } // indefinite segments are always true\r\n\r\n    public getPause() { return this.seconds; }\r\n    public setPause(seconds: number) { this.seconds = seconds; }\r\n\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const pause = this.getPause();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${pause})`);\r\n    }\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const pause = this.getPause();\r\n        return `${beat}=${pause}`;\r\n    }\r\n\r\n    public getValues(): number[] {\r\n        return [this.getPause()];\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof StopSegment)) {\r\n            return false;\r\n        }\r\n        return TimingSegment.compareFloat(this.seconds, other.seconds);\r\n    }\r\n}\r\n\r\n/**\r\n * Identifies when a song has a delay, or pump style stop.\r\n */\r\nexport class DelaySegment extends TimingSegment {\r\n    /** The number of seconds to pause at the segment's row. */\r\n    private seconds: number = -1;\r\n\r\n    constructor(startRow = ROW_INVALID, seconds = 0) {\r\n        super(startRow, true);\r\n        this.seconds = seconds;\r\n    }\r\n\r\n    public getType() { return TimingSegmentType.DELAY; }\r\n    public getEffectType() { return SegmentEffectType.Row; }\r\n\r\n    public getPause() { return this.seconds; }\r\n    public setPause(seconds: number) { this.seconds = seconds; }\r\n\r\n    public isNotable() { return this.seconds > 0; }\r\n    public getValues() { return [this.getPause()]; }\r\n    public debugPrint() {\r\n        const type = this.getType();\r\n        const row = this.getRow();\r\n        const beat = this.getBeat();\r\n        const pause = this.getPause();\r\n        console.debug(`\\t${type}(${row} [${beat}], ${pause})`);\r\n    }\r\n    public toString(dec: number) {\r\n        const beat = this.getBeat().toFixed(dec);\r\n        const pause = this.getPause().toFixed(dec);\r\n        return `${beat}=${pause}`;\r\n    }\r\n\r\n    public equals(other: TimingSegment): boolean {\r\n        if (this.getType() !== other.getType()) {\r\n            return false;\r\n        }\r\n\r\n        if (!(other instanceof DelaySegment)) {\r\n            return false;\r\n        }\r\n        return TimingSegment.compareFloat(this.seconds, other.seconds);\r\n    }\r\n}\r\n","// tslint:disable: max-classes-per-file\r\nimport { TimingSegment, TimingSegmentType, SegmentEffectType,\r\n    TimeSignatureSegment, BPMSegment, TickcountSegment,\r\n    WarpSegment, StopSegment, DelaySegment } from './TimingSegments';\r\nimport { PassByRef } from './GameConstantsAndTypes';\r\nimport NoteHelpers from './NoteTypes';\r\nimport { NotImplementedError } from './Error';\r\n\r\nconst INVALID_INDEX: number = -1;\r\n\r\n/* DummySegments: since our model relies on being able to get a segment at will,\r\n * whether one exists or not, we have a bunch of dummies to return if there is\r\n * no segment. It's kind of kludgy, but when we have functions making\r\n * indiscriminate calls to get segments at arbitrary rows, I think it's the\r\n * best solution we've got for now.\r\n *\r\n * Note that types whose SegmentEffectAreas are \"Indefinite\" are NULL here,\r\n * because they should never need to be used; we always have at least one such\r\n * segment in the TimingData, and if not, we'll crash anyway. -- vyhd */\r\nconst DummySegments: Array<TimingSegment | null> = [\r\n    null, // BPMSegment\r\n    new StopSegment(),\r\n    new DelaySegment(),\r\n    null, // TimeSignatureSegment\r\n    new WarpSegment(),\r\n    null, // LabelSegment\r\n    null, // TickcountSegment\r\n    null, // ComboSegment\r\n    null, // SpeedSegment\r\n    null, // ScrollSegment\r\n    null, // Haven't implemented FakeSegment yet //new FakeSegment(),\r\n];\r\n\r\nenum FoundEventType {\r\n    WARP,\r\n    WARP_DESTINATION,\r\n    BPM_CHANGE,\r\n    STOP,\r\n    DELAY,\r\n    STOP_DELAY, // we have these two on the same row.\r\n    MARKER,\r\n    NOT_FOUND,\r\n}\r\n\r\n/** Simple struct for finding events in timing data. */\r\nclass FindEventStatus {\r\n    public bpm = 0;\r\n    public warp = 0;\r\n    public stop = 0;\r\n    public delay = 0;\r\n    public lastRow = 0;\r\n    public lastTime = 0;\r\n    public warpDestination = 0;\r\n    public isWarping = false;\r\n}\r\n\r\n// GetBeatArgs, GetBeatStarts, m_beat_start_lookup, m_time_start_lookup,\r\n// PrepareLookup, and ReleaseLookup form a system for speeding up finding\r\n// the current beat and bps from the time, or finding the time from the\r\n// current beat.\r\n// The lookup tables contain indices for the beat and time finding\r\n// functions to start at so they don't have to walk through all the timing\r\n// segments.\r\n// PrepareLookup should be called before gameplay starts, so that the lookup\r\n// tables are populated.  ReleaseLookup should be called after gameplay\r\n// finishes so that memory isn't wasted.\r\n// -Kyz\r\n/** Struct for passing around timing info. */\r\nexport class GetBeatArgs {\r\n    public elapsedTime = 0;\r\n    public beat = 0;\r\n    public bpsOut = 0;\r\n    public warpDestOut = 0;\r\n    public warpBeginOut = -1; // int\r\n    public freezeOut = false;\r\n    public delayOut = false;\r\n}\r\nexport class GetBeatStarts {\r\n    public bpm = 0;     // int\r\n    public warp = 0;    // int\r\n    public stop = 0;    // int\r\n    public delay = 0;   // int\r\n    public lastRow = 0; // int\r\n    public lastTime = 0;\r\n    public warpDestination = 0;\r\n    public isWarping = false;\r\n}\r\n/** A pair representing <beat or second, GetBeatStarts> */\r\ntype LookupItem = [number, GetBeatStarts];\r\ntype BeatStartLookup = Array<LookupItem | undefined>;\r\n\r\n/** Holds data for translating beats<->seconds. */\r\nexport class TimingData {\r\n    // Utility functions\r\n    public static findEntryInLookup(lookup: BeatStartLookup, entry: number): LookupItem | undefined {\r\n        if (lookup.length === 0) { return undefined; }\r\n        let lower = 0;\r\n        let upper = lookup.length - 1;\r\n\r\n        // If the entry we're looking for is outside the bounds of the array\r\n        // then fail fast\r\n        let lookupItem = lookup[lower];\r\n        if (lookupItem === undefined) { throw new Error('lookup[lower] must be defined'); }\r\n        if (lookupItem[0] > entry) {\r\n            return undefined;\r\n        }\r\n        lookupItem = lookup[upper];\r\n        if (lookupItem === undefined) { throw new Error('lookup[upper] must be defined'); }\r\n        if (lookupItem[0] < entry) {\r\n            // See explanation at the end of this function. -Kyz\r\n            return lookup[upper - 1];\r\n        }\r\n\r\n        // Otherwise use a binary search to find it\r\n        while (upper - lower > 1) {\r\n            const next = Math.trunc((upper + lower) / 2); // int\r\n            lookupItem = lookup[next];\r\n            if (lookupItem === undefined) { throw new Error('lookup[next] must be defined'); }\r\n            if (lookupItem[0] > entry) {\r\n                upper = next;\r\n            } else if (lookupItem[0] < entry) {\r\n                lower = next;\r\n            } else {\r\n                // We found the element\r\n                lower = next;\r\n                break;\r\n            }\r\n        }\r\n        // If the time or beat being looked up is close enough to the starting\r\n        // point that is returned, such as putting the time inside a stop or delay,\r\n        // then it can make arrows unhittable.  So always return the entry before\r\n        // the closest one to prevent that. -Kyz\r\n        if (lower === 0) { return undefined; }\r\n        return lookup[lower - 1];\r\n    }\r\n\r\n    public static findEvent(\r\n        eventRow: PassByRef<number>, eventType: PassByRef<number>,\r\n        status: FindEventStatus, beat: number, findMarker: boolean, bpms: TimingSegment[],\r\n        warps: TimingSegment[], stops: TimingSegment[], delays: TimingSegment[]) {\r\n            if (status.isWarping && NoteHelpers.beatToNoteRow(status.warpDestination) < eventRow.value) {\r\n                eventRow.value = NoteHelpers.beatToNoteRow(status.warpDestination);\r\n                eventType.value = FoundEventType.WARP_DESTINATION;\r\n            }\r\n            if (status.bpm < bpms.length && bpms[status.bpm].getRow() < eventRow.value) {\r\n                eventRow.value = bpms[status.bpm].getRow();\r\n                eventType.value = FoundEventType.BPM_CHANGE;\r\n            }\r\n            if (status.delay < delays.length && delays[status.delay].getRow() < eventRow.value) {\r\n                eventRow.value = delays[status.delay].getRow();\r\n                eventType.value = FoundEventType.DELAY;\r\n            }\r\n            if (findMarker && NoteHelpers.beatToNoteRow(beat) < eventRow.value) {\r\n                eventRow.value = NoteHelpers.beatToNoteRow(beat);\r\n                eventType.value = FoundEventType.MARKER;\r\n            }\r\n            if (status.stop < stops.length && stops[status.stop].getRow() < eventRow.value) {\r\n                // Because of the way we PassByRef we need to assign a value like this to make it separate\r\n                const tmpRow = {value: eventRow.value};\r\n                eventRow.value = stops[status.stop].getRow();\r\n                eventType.value = (tmpRow.value === eventRow.value) ? FoundEventType.STOP_DELAY : FoundEventType.STOP;\r\n            }\r\n            if (status.warp < warps.length && warps[status.warp].getRow() < eventRow.value) {\r\n                eventRow.value = warps[status.warp].getRow();\r\n                eventType.value = FoundEventType.WARP;\r\n            }\r\n        }\r\n\r\n    // Beat<->Second translation structures\r\n    public beatStartLookup: BeatStartLookup = [];\r\n    public timeStartLookup: BeatStartLookup = [];\r\n\r\n    /** The initial offset of a song. */\r\n    private beat0OffsetInSecs: number = 0;\r\n    // All of the following vectors must be sorted before gameplay.\r\n    private timingSegments: TimingSegment[][] = [];\r\n\r\n    constructor() {\r\n        // TimingSegments has one array per valid TimingSegmentType enum\r\n        for (let i = 0; i < TimingSegmentType.NUM; i++) {\r\n            this.timingSegments.push([]);\r\n        }\r\n    }\r\n\r\n    public getBeatInternal(start: GetBeatStarts, args: GetBeatArgs, maxSegment: number) {\r\n        const segs = this.timingSegments;\r\n        const bpms = segs[TimingSegmentType.BPM];\r\n        const warps = segs[TimingSegmentType.WARP];\r\n        const stops = segs[TimingSegmentType.STOP];\r\n        const delays = segs[TimingSegmentType.DELAY];\r\n        let curSegment = start.bpm + start.warp + start.stop + start.delay;\r\n\r\n        let bps = this.getBpmAtRow(start.lastRow) / 60;\r\n\r\n        while (curSegment < maxSegment) {\r\n            const eventRow = { value: Number.MAX_SAFE_INTEGER };\r\n            const eventType = { value: FoundEventType.NOT_FOUND };\r\n            TimingData.findEvent(eventRow, eventType, start, 0, false, bpms, warps, stops, delays);\r\n            if (eventType.value === FoundEventType.NOT_FOUND) { break; }\r\n            let timeToNextEvent = start.isWarping ? 0 :\r\n                NoteHelpers.noteRowToBeat(eventRow.value - start.lastRow) / bps;\r\n            let nextEventTime = start.lastTime + timeToNextEvent;\r\n            if (args.elapsedTime < nextEventTime) { break; }\r\n            start.lastTime = nextEventTime;\r\n\r\n            switch (eventType.value) {\r\n                case FoundEventType.WARP_DESTINATION:\r\n                    start.isWarping = false;\r\n                    break;\r\n                case FoundEventType.BPM_CHANGE:\r\n                    bps = (bpms[start.bpm] as BPMSegment).getBps();\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.bpm++;\r\n                    break;\r\n                case FoundEventType.DELAY:\r\n                case FoundEventType.STOP_DELAY:\r\n                    const delaySeg = (delays[start.delay] as DelaySegment);\r\n                    timeToNextEvent = delaySeg.getPause();\r\n                    nextEventTime = start.lastTime + timeToNextEvent;\r\n                    if (args.elapsedTime < nextEventTime) {\r\n                        args.freezeOut = false;\r\n                        args.delayOut = true;\r\n                        args.beat = delaySeg.getBeat();\r\n                        args.bpsOut = bps;\r\n                        return;\r\n                    }\r\n                    start.lastTime = nextEventTime;\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.delay++;\r\n                    if (eventType.value === FoundEventType.DELAY) { break; }\r\n                case FoundEventType.STOP:\r\n                    const stopSeg = (stops[start.stop] as StopSegment);\r\n                    timeToNextEvent = stopSeg.getPause();\r\n                    nextEventTime = start.lastTime + timeToNextEvent;\r\n                    if (args.elapsedTime < nextEventTime) {\r\n                        args.freezeOut = true;\r\n                        args.delayOut = false;\r\n                        args.beat = stopSeg.getBeat();\r\n                        args.bpsOut = bps;\r\n                        return;\r\n                    }\r\n                    start.lastTime = nextEventTime;\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.stop++;\r\n                    break;\r\n                case FoundEventType.WARP:\r\n                    start.isWarping = true;\r\n                    const warpSeg = (warps[start.warp] as WarpSegment);\r\n                    const warpSum = warpSeg.getLength() + warpSeg.getBeat();\r\n                    if (warpSum > start.warpDestination) {\r\n                        start.warpDestination = warpSum;\r\n                    }\r\n                    args.warpBeginOut = eventRow.value;\r\n                    args.warpDestOut = start.warpDestination;\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.warp++;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            start.lastRow = eventRow.value;\r\n        }\r\n\r\n        if (args.elapsedTime === Number.MAX_VALUE) {\r\n            args.elapsedTime = start.lastTime;\r\n        }\r\n        args.beat = NoteHelpers.noteRowToBeat(start.lastRow) + (args.elapsedTime - start.lastTime) * bps;\r\n        args.bpsOut = bps;\r\n    }\r\n\r\n    public getElapsedTimeInternal(start: GetBeatStarts, beat: number, maxSegment: number) {\r\n        const segs = this.timingSegments;\r\n        const bpms = segs[TimingSegmentType.BPM];\r\n        const warps = segs[TimingSegmentType.WARP];\r\n        const stops = segs[TimingSegmentType.STOP];\r\n        const delays = segs[TimingSegmentType.DELAY];\r\n        let curSegment = start.bpm + start.warp + start.stop + start.delay;\r\n\r\n        let bps = this.getBpmAtRow(start.lastRow) / 60;\r\n        const findMarker = beat < Number.MAX_VALUE;\r\n\r\n        while (curSegment < maxSegment) {\r\n            const eventRow = { value: Number.MAX_SAFE_INTEGER };\r\n            const eventType = { value: FoundEventType.NOT_FOUND };\r\n            TimingData.findEvent(eventRow, eventType, start, beat, findMarker, bpms, warps, stops, delays);\r\n            let timeToNextEvent = start.isWarping ? 0 :\r\n                NoteHelpers.noteRowToBeat(eventRow.value - start.lastRow) / bps;\r\n            let nextEventTime = start.lastTime + timeToNextEvent;\r\n            start.lastTime = nextEventTime;\r\n\r\n            switch (eventType.value) {\r\n                case FoundEventType.WARP_DESTINATION:\r\n                    start.isWarping = false;\r\n                    break;\r\n                case FoundEventType.BPM_CHANGE:\r\n                    bps = (bpms[start.bpm] as BPMSegment).getBps();\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.bpm++;\r\n                    break;\r\n                case FoundEventType.STOP:\r\n                case FoundEventType.STOP_DELAY:\r\n                    const stopSeg = (stops[start.stop] as StopSegment);\r\n                    timeToNextEvent = stopSeg.getPause();\r\n                    nextEventTime = start.lastTime + timeToNextEvent;\r\n                    start.lastTime = nextEventTime;\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.stop++;\r\n                    break;\r\n                case FoundEventType.DELAY:\r\n                    timeToNextEvent = (delays[start.delay] as DelaySegment).getPause();\r\n                    nextEventTime = start.lastTime + timeToNextEvent;\r\n                    start.lastTime = nextEventTime;\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.delay++;\r\n                    break;\r\n                case FoundEventType.MARKER:\r\n                    return start.lastTime;\r\n                case FoundEventType.WARP:\r\n                    start.isWarping = true;\r\n                    const warpSeg = (warps[start.warp] as WarpSegment);\r\n                    const warpSum = warpSeg.getLength() + warpSeg.getBeat();\r\n                    if (warpSum > start.warpDestination) {\r\n                        start.warpDestination = warpSum;\r\n                    }\r\n                    // INC_INDEX next 2 lines\r\n                    curSegment++;\r\n                    start.warp++;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            start.lastRow = eventRow.value;\r\n        }\r\n        return start.lastTime;\r\n    }\r\n\r\n    public prepareLookup() {\r\n        // If multiple players have the same timing data, then adding to the\r\n        // lookups would probably cause FindEntryInLookup to return the wrong\r\n        // thing.  So release the lookups. -Kyz\r\n        this.releaseLookup();\r\n        const segmentsPerLookup = 16;\r\n        const segs = this.timingSegments;\r\n        const bpms = segs[TimingSegmentType.BPM];\r\n        const warps = segs[TimingSegmentType.WARP];\r\n        const stops = segs[TimingSegmentType.STOP];\r\n        const delays = segs[TimingSegmentType.DELAY];\r\n\r\n        const totalSegments = bpms.length + warps.length + stops.length + delays.length;\r\n        // extend the arrays with 'undefined' entries\r\n        for (let curSegment = segmentsPerLookup; curSegment < totalSegments; curSegment += segmentsPerLookup) {\r\n            const beatStart = new GetBeatStarts();\r\n            beatStart.lastTime = -this.beat0OffsetInSecs;\r\n            const args = new GetBeatArgs();\r\n            args.elapsedTime = Number.MAX_VALUE;\r\n            this.getBeatInternal(beatStart, args, curSegment);\r\n            this.beatStartLookup.push([args.elapsedTime, beatStart]);\r\n\r\n            const timeStart = new GetBeatStarts();\r\n            timeStart.lastTime = -this.beat0OffsetInSecs;\r\n            this.getElapsedTimeInternal(timeStart, Number.MAX_VALUE, curSegment);\r\n            this.timeStartLookup.push([NoteHelpers.noteRowToBeat(timeStart.lastRow), timeStart]);\r\n        }\r\n        // If there are less than two entries, then FindEntryInLookup in lookup\r\n        // will always decide there's no appropriate entry.  So clear the table.\r\n        // -Kyz\r\n        if (this.beatStartLookup.length < 2) { this.releaseLookup(); }\r\n    }\r\n\r\n    public releaseLookup() {\r\n        this.beatStartLookup = [];\r\n        this.timeStartLookup = [];\r\n    }\r\n\r\n    public segInfoStr(segs: TimingSegment[], index: number, name: string) {\r\n        if (index < segs.length) {\r\n            return `${name}: ${index} at ${segs[index].getRow()}`;\r\n        }\r\n        return `${name}: ${index} at end`;\r\n    }\r\n\r\n    public dumpOneLookupTable(lookup: BeatStartLookup, name: string) {\r\n        const segs = this.timingSegments;\r\n        const bpms = segs[TimingSegmentType.BPM];\r\n        const warps = segs[TimingSegmentType.WARP];\r\n        const stops = segs[TimingSegmentType.STOP];\r\n        const delays = segs[TimingSegmentType.DELAY];\r\n        console.debug(`${name} lookup table:`);\r\n        for (let lit = 0; lit < lookup.length; lit++) {\r\n            const item = lookup[lit];\r\n            if (item === undefined) { throw new Error('item should never be undefined'); }\r\n            const starts = item[1];\r\n            console.debug(`${lit}: ${item[0]}`);\r\n\r\n            const bpmInfo = this.segInfoStr(bpms, starts.bpm, 'bpm');\r\n            const warpInfo = this.segInfoStr(warps, starts.warp, 'warp');\r\n            const stopInfo = this.segInfoStr(stops, starts.stop, 'stop');\r\n            const delayInfo = this.segInfoStr(delays, starts.delay, 'delay');\r\n            const str = `  ${bpmInfo}, ${warpInfo}, ${stopInfo}, ${delayInfo},\\n` +\r\n                        `  lastRow: ${starts.lastRow}, lastTime: ${starts.lastTime},\\n` +\r\n                        `  warpDestination: ${starts.warpDestination}, isWarping: ${starts.isWarping}`;\r\n            console.debug(str);\r\n        }\r\n    }\r\n\r\n    public dumpLookupTables() {\r\n        console.debug('Dumping timing data lookup tables');\r\n        this.dumpOneLookupTable(this.beatStartLookup, 'beatStartLookup');\r\n        this.dumpOneLookupTable(this.timeStartLookup, 'timeStartLookup');\r\n        console.debug('Finished dumping lookup tables');\r\n    }\r\n\r\n\r\n    public empty() {\r\n        for (let tst = 0; tst < TimingSegmentType.NUM; tst++) {\r\n            if (this.timingSegments[tst].length > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the TimingSegment at the specified row.\r\n     * @param iNoteRow the row that has a TimingSegment.\r\n     * @param tst the TimingSegmentType requested.\r\n     * @return the segment in question.\r\n     */\r\n    public getSegmentAtRow(noteRow: number, tst: TimingSegmentType) {\r\n        const segments = this.getTimingSegments(tst);\r\n\r\n        if (segments.length === 0) {\r\n            const retSegment = DummySegments[tst];\r\n            if (retSegment === null) { throw new Error('FATAL: retSegment should never be null'); }\r\n            return retSegment;\r\n        }\r\n\r\n        const index = this.getSegmentIndexAtRow(tst, noteRow);\r\n        const seg = segments[index];\r\n\r\n        switch (seg.getEffectType()) {\r\n            case SegmentEffectType.Indefinite:\r\n                // this segment is in effect at this row\r\n                return seg;\r\n            default:\r\n                // if the returned segment isn't exactly on this row,\r\n                // we don't want it, return a dummy instead\r\n                if (seg.getRow() === noteRow) {\r\n                    return seg;\r\n                }\r\n                const retSegment = DummySegments[tst];\r\n                if (retSegment === null) { throw new Error('FATAL: retSegment should never be null'); }\r\n                return retSegment;\r\n        }\r\n    }\r\n\r\n    /* The following functions were all preprocessor defined so this is a giant block\r\n       of code compared to what was in the C++. Unfortunate. Maybe we can clean this up\r\n       one day -Struz */\r\n    public getBpmSegmentAtRow(noteRow: number) {\r\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.BPM);\r\n        return (t as BPMSegment);\r\n    }\r\n    public getStopSegmentAtRow(noteRow: number) {\r\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.STOP);\r\n        return (t as StopSegment);\r\n    }\r\n    public getDelaySegmentAtRow(noteRow: number) {\r\n        const t = this.getSegmentAtRow(noteRow, TimingSegmentType.DELAY);\r\n        return (t as DelaySegment);\r\n    }\r\n\r\n    /* convenience aliases (Set functions are deprecated) */\r\n    public getBpmAtRow(noteRow: number) { return this.getBpmSegmentAtRow(noteRow).getBpm(); }\r\n    public getStopAtRow(noteRow: number) { return this.getStopSegmentAtRow(noteRow).getPause(); }\r\n    public getDelayAtRow(noteRow: number) { return this.getDelaySegmentAtRow(noteRow).getPause(); }\r\n\r\n    public isWarpAtRow(noteRow: number) {\r\n        const warps = this.getTimingSegments(TimingSegmentType.WARP);\r\n        if (warps.length === 0) { return false; }\r\n\r\n        const i = this.getSegmentIndexAtRow(TimingSegmentType.WARP, noteRow);\r\n        if (i === -1) { return false; }\r\n\r\n        const s = warps[i] as WarpSegment;\r\n        const beatRow = NoteHelpers.noteRowToBeat(noteRow);\r\n        if (s.getBeat() <= beatRow && beatRow < (s.getBeat() + s.getLength())) {\r\n            // Allow stops inside warps to allow things like stop, warp, stop, warp, stop, and so on.\r\n            if (this.getTimingSegments(TimingSegmentType.STOP).length === 0 &&\r\n                this.getTimingSegments(TimingSegmentType.DELAY).length === 0) {\r\n                    return true;\r\n                }\r\n            if (this.getStopAtRow(noteRow) !== 0 || this.getDelayAtRow(noteRow) !== 0) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    public isWarpAtBeat(beat: number) { return this.isWarpAtRow(NoteHelpers.beatToNoteRow(beat)); }\r\n\r\n    public isFakeAtRow(noteRow: number) {\r\n        // We don't support fakes yet -Struz\r\n        return false;\r\n        // const fakes = this.getTimingSegments(TimingSegmentType.FAKE);\r\n        // if (fakes.length === 0) { return false; }\r\n\r\n        // const i = this.getSegmentIndexAtRow(TimingSegmentType.FAKE, noteRow);\r\n        // if (i === -1) { return false; }\r\n\r\n        // const s = fakes[i] as FakeSegment;\r\n    }\r\n    public isFakeAtBeat(beat: number) { return this.isFakeAtRow(NoteHelpers.beatToNoteRow(beat)); }\r\n\r\n    public isJudgableAtRow(row: number) { return !this.isWarpAtRow(row) && !this.isFakeAtRow(row); }\r\n    public isJudgableAtBeat(beat: number) { return this.isJudgableAtRow(NoteHelpers.beatToNoteRow(beat)); }\r\n\r\n    public adjustOffset(amount: number) {\r\n        this.setOffset(this.beat0OffsetInSecs + amount);\r\n    }\r\n\r\n    public setOffset(offset: number) {\r\n        if (offset !== this.beat0OffsetInSecs) {\r\n            this.beat0OffsetInSecs = offset;\r\n            // TODO: it's changed, we probably need to recompute the data for anything using it\r\n            // see: TimingData::set_offset in StepMania\r\n        }\r\n    }\r\n\r\n    public getOffset() {\r\n        return this.beat0OffsetInSecs;\r\n    }\r\n\r\n    public getTimingSegments(tst: TimingSegmentType) {\r\n        return this.timingSegments[tst];\r\n    }\r\n\r\n    public addSegment(seg: TimingSegment) {\r\n        // TODO: add debug logging flag and put a debug log here\r\n        const tst = seg.getType();\r\n        const segs = this.timingSegments[tst];\r\n\r\n        // Optimisation: if this is our first segment, push and return\r\n        if (segs.length === 0) {\r\n            // TODO: make sure this shallow copy actually works for all delay types\r\n            const cpy = Object.assign(Object.create(Object.getPrototypeOf(seg)), seg);\r\n            segs.push(cpy);\r\n            return;\r\n        }\r\n\r\n        const index = this.getSegmentIndexAtRow(tst, seg.getRow());\r\n        if (index === INVALID_INDEX) {\r\n            // TODO: make this error better\r\n            throw new Error('ASSERTION FAILED: index should not be INVALID_INDEX');\r\n        }\r\n        const cur: TimingSegment = segs[index];\r\n        const isNotable = seg.isNotable();\r\n        const onSameRow = seg.getRow() === cur.getRow();\r\n\r\n        // ignore changes that are zero and don't overwrite an existing segment\r\n        if (!isNotable && !onSameRow) {\r\n            return;\r\n        }\r\n\r\n        // TODO: all the splicing in here may have memory leaks if references remain - test this\r\n        switch (seg.getEffectType()) {\r\n            case SegmentEffectType.Row:\r\n            case SegmentEffectType.Range:\r\n                // if we're overwriting a change with a non-notable\r\n                // one, take it to mean deleting the existing segment\r\n                if (onSameRow && isNotable) {\r\n                    // Removes the element in-place\r\n                    segs.splice(index, 1);\r\n                    return;\r\n                }\r\n                break;\r\n            case SegmentEffectType.Indefinite:\r\n                let prev: TimingSegment = cur;\r\n\r\n                // get the segment before last; if we're on the same\r\n                // row, get the segment in effect before 'cur'\r\n                if (onSameRow && index > 0) {\r\n                    prev = segs[index - 1];\r\n                }\r\n                // If there is another segment after this one, it might become\r\n                // redundant when this one is inserted.\r\n                // If the next segment is redundant, we want to move its starting row\r\n                // to the row the new segment is being added at instead of erasing it\r\n                // and adding the new segment.\r\n                // If the new segment is also redundant, erase the next segment because\r\n                // that effectively moves it back to the prev segment. -Kyz\r\n                if (index < segs.length - 1) {\r\n                    const next: TimingSegment = segs[index + 1];\r\n                    if (seg.equals(next)) {\r\n                        // The segment after this new one is redundant\r\n                        if (seg.equals(prev)) {\r\n                            // This new segment is redundant.  Erase the next segment and\r\n                            // ignore this new one.\r\n                            segs.splice(index + 1, 1);\r\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\r\n                            // This seems to be shorthand for (onSameRow && index > 0) since that is the\r\n                            // only way I can see prev being !== cur based on above code.\r\n                            if (prev !== cur) {\r\n                                segs.splice(index, 1);\r\n                            }\r\n                            return;\r\n                        } else {\r\n                            // Move the next segment's start back to this row.\r\n                            next.setRow(seg.getRow());\r\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\r\n                            // See earlier comment about the shorthand this is for.\r\n                            if (prev !== cur) {\r\n                                segs.splice(index, 1);\r\n                            }\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        // if true, this is redundant segment change\r\n                        if (prev.equals(seg)) {\r\n                            // NOTE: this is actual pointer math in StepMania, not object .equals\r\n                            // See earlier comment about the shorthand this is for.\r\n                            if (prev !== cur) {\r\n                                segs.splice(index, 1);\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                } else {\r\n                    // if true, this is redundant segment change\r\n                    if (prev.equals(seg)) {\r\n                        // NOTE: this is actual pointer math in StepMania, not object .equals\r\n                        if (prev !== cur) {\r\n                            segs.splice(index, 1);\r\n                        }\r\n                        return;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // the segment at or before this row is equal to the new one; ignore it\r\n        // NOTE: this is NOT pointer math - it's a .equals\r\n        if (onSameRow && (cur.equals(seg))) {\r\n            return;\r\n        }\r\n\r\n        // Copy() the segment (which allocates a new segment), assign it\r\n        // to the position of the old one, then delete the old pointer.\r\n        // TODO: probably not the best way to do this in js -Struz\r\n        const copy = Object.assign(Object.create(Object.getPrototypeOf(seg)), seg);\r\n        if (onSameRow) {\r\n            // TODO: check memory leaks\r\n            // delete the existing segment and replace it\r\n            segs[index] = copy;\r\n        } else {\r\n            // Find the first element that isn't comparatively less than `copy`\r\n            let i = segs.findIndex((ts) => !ts.lessThan(copy));\r\n            if (i === -1) {\r\n                // No element is < copy, insert at end to maintain ordering\r\n                i = segs.length;\r\n            }\r\n\r\n            segs.splice(i, 0, copy);\r\n        }\r\n    }\r\n\r\n    public noteRowToMeasureAndBeat(\r\n        noteRow: number, measureIndexOut: PassByRef<number>,\r\n        beatIndexOut: PassByRef<number>, rowsRemainder: PassByRef<number>) {\r\n            // TODO: this function could have some weirdness given it was all with ints in\r\n            // C++ and we're using number here. If anything goes wrong try more Math.truncs\r\n            measureIndexOut.value = 0;\r\n            const tSigs = this.getTimingSegments(TimingSegmentType.TIME_SIG);\r\n            for (let i = 0; i < tSigs.length; i++) {\r\n                const curSig = (tSigs[i] as TimeSignatureSegment);\r\n                const segmentEndRow = (i + 1 === tSigs.length) ? Number.MAX_SAFE_INTEGER : curSig.getRow();\r\n\r\n                const rowsPerMeasureThisSegment = curSig.getNoteRowsPerMeasure();\r\n                // Usage of this variable fixes a bug from StepMania: https://github.com/stepmania/stepmania/issues/1080\r\n                const rowsPerBeatThisSegment = curSig.getNoteRowsPerBeat();\r\n\r\n                if (noteRow >= curSig.getRow()) {\r\n                    // noteRow lands in this segment\r\n                    const numRowsThisSegment = noteRow - curSig.getRow();\r\n                    // don't round up (below)\r\n                    const numMeasuresThisSegment = Math.trunc(numRowsThisSegment / rowsPerMeasureThisSegment);\r\n                    measureIndexOut.value += numMeasuresThisSegment;\r\n                    // These are all integers so we need to trunc for our callers benefit\r\n                    beatIndexOut.value = Math.trunc(numRowsThisSegment / rowsPerBeatThisSegment);\r\n                    rowsRemainder.value = numRowsThisSegment % rowsPerMeasureThisSegment;\r\n                    return;\r\n                } else {\r\n                    // noteRow lands after this segment\r\n                    const numRowsThisSegment = segmentEndRow - curSig.getRow();\r\n                    const numMeasuresThisSegment = Math.trunc(\r\n                        (numRowsThisSegment + rowsPerMeasureThisSegment - 1) / rowsPerMeasureThisSegment); // Round up\r\n                    measureIndexOut.value += numMeasuresThisSegment;\r\n                }\r\n            }\r\n            throw new Error('Failed to get measure and beat for note row');\r\n        }\r\n\r\n    public getSegmentIndexAtRow(tst: TimingSegmentType, row: number) {\r\n        const segs = this.timingSegments[tst];\r\n        if (segs.length === 0) {\r\n            return INVALID_INDEX;\r\n        }\r\n\r\n        // TODO: this not working? Not finding correct segment\r\n        // BECAUSE ITS ORDERED IN REVERSE\r\n\r\n        const min = 0;\r\n        const max = segs.length - 1;\r\n        let l = min;\r\n        let r = max;\r\n        // Do a binary search to find the row, if any\r\n        while ( l <= r ) {\r\n            const m = Math.trunc((l + r) / 2); // int\r\n            if ( ( m === min || segs[m].getRow() <= row ) && ( m === max || row < segs[m + 1].getRow() ) ) {\r\n                return m;\r\n            } else if (segs[m].getRow() <= row) {\r\n                l = m + 1;\r\n            } else {\r\n                r = m - 1;\r\n            }\r\n        }\r\n        // row is before first segment of type tst\r\n        return INVALID_INDEX;\r\n    }\r\n    public getSegmentIndexAtBeat(tst: TimingSegmentType, beat: number) {\r\n        return this.getSegmentIndexAtRow(tst, NoteHelpers.beatToNoteRow(beat));\r\n    }\r\n\r\n    public getNextSegmentBeatAtRow(tst: TimingSegmentType, row: number) {\r\n        const segs = this.getTimingSegments(tst);\r\n        for (const seg of segs) {\r\n            if (seg.getRow() <= row) { continue; }\r\n            return seg.getBeat();\r\n        }\r\n        return NoteHelpers.noteRowToBeat(row);\r\n    }\r\n    public getNextSegmentBeatAtBeat(tst: TimingSegmentType, beat: number) {\r\n        return this.getNextSegmentBeatAtRow(tst, NoteHelpers.beatToNoteRow(beat));\r\n    }\r\n\r\n    public getPreviousSegmentBeatAtRow(tst: TimingSegmentType, row: number) {\r\n        let backup = -1;\r\n        const segs = this.getTimingSegments(tst);\r\n        for (const seg of segs) {\r\n            if (seg.getRow() >= row) { break; }\r\n            backup = seg.getBeat();\r\n        }\r\n        return (backup > -1) ? backup : NoteHelpers.noteRowToBeat(row);\r\n    }\r\n    public getPreviousSegmentBeatAtBeat(tst: TimingSegmentType, beat: number) {\r\n        return this.getPreviousSegmentBeatAtRow(tst, NoteHelpers.beatToNoteRow(beat));\r\n    }\r\n\r\n    public getBeatFromElapsedTime(elapsedTime: number): number {\r\n        const args = new GetBeatArgs();\r\n        args.elapsedTime = elapsedTime;\r\n        this.getBeatAndBpsFromElapsedTime(args);\r\n        return args.beat;\r\n    }\r\n\r\n    public getBeatFromElapsedTimeNoOffset(second: number): number {\r\n        // We don't support offset yet so this function does the same. Pass through. -Struz\r\n        return this.getBeatFromElapsedTime(second);\r\n    }\r\n\r\n    public getElapsedTimeFromBeatNoOffset(beat: number): number {\r\n        let start = new GetBeatStarts();\r\n        start.lastTime = -this.beat0OffsetInSecs;\r\n        const lookedUpStart = TimingData.findEntryInLookup(this.timeStartLookup, beat);\r\n        if (lookedUpStart !== undefined) {\r\n            // Make sure to use a copy so we don't modify it again and again in getBeatInternal()\r\n            start = Object.assign(Object.create(Object.getPrototypeOf(lookedUpStart[1])), lookedUpStart[1]);\r\n        }\r\n        this.getElapsedTimeInternal(start, beat, Number.MAX_SAFE_INTEGER);\r\n        return start.lastTime;\r\n    }\r\n\r\n    public getElapsedTimeFromBeat(beat: number): number {\r\n        return this.getElapsedTimeFromBeatNoOffset(beat);\r\n        // The C++ code handles hasted music rate here but we don't implement that -Struz\r\n    }\r\n\r\n    public getBeatAndBpsFromElapsedTime(args: GetBeatArgs) {\r\n        // The C++ code handles hasted music rate here but we don't implement that -Struz\r\n        this.getBeatAndBpsFromElapsedTimeNoOffset(args);\r\n    }\r\n\r\n    public getBeatAndBpsFromElapsedTimeNoOffset(args: GetBeatArgs): void {\r\n        let start = new GetBeatStarts();\r\n        start.lastTime = -this.beat0OffsetInSecs;\r\n        const lookedUpStart = TimingData.findEntryInLookup(this.beatStartLookup, args.elapsedTime);\r\n        if (lookedUpStart !== undefined) {\r\n            // Make sure to use a copy so we don't modify it again and again in getBeatInternal()\r\n            start = Object.assign(Object.create(Object.getPrototypeOf(lookedUpStart[1])), lookedUpStart[1]);\r\n        }\r\n        this.getBeatInternal(start, args, Number.MAX_SAFE_INTEGER);\r\n    }\r\n\r\n    public getDisplayedSpeedPercent(songBeat: number, musicSeconds: number) {\r\n        const speeds = this.getTimingSegments(TimingSegmentType.SPEED);\r\n        if (speeds.length === 0) { return 1; }\r\n        return 1;\r\n\r\n        // TODO: finish me when we implement SpeedSegment\r\n\r\n        // const index = this.getSegmentIndexAtBeat(TimingSegmentType.SPEED, songBeat);\r\n\r\n        // const seg = (speeds[index] as SpeedSegment);\r\n    }\r\n\r\n    public tidyUpData(allowEmpty: boolean) {\r\n        if (allowEmpty && this.empty()) {\r\n            return;  // Steps with empty timing data revert to song timing\r\n        }\r\n\r\n        // If there are no BPM segments, provide a default.\r\n        if (this.timingSegments[TimingSegmentType.BPM].length === 0) {\r\n            console.warn('Song has no BPM segments, default 60 provided.');\r\n            this.addSegment(new BPMSegment(0, 60));\r\n        }\r\n\r\n        // Make sure the first BPM segment starts at beat 0.\r\n        if (this.timingSegments[TimingSegmentType.BPM][0].getRow() !== 0) {\r\n            this.timingSegments[TimingSegmentType.BPM][0].setRow(0);\r\n        }\r\n\r\n        // If no time signature specified, assume default time for the whole song.\r\n        if (this.timingSegments[TimingSegmentType.TIME_SIG].length === 0) {\r\n            this.addSegment(new TimeSignatureSegment(0));\r\n        }\r\n\r\n        // Likewise, if no tickcount signature is specified, assume 4 ticks\r\n        // per beat for the entire song. The default of 4 is chosen more\r\n        // for compatibility with the main Pump series than anything else.\r\n        // (TickcountSegment's constructor handles that now. -- vyhd)\r\n        if (this.timingSegments[TimingSegmentType.TICKCOUNT].length === 0) {\r\n            this.addSegment(new TickcountSegment(0));\r\n        }\r\n\r\n        // Have a default combo segment of one just in case.\r\n        // if (this.timingSegments[TimingSegmentType.COMBO].length === 0) {\r\n        //     this.addSegment(new ComboSegment(0));\r\n        // }\r\n        // TODO: uncomment when we implement combo segments\r\n\r\n        // Have a default label segment just in case.\r\n        // if (this.timingSegments[TimingSegmentType.LABEL].length === 0) {\r\n        //     this.addSegment(new LabelSegment(0));\r\n        // }\r\n        // TODO: uncomment when we implement label segments\r\n\r\n        // Always be sure there is a starting speed.\r\n        // if (this.timingSegments[TimingSegmentType.SPEED].length === 0) {\r\n        //     this.addSegment(new SpeedSegment(0));\r\n        // }\r\n        // IMPORTANT: uncomment when we implement speed segments\r\n\r\n        // Always be sure there is a starting scrolling factor.\r\n        // if (this.timingSegments[TimingSegmentType.SCROLL].length === 0) {\r\n        //     this.addSegment(new ScrollSegment(0));\r\n        // }\r\n        // IMPORTANT: uncomment when we implement speed segments\r\n    }\r\n}\r\nexport default TimingData;\r\n","import hrtime from 'browser-process-hrtime';\r\n\r\n/** Seconds per microsecond. */\r\nconst TIMESTAMP_RESOLUTION = 1000000;\r\nconst NANOSECONDS_PER_MICROSECOND = 1000;\r\n\r\n/** A way to keep track of time in a way that shouldn't overflow. */\r\ninterface PreciseTime {\r\n    secs: number; /** Seconds */\r\n    us: number;   /** Microseconds */\r\n}\r\n\r\n/** A mirror of RageTimer */\r\nexport class GameTimer {\r\n    /** Returns the number of seconds and microseconds since init. */\r\n    public static getTime() {\r\n        const time = hrtime();\r\n        const secs = time[0];\r\n        const us = Math.trunc(time[1] / NANOSECONDS_PER_MICROSECOND);\r\n        if (GameTimer.initTimeSecs === 0) {\r\n            GameTimer.initTimeSecs = secs;\r\n            GameTimer.initTimeUs = us;\r\n        }\r\n\r\n        let deltaSecs = secs - GameTimer.initTimeSecs;\r\n        let deltaUs = us - GameTimer.initTimeUs;\r\n        if (deltaUs < 0) {\r\n            deltaUs += TIMESTAMP_RESOLUTION;\r\n            --deltaSecs;\r\n        }\r\n        return { secs: deltaSecs, us: deltaUs };\r\n    }\r\n\r\n    private static initTimeSecs = 0;\r\n    private static initTimeUs = 0;\r\n\r\n    /** Adds a number of seconds to a GameTimer\r\n     *  and returns a GameTimer that contains the added time.\r\n     */\r\n    private static sum(lhs: GameTimer, tm: number): GameTimer {\r\n        /* tm == 5.25  -> secs =  5, us = 5.25  - ( 5) = .25\r\n\t     * tm == -1.25 -> secs = -2, us = -1.25 - (-2) = .75 */\r\n        // From what I can gather, tm is a float representing seconds - Struz\r\n        const seconds = Math.trunc(tm); // Int\r\n        const us = Math.trunc( (tm - seconds) * TIMESTAMP_RESOLUTION ); // Int\r\n\r\n        const ret = new GameTimer(0, 0); // Prevent unnecessarily checking the time via .touch()\r\n        ret.secs = seconds + lhs.secs;\r\n        ret.us = us + lhs.us;\r\n\r\n        if (ret.us >= TIMESTAMP_RESOLUTION) {\r\n            ret.us -= TIMESTAMP_RESOLUTION;\r\n            ++ret.secs;\r\n        }\r\n        return ret;\r\n    }\r\n    /** The difference between two GameTimers in seconds, as a float. */\r\n    private static difference(lhs: GameTimer, rhs: GameTimer) {\r\n        let secs = lhs.secs - rhs.secs;\r\n        let us = lhs.us - rhs.us;\r\n\r\n        if (us < 0) {\r\n            us += TIMESTAMP_RESOLUTION;\r\n            --secs;\r\n        }\r\n        return secs + us / TIMESTAMP_RESOLUTION;\r\n    }\r\n\r\n    public secs: number;\r\n    public us: number;\r\n\r\n    constructor(secs?: number, us?: number) {\r\n        // Constructor: (secs, us)\r\n        if (secs !== undefined && us !== undefined) {\r\n            this.secs = secs;\r\n            this.us = us;\r\n            return;\r\n        }\r\n        // Constructor: ()\r\n        this.secs = 0;\r\n        this.us = 0;\r\n        this.touch();\r\n        return;\r\n    }\r\n\r\n    public ago(): number {\r\n        const now = new GameTimer();\r\n        return now.subtract(this);\r\n    }\r\n    public touch(): void {\r\n        const time = GameTimer.getTime();\r\n        this.secs = time.secs;\r\n        this.us = time.us;\r\n    }\r\n    public isZero(): boolean { return this.secs === 0 && this.us === 0; }\r\n    public setZero() { this.secs = 0; this.us = 0; }\r\n\r\n    /** Time between last call to GetDeltaTime() (Ago() + Touch()): */\r\n    public getDeltaTime() {\r\n        const now = new GameTimer();\r\n        const diff = GameTimer.difference(now, this);\r\n        // This is just .touch() but saves us a call to getTime()\r\n        this.secs = now.secs;\r\n        this.us = now.us;\r\n        return diff;\r\n    }\r\n    /* (alias) */\r\n    public peekDeltaTime() { return this.ago(); }\r\n\r\n    /*\r\n    * Get a timer representing half of the time ago as this one.  This is\r\n    * useful for averaging time.  For example,\r\n    *\r\n    * GameTimer tm;\r\n    * ... do stuff ...\r\n    * GameTimer AverageTime = tm.Half();\r\n    * printf( \"Something happened approximately %f seconds ago.\\n\", tm.Ago() );\r\n    */\r\n    public half() {\r\n        const probableDelay = this.ago() / 2;\r\n        return this.add(probableDelay);\r\n    }\r\n\r\n    // TODO operators\r\n    /** Add a number of seconds to this game timer. */\r\n    public add(tm: number) {\r\n        return GameTimer.sum(this, tm);\r\n    }\r\n    public subtract(rhs: GameTimer) {\r\n        return GameTimer.difference(this, rhs);\r\n    }\r\n    public lessThan(rhs: GameTimer) {\r\n        if (this.secs !== rhs.secs) { return this.secs < rhs.secs; }\r\n        return this.us < rhs.us;\r\n    }\r\n}\r\nexport default GameTimer;\r\n\r\nexport const gZeroTimer = new GameTimer(0, 0);\r\n","// tslint:disable: max-line-length\r\n\r\nexport const EXPECTED_FPS = 60;\r\n\r\n// The different game categories available to play.\r\n// Taken from commit b95e49216eb2974b8e0f69b6603595df1c698ccd\r\nexport enum StepsTypeCategory {\r\n    Single, // One person plays on one side.\r\n    Double, // One person plays on both sides.\r\n    Couple, // Two players play on their own side.\r\n    Routine, // Two players share both sides together.\r\n}\r\n\r\n// The different steps types for playing.\r\n// Taken from commit b95e49216eb2974b8e0f69b6603595df1c698ccd\r\nexport enum StepsType {\r\n    dance_single = 0,\r\n    dance_double,\r\n    dance_couple,\r\n    dance_solo,\r\n    dance_threepanel,\r\n    dance_routine,\r\n    pump_single,\r\n    pump_halfdouble,\r\n    pump_double,\r\n    pump_couple,\r\n    pump_routine,\r\n    kb7_single,\r\n    ez2_single,\r\n    ez2_double,\r\n    ez2_real,\r\n    para_single,\r\n    ds3ddx_single,\r\n    beat_single5,\r\n    beat_versus5,\r\n    beat_double5,\r\n    beat_single7,\r\n    beat_versus7,\r\n    beat_double7,\r\n    maniax_single,\r\n    maniax_double,\r\n    techno_single4,\r\n    techno_single5,\r\n    techno_single8,\r\n    techno_double4,\r\n    techno_double5,\r\n    techno_double8,\r\n    popn_five,\r\n    popn_nine,\r\n    lights_cabinet,\r\n    kickbox_human,\r\n    kickbox_quadarm,\r\n    kickbox_insect,\r\n    kickbox_arachnid,\r\n    NUM, \t// leave this at the end\r\n    Invalid,\r\n}\r\n\r\n// The collective information about a Steps' type\r\nexport class StepsTypeInfo {\r\n    // The name of the step type\r\n    public stepTypeName: string;\r\n    // The number of tracks, or columns, of this type.\r\n    public numTracks: number;\r\n    // A flag to determine if we allow this type to be autogen'ed to other types.\r\n    public allowAutogen: boolean;\r\n    // The most basic StyleType that this StpesTypeInfo is used with.\r\n    public stepsTypeCategory: StepsTypeCategory;\r\n\r\n    constructor(stepTypeName: string, numTracks: number,\r\n                allowAutogen: boolean, stepsTypeCategory: StepsTypeCategory) {\r\n        this.stepTypeName = stepTypeName;\r\n        this.numTracks = numTracks;\r\n        this.allowAutogen = allowAutogen;\r\n        this.stepsTypeCategory = stepsTypeCategory;\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.stepTypeName;\r\n    }\r\n}\r\n\r\n// Information about all the step types we support. Taken from StepMania\r\n// GameManager.cpp at line 50, commit b95e49216eb2974b8e0f69b6603595df1c698ccd\r\n// The indexes here must match the indexes in the enum.\r\n// TODO: this is really ugly without the full enum names linked here - Fix when have time.\r\nexport const StepsTypeInfos: StepsTypeInfo[] = [\r\n    // dance\r\n    new StepsTypeInfo('dance-single', 4, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('dance-double', 8, true, StepsTypeCategory.Double),\r\n    new StepsTypeInfo('dance-couple', 8, true, StepsTypeCategory.Couple),\r\n    new StepsTypeInfo('dance-solo', 6, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('dance-threepanel', 3, true, StepsTypeCategory.Single), // thanks to kurisu\r\n    new StepsTypeInfo('dance-routine', 8, false, StepsTypeCategory.Routine),\r\n    // pump\r\n    new StepsTypeInfo('pump-single', 5, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('pump-halfdouble', 6, true, StepsTypeCategory.Double),\r\n    new StepsTypeInfo('pump-double', 10, true, StepsTypeCategory.Double),\r\n    new StepsTypeInfo('pump-couple', 10, true, StepsTypeCategory.Couple),\r\n    // uh, dance-routine has that one bool as false... wtf? -aj\r\n    new StepsTypeInfo('pump-routine', 10, true, StepsTypeCategory.Routine),\r\n    // kb7\r\n    new StepsTypeInfo('kb7-single', 7, true, StepsTypeCategory.Single),\r\n    // new StepsTypeInfo('kb7-small', 7, true, StepsTypeCategory.Single),\r\n    // ez2dancer\r\n    new StepsTypeInfo('ez2-single', 5, true, StepsTypeCategory.Single), // Single: TL,LHH,D,RHH,TR\r\n    new StepsTypeInfo('ez2-double', 10, true, StepsTypeCategory.Double), // Double: Single x2\r\n    new StepsTypeInfo('ez2-real', 7, true, StepsTypeCategory.Single), // Real: TL,LHH,LHL,D,RHL,RHH,TR\r\n    // parapara paradise\r\n    new StepsTypeInfo('para-single', 5, true, StepsTypeCategory.Single),\r\n    // ds3ddx\r\n    new StepsTypeInfo('ds3ddx-single', 8, true, StepsTypeCategory.Single),\r\n    // beatmania\r\n    new StepsTypeInfo('bm-single5', 6, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\r\n    new StepsTypeInfo('bm-versus5', 6, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\r\n    new StepsTypeInfo('bm-double5', 12, true, StepsTypeCategory.Double), // called \"bm\" for backward compat\r\n    new StepsTypeInfo('bm-single7', 8, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\r\n    new StepsTypeInfo('bm-versus7', 8, true, StepsTypeCategory.Single), // called \"bm\" for backward compat\r\n    new StepsTypeInfo('bm-double7', 16, true, StepsTypeCategory.Double), // called \"bm\" for backward compat\r\n    // dance maniax\r\n    new StepsTypeInfo('maniax-single', 4, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('maniax-double', 8, true, StepsTypeCategory.Double),\r\n    // technomotion\r\n    new StepsTypeInfo('techno-single4', 4, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('techno-single5', 5, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('techno-single8', 8, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('techno-double4', 8, true, StepsTypeCategory.Double),\r\n    new StepsTypeInfo('techno-double5', 10, true, StepsTypeCategory.Double),\r\n    new StepsTypeInfo('techno-double8', 16, true, StepsTypeCategory.Double),\r\n    // pop'n music\r\n    new StepsTypeInfo('pnm-five', 5, true, StepsTypeCategory.Single), // called \"pnm\" for backward compat\r\n    new StepsTypeInfo('pnm-nine', 9, true, StepsTypeCategory.Single), // called \"pnm\" for backward compat\r\n    // cabinet lights and other fine StepsTypes that don't exist lol\r\n    new StepsTypeInfo('lights-cabinet', 6, false, StepsTypeCategory.Single), // XXX disable lights autogen for now\r\n    // kickbox mania\r\n    new StepsTypeInfo('kickbox-human', 4, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('kickbox-quadarm', 4, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('kickbox-insect', 6, true, StepsTypeCategory.Single),\r\n    new StepsTypeInfo('kickbox-arachnid', 8, true, StepsTypeCategory.Single),\r\n];\r\n\r\n// TODO: pull difficulty stuff into another file\r\n// Player number stuff\r\nexport enum Difficulty {\r\n    Beginner,\r\n    Easy,\r\n    Medium,\r\n    Hard,\r\n    Challenge,\r\n    Edit,\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\nconst OldStyleStringToDifficultyMap: Map<string, Difficulty> = new Map([\r\n    ['beginner', Difficulty.Beginner],\r\n    ['easy', Difficulty.Easy],\r\n    ['basic', Difficulty.Easy],\r\n    ['light', Difficulty.Easy],\r\n    ['medium', Difficulty.Medium],\r\n    ['another', Difficulty.Medium],\r\n    ['trick', Difficulty.Medium],\r\n    ['standard', Difficulty.Medium],\r\n    ['difficult', Difficulty.Medium],\r\n    ['hard', Difficulty.Hard],\r\n    ['ssr', Difficulty.Hard],\r\n    ['maniac', Difficulty.Hard],\r\n    ['heavy', Difficulty.Hard],\r\n    ['smaniac', Difficulty.Challenge],\r\n    ['challenge', Difficulty.Challenge],\r\n    ['expert', Difficulty.Challenge],\r\n    ['oni', Difficulty.Challenge],\r\n    ['edit', Difficulty.Edit],\r\n]);\r\n\r\n// Define the mininum and maximum chart difficulty value allowed.\r\nconst MIN_METER = 1;\r\nconst MAX_METER = 35;\r\n\r\n/** Hacky way to pass things by reference without too much overhead. */\r\nexport interface PassByRef<T> {\r\n    value: T;\r\n}\r\n\r\n// Disabled so we can group collective things up in this file\r\n// tslint:disable-next-line: max-classes-per-file\r\nexport class Helpers {\r\n    public static stringToStepsType(stepsType: string): StepsType {\r\n        for (let i = 0; i < StepsTypeInfos.length; i++) {\r\n            if (StepsTypeInfos[i].stepTypeName === stepsType) {\r\n                return i;\r\n            }\r\n        }\r\n        return StepsType.Invalid;\r\n    }\r\n\r\n    public static getStepsTypeInfo(st: StepsType) {\r\n        if (st >= StepsType.NUM) {\r\n            throw new Error(`getStepsTypeInfo(): Invalid steps type index ${st}`);\r\n        }\r\n        return StepsTypeInfos[st];\r\n    }\r\n\r\n    public static oldStyleStringToDifficulty(oldDifficulty: string): Difficulty {\r\n        const difficulty = OldStyleStringToDifficultyMap.get(oldDifficulty.toLowerCase());\r\n        if (difficulty === undefined) {\r\n            return Difficulty.Invalid;\r\n        }\r\n        return difficulty;\r\n    }\r\n\r\n    public static HHMMSSToSeconds(HHMMSS: string) {\r\n        const arrayBits = HHMMSS.split(':');\r\n        while (arrayBits.length < 3) {\r\n            arrayBits.splice(0, 0, '0'); // pad missing bits\r\n        }\r\n        let seconds = 0;\r\n        seconds += this.stringToInt(arrayBits[0]) * 60 * 60;\r\n        seconds += this.stringToInt(arrayBits[1]) * 60;\r\n        seconds += this.stringToFloat(arrayBits[2]);\r\n        return seconds;\r\n    }\r\n\r\n    /**\r\n     * Return a list of values for the enum, not including Invalid.\r\n     * Enum must have a .NUM element for this to work.\r\n     *\r\n     * Uses some any magic, but we expect to only return numbers.\r\n     */\r\n    public static forEachEnum(gameEnum: { NUM: number }): number[] {\r\n        const iterator: number[] = [];\r\n        const keys = Object.keys(gameEnum);\r\n        const values = keys.map((k) => {\r\n            if (k === 'NUM') { return; }\r\n            const value = (gameEnum as any)[k as any];\r\n            if (value < gameEnum.NUM) {\r\n                iterator.push(value);\r\n            }\r\n        });\r\n        return iterator;\r\n    }\r\n\r\n    /** Clamp a number to be between min and max. */\r\n    public static clamp(num: number, min: number, max: number): number {\r\n        return Math.min(Math.max(num, min), max);\r\n    }\r\n\r\n    // StringToInt and StringToFloat are wrappers around std::stoi and std::stof\r\n    // which handle the exception by returning 0.  Reporting the exception would\r\n    // be cumbersome, and there are probably a million things that rely on an\r\n    // \"invalid\" string being silently converted to 0.  This includes cases where\r\n    // someone uses an empty string and expects it to come out 0, probably\r\n    // frequently used in metrics. -Kyz\r\n\r\n    /** Like parseInt(x, 10) but instead of NaN it returns 0. */\r\n    public static stringToInt(str: string) {\r\n        const int = parseInt(str, 10);\r\n        if (isNaN(int)) {\r\n            return 0;\r\n        }\r\n        return int;\r\n    }\r\n    /** Like parseFloat(x) but instead of NaN it returns 0. */\r\n    public static stringToFloat(str: string) {\r\n        const float = parseFloat(str);\r\n        if (isNaN(float)) {\r\n            return 0.0;\r\n        }\r\n        return float;\r\n    }\r\n\r\n    /** Interpolate within the ranges and interlopant. */\r\n    public static lerp(x: number, l: number, h: number) {\r\n        return (h - l) * x + l;\r\n    }\r\n\r\n    /** Scale the target number so that the two targets match.\r\n     *\r\n     * This does not modify x, so it MUST assign the result to something!\r\n     * Do the multiply before the divide so that integer scales have more precision.\r\n     *\r\n     * One such example: scale(x, 0, 1, L, H); interpolate between L and H.\r\n     */\r\n    public static scale(x: number, l1: number, h1: number, l2: number, h2: number) {\r\n        return ( l1 === 0 && h1 === 1 ) ? Helpers.lerp(x, l2, h2) : (x - l1) * (h2 - l2) / (h1 - l1) + l2;\r\n    }\r\n}\r\nexport default Helpers;\r\n","import { Howl } from 'howler';\r\nimport { debug } from 'util';\r\n\r\n// Simple wrapper for a playable song. This is so we can\r\n// extend the functionality if we need to, for example\r\n// by padding silence.\r\nclass SongSound {\r\n    /** The actual song sound bytes. */\r\n    protected sound: Howl;\r\n\r\n    constructor(sound: Howl) {\r\n        this.sound = sound;\r\n    }\r\n\r\n    public play(at?: number) {\r\n        if (at !== undefined) {\r\n            this.seek(at);\r\n        }\r\n        this.sound.play();\r\n    }\r\n\r\n    public pause() {\r\n        this.sound.pause();\r\n    }\r\n\r\n    public seek(time: number) {\r\n        this.sound.seek(time);\r\n    }\r\n\r\n    public getSound() { return this.sound; }\r\n    public getTimeElapsed() {\r\n        const timeElapsed = this.sound.seek() as number;\r\n        return timeElapsed;\r\n    }\r\n}\r\nexport default SongSound;\r\n","import GAMESTATE from './GameState';\r\nimport NoteHelpers, { ROWS_PER_BEAT } from './NoteTypes';\r\nimport TimingData from './TimingData';\r\nimport { BPMSegment } from './TimingSegments';\r\nimport { EXPECTED_FPS } from './GameConstantsAndTypes';\r\nimport { DebugTools } from './Debug';\r\nimport SongSound from './SongSound';\r\n\r\n/** The amount of time in seconds that is allowable to drift from\r\n * the playing music.\r\n */\r\nconst MAX_TOLERATED_DRIFT_SECS = (1 / EXPECTED_FPS) * 2; // 2 frames @ 60fps\r\nconst DRIFT_SECS_BEFORE_UPDATE = 0.05;\r\n\r\nexport class MusicPlaying {\r\n    public music: SongSound;\r\n    public timing: TimingData;\r\n\r\n    public hasTiming = false;\r\n    public applyMusicRate = false;\r\n\r\n    // Anything else we need to sync up things\r\n\r\n    constructor(music: Howl, timing: TimingData) {\r\n        this.music = new SongSound(music);\r\n        this.timing = timing;\r\n    }\r\n\r\n    public hasMusic() {\r\n        return this.music !== undefined;\r\n    }\r\n}\r\n\r\nexport class MusicToPlay {\r\n    public hasTiming = false;\r\n    public timing: TimingData | undefined;\r\n\r\n    public startSeconds = 0;\r\n    public lengthSeconds = 0;\r\n    public fadeInLengthSeconds = 0;\r\n    public fadeOutLengthSeconds = 0;\r\n    public forceLoop = false;\r\n    public alignBeat = false;\r\n    public applyMusicRate = false;\r\n\r\n    // Unlike StepMania we pass in a preloaded, ready-to-play, bit of music\r\n    public music: Howl | undefined;\r\n}\r\n\r\nexport class GameSoundManager {\r\n    // Singleton\r\n    public static getInstance() {\r\n        if (!GameSoundManager.instance) {\r\n            GameSoundManager.instance = new GameSoundManager();\r\n        }\r\n        return GameSoundManager.instance;\r\n    }\r\n    private static instance: GameSoundManager;\r\n\r\n    /** The music we're currently playing, if any. */\r\n    private musicPlaying: MusicPlaying | undefined;\r\n    /** Whether we are currently updating the song timer. When false we can pause / seek without\r\n     * things going wonky.\r\n     */\r\n    private updatingTimer = false;\r\n\r\n    /** The last processed beat that was crossed. An integer. */\r\n    private beatLastCrossed = 0;\r\n\r\n    /** Tracks the number of seconds we've been out of sync with the song for. If it\r\n     * exceeds a threshold then we will forcibly resync.\r\n     * This is necessary because the song timing updates are not frame-frequent.\r\n     */\r\n    private outOfSyncSecs = 0;\r\n\r\n    // Private constructor for singleton pattern\r\n    private constructor() {\r\n        // Nothing to do here\r\n    }\r\n\r\n    public pauseMusic() {\r\n        if (this.musicPlaying !== undefined) {\r\n            this.musicPlaying.music.pause();\r\n        }\r\n    }\r\n\r\n    public resumeMusic() {\r\n        if (this.musicPlaying !== undefined) {\r\n            this.musicPlaying.music.play();\r\n        }\r\n    }\r\n\r\n    public musicSeek(seekTimeSeconds: number) {\r\n        if (this.musicPlaying !== undefined) {\r\n            this.musicPlaying.music.seek(seekTimeSeconds);\r\n        }\r\n    }\r\n\r\n    public musicSkipforwards(seekTimeSeconds: number) {\r\n        if (this.musicPlaying !== undefined) {\r\n            const currentTimeSeconds = this.musicPlaying.music.getTimeElapsed();\r\n            this.musicPlaying.music.seek(currentTimeSeconds + seekTimeSeconds);\r\n        }\r\n    }\r\n\r\n    public getMusicTimeSeconds() {\r\n        if (this.musicPlaying !== undefined) {\r\n            return this.musicPlaying.music.getTimeElapsed();\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public getMusicTiming() {\r\n        if (this.musicPlaying !== undefined) {\r\n            return this.musicPlaying.timing;\r\n        }\r\n        return new TimingData();\r\n    }\r\n\r\n    public startMusic(toPlay: MusicToPlay) {\r\n        // TODO: have a gate at the top that stops us playing the same file twice\r\n\r\n        // Loading of music is taken care of elsewhere - it's already in memory\r\n        if (toPlay.music === undefined || toPlay.music.state() !== 'loaded') {\r\n            throw new Error('toPlay.music must be provided and loaded');\r\n        }\r\n        if (toPlay.timing === undefined) { throw new Error('toPlay.timing must be provided'); }\r\n        const newMusic = new MusicPlaying(toPlay.music, toPlay.timing);\r\n\r\n        // Omitted loop stuff from StepMania for now - we will need this eventually -Struz\r\n        // Currently stuff like 24h crapyard scent streams won't render\r\n\r\n        // If we have an active timer try to start on the next update. Otherwise, start now.\r\n        // TODO ^\r\n\r\n        newMusic.hasTiming = toPlay.hasTiming;\r\n        newMusic.music.seek(toPlay.startSeconds);\r\n        // TODO: support toPlay.lengthSeconds somehow\r\n        // TODO: support fade in / fade out\r\n        // TODO: support start times in the future which would be buffered with silence aka not playing.\r\n        //       see RageSoundDriver_Generic_Software.cpp:88\r\n        if (toPlay.forceLoop) {\r\n            newMusic.music.getSound().loop(true);\r\n        }\r\n\r\n        newMusic.music.play();\r\n        if (!toPlay.forceLoop) {\r\n            // With loops this would fire on the end of each loop\r\n            newMusic.music.getSound().on('end', () => {\r\n                // When the song has ended, stop wasting processing cycles\r\n                this.handleSongTimer(false);\r\n            });\r\n        }\r\n        this.musicPlaying = newMusic;\r\n    }\r\n\r\n    public handleSongTimer(on: boolean) {\r\n        this.updatingTimer = on;\r\n    }\r\n    public isHandlingSongTimer() { return this.updatingTimer; }\r\n\r\n    // The idea here is to fake the sounds playing for now and just move the song position along\r\n    public update(deltaTime: number) {\r\n        if (!this.updatingTimer) { return; }\r\n\r\n        const playbackRate = 1.0;\r\n        // If we have some timing data then we can update the song position\r\n        // TODO: once we're past the end of the song probably stop doing this\r\n        if (GAMESTATE.curSong !== undefined) {\r\n            GAMESTATE.updateSongPosition(GAMESTATE.position.musicSeconds + deltaTime\r\n                    * playbackRate, GAMESTATE.curSong.songTiming);\r\n        }\r\n        // NOTE: the above is fudging and hoping, when actually playing music we *may* need to sync\r\n        // by getting the seconds from the song.\r\n\r\n        // Send crossed messages\r\n        if (GAMESTATE.curSong !== undefined) {\r\n            const songBeat = GAMESTATE.position.songBeat;\r\n            let rowNow = NoteHelpers.beatToNoteRowNotRounded(songBeat);\r\n            rowNow = Math.max(0, rowNow);\r\n\r\n            const beatNow = Math.trunc(rowNow / ROWS_PER_BEAT);  // int\r\n\r\n            for (let beat = this.beatLastCrossed + 1; beat <= beatNow; beat++) {\r\n                // TODO: Broadcast \"CrossedBeat\" message for all beats crossed since the last update\r\n                // Need some kind of message queue system but it's single threaded ...\r\n                // Will fire multiple itmes if multiple beats have been crossed due to lag.\r\n            }\r\n\r\n            this.beatLastCrossed = beatNow;\r\n        }\r\n\r\n        this.resyncSongTimingWithMusicPosition(deltaTime);\r\n    }\r\n\r\n    public resyncSongTimingWithMusicPosition(deltaTime: number, updateIfMusicNotPlaying = false) {\r\n        // If we've drifted too far from the song we need to speed up or slow down to meet it.\r\n        // Because nobody is actually playing the song we can just teleport forwards or backwards.\r\n        // If at any point people are actually playing we will need a more elegant method to sync\r\n        // back up.\r\n\r\n        // We don't want to do this unless the drift is signifiant or it could cause a lot of\r\n        // teleporting arrows.\r\n\r\n        // If we don't have anything to sync, bail out\r\n        if (GAMESTATE.curSong === undefined || this.musicPlaying === undefined) { return; }\r\n        // If the music isn't playing and we don't want to update if it's not playing, bail out\r\n        if (!this.musicPlaying.music.getSound().playing() && !updateIfMusicNotPlaying) { return; }\r\n\r\n        // TODO: work out if we should be using visible or regular here. I say regular because\r\n        // we do modifications on that to work out what to show with global offset etc etc -Struz\r\n        const musicPlayingPosSeconds = this.musicPlaying.music.getTimeElapsed();\r\n        const drift = Math.abs(musicPlayingPosSeconds - GAMESTATE.position.musicSeconds);\r\n        if (drift > MAX_TOLERATED_DRIFT_SECS) {\r\n            // console.log(`drifted: ${drift * 1000}ms`);\r\n            this.outOfSyncSecs += drift;\r\n\r\n            // If we've been drifted for too long, resync\r\n            if (this.outOfSyncSecs > DRIFT_SECS_BEFORE_UPDATE) {\r\n                this.outOfSyncSecs = 0;\r\n                // Always sync to the music rather than the other way around. It's less jarring.\r\n                GAMESTATE.updateSongPosition(musicPlayingPosSeconds, this.musicPlaying.timing);\r\n                console.log('resynced song to music');\r\n                // DebugTools.PAUSE();\r\n            }\r\n        } else {\r\n            this.outOfSyncSecs = 0;\r\n        }\r\n        // TODO: use averaging across update cycles to get the \"real\" song timing\r\n        // since the timing reported by media objects is not particularly accurate.\r\n        // We could also use literal timestamps i.e. Date, or resync from the startup\r\n        // GameTimer.\r\n    }\r\n}\r\nconst SOUNDMAN = GameSoundManager.getInstance();\r\nexport default SOUNDMAN;\r\n","import GAMESTATE from './GameState';\r\nimport SOUNDMAN from './GameSoundManager';\r\nimport { EXPECTED_FPS } from './GameConstantsAndTypes';\r\n\r\n// Debug helpers\r\n\r\n// Ideally we find a way to completely compile this out in certain builds\r\nexport function DEBUG_ASSERT(cond: boolean) {\r\n    if (!cond) {\r\n// tslint:disable-next-line: no-debugger\r\n        debugger;\r\n        console.debug('Debug assert failed.');\r\n        console.trace();\r\n    }\r\n}\r\n\r\nexport function ASSERT(cond: boolean, message: string) {\r\n    if (!cond) {\r\n        throw new Error(message);\r\n    }\r\n}\r\n\r\n// How to use the debug tools:\r\n// 1. Put a DebugTools.PAUSE() call where you would normally want a breakpoint.\r\n// 2. Use window.debugTools.FRAME_ADVANCE() to move forwards as you wish.\r\n// 3. Use breakpoints via the debugger to place a breakpoint before advancing.\r\nexport class DebugTools {\r\n    public static PAUSE() {\r\n        GAMESTATE.pause();\r\n        SOUNDMAN.pauseMusic();\r\n// tslint:disable-next-line: no-debugger\r\n        debugger;\r\n    }\r\n    public static PLAY() {\r\n        GAMESTATE.play();\r\n        SOUNDMAN.resumeMusic();\r\n    }\r\n    public static FRAME_ADVANCE(numFrames = 1) {\r\n        const timeAdvanceSeconds = numFrames * (1 / EXPECTED_FPS);\r\n        SOUNDMAN.musicSkipforwards(timeAdvanceSeconds);\r\n        GAMESTATE.updateSongPosition(SOUNDMAN.getMusicTimeSeconds(), SOUNDMAN.getMusicTiming());\r\n// tslint:disable-next-line: no-debugger\r\n        debugger;\r\n    }\r\n}\r\n","import TimingData, { GetBeatArgs } from './TimingData';\r\nimport { GameTimer } from './GameTimer';\r\nimport { ASSERT } from './Debug';\r\n\r\n// TODO: support delays and offsets?\r\nconst gVisualDelaySeconds = 0;\r\n\r\n/** Tracks how far through the song we are.\r\n *  Is basically a struct rather than a class.\r\n */\r\nexport class SongPosition {\r\n    public musicSeconds = 0;\r\n    public songBeat = 0;\r\n    public songBeatNoOffset = 0;\r\n    public curBps = 0;\r\n    /** A flag to determine if we're in the middle of a freeze/stop. */\r\n    public freeze = false;\r\n    /** A flag to determine if we're in the middle of a delay (Pump style stop). */\r\n    public delay = false;\r\n    /** The row used to start a warp. */\r\n    public warpBeginRow = 0;\r\n    /** The beat to warp to afterwards. */\r\n    public warpDestination = 0;\r\n    public lastBeatUpdate = new GameTimer(); // time of last this.songBeat etc. update\r\n    public musicSecondsVisible = -1;\r\n    public songBeatVisible = -1;\r\n\r\n    public reset() {\r\n        this.musicSecondsVisible = 0;\r\n        this.songBeatVisible = 0;\r\n\r\n        this.musicSeconds = 0;\r\n        // todo: move me to FOREACH_EnabledPlayer( p ) after [NUM_PLAYERS]ing\r\n        this.songBeat = 0;\r\n        this.songBeatNoOffset = 0;\r\n        this.curBps = 0;\r\n        this.freeze = false;\r\n        this.delay = false;\r\n        this.warpBeginRow = -1; // Set to -1 because some song may want to warp to row 0. -aj\r\n        this.warpDestination = -1; // Set when a warp is encountered. also see above. -aj\r\n    }\r\n\r\n    public updateSongPosition(positionSeconds: number, timing: TimingData, timestamp: GameTimer) {\r\n        if (!timestamp.isZero()) {\r\n            this.lastBeatUpdate = timestamp;\r\n        } else {\r\n            this.lastBeatUpdate.touch();\r\n        }\r\n\r\n        const beatInfo = new GetBeatArgs();\r\n        beatInfo.elapsedTime = positionSeconds;\r\n        timing.getBeatAndBpsFromElapsedTime(beatInfo);\r\n        this.songBeat = beatInfo.beat;\r\n        this.curBps = beatInfo.bpsOut;\r\n        this.freeze = beatInfo.freezeOut;\r\n        this.delay = beatInfo.delayOut;\r\n        this.warpBeginRow = beatInfo.warpBeginOut;\r\n        this.warpDestination = beatInfo.warpDestOut;\r\n\r\n        ASSERT(this.songBeat > -2000, `Song beat ${this.songBeat} at ${positionSeconds} is less than -2000`);\r\n\r\n        this.musicSeconds = positionSeconds;\r\n        // ignore light beat - we don't support lights -Struz\r\n        this.songBeatNoOffset = timing.getBeatFromElapsedTimeNoOffset(this.musicSecondsVisible);\r\n\r\n        // we don't support visual delay yet, clone the values -Struz\r\n        this.musicSecondsVisible = this.musicSeconds;\r\n        this.songBeatVisible = this.songBeat;\r\n    }\r\n}\r\nexport default SongPosition;\r\n","import SongPosition from './SongPosition';\r\nimport GAMESTATE from './GameState';\r\nimport { PlayerNumber } from './PlayerNumber';\r\n\r\n/** The player's individual state. */\r\nexport class PlayerState {\r\n    public playerNumber = PlayerNumber.PLAYER_1;\r\n    // Music statistics:\r\n    public position = new SongPosition();\r\n    // Stores the bpm that was picked for reading the chart if the player is using an mmod.\r\n    public readBPM = 0;\r\n\r\n    /** Update the player state based on the present time.\r\n     * @param delta The current time.\r\n     */\r\n    public update(delta: number) {\r\n        // This is all attack and mods stuff. We don't need it - Struz\r\n    }\r\n\r\n    public getDisplayedPosition() {\r\n        if (GAMESTATE.isUsingStepTiming) { return this.position; }\r\n        return GAMESTATE.position;\r\n    }\r\n\r\n    public getDisplayedTiming() {\r\n        const steps = GAMESTATE.curSteps[this.playerNumber];\r\n        // C++ code checked for undefined but we don't allow that here\r\n        return steps.timingData;\r\n    }\r\n}\r\nexport default PlayerState;\r\n","// Various errors that we throw\r\n\r\nexport class NotImplementedError extends Error {\r\n    constructor() {\r\n        super('Not yet implemented');\r\n    }\r\n}\r\n","import { PlayerNumber } from './PlayerNumber';\r\nimport TimingData from './TimingData';\r\nimport SongPosition from './SongPosition';\r\nimport { PlayerState } from './PlayerState';\r\nimport Helpers from './GameConstantsAndTypes';\r\nimport { GameTimer, gZeroTimer } from './GameTimer';\r\nimport { Steps } from './Steps';\r\nimport Song from './Song';\r\nimport { NotImplementedError } from './Error';\r\nimport SOUNDMAN, { MusicToPlay } from './GameSoundManager';\r\n\r\n\r\n/** Holds all the state about the game. A singleton. */\r\nexport class GameState {\r\n    // Global state from Actors.h, might need moving to another place\r\n    public static currentBgmTime = 0;\r\n    public static currentBgmBeat = 0;\r\n\r\n    public static currentBgmTimeNoOffset = 0;\r\n    public static currentBgmBeatNoOffset = 0;\r\n\r\n    public static currentBgmBeatPlayer: number[] = []; // Max entries is PlayerNumber.NUM\r\n    public static currentBgmBeatPlayerNoOffset: number[] = []; // Max entries is PlayerNumber.NUM\r\n    // End global state from Actors\r\n\r\n    // public static MUSIC_SECONDS_INVALID = -5000;\r\n\r\n    // Singleton\r\n    public static getInstance() {\r\n        if (!GameState.instance) {\r\n            GameState.instance = new GameState();\r\n        }\r\n        return GameState.instance;\r\n    }\r\n    private static instance: GameState;\r\n\r\n    // The currently playing song, if any\r\n    public curSong: Song | undefined;\r\n    // curSong.songTiming has the timing data we care about\r\n\r\n    // Stuff used in gameplay, they mean nothing if curSong is undefined\r\n    public curSteps: Steps[]; // One index per player; A broadcast on change pointer in C++\r\n    public position: SongPosition = new SongPosition();\r\n    public selectedSteps: number;\r\n\r\n    public hasteRate: number;\r\n\r\n    // Options stuff (mods)\r\n    // public songOptions: SongOptions;\r\n\r\n    // PlayerState\r\n    /** Allow access to each player's PlayerState. */\r\n    public playerState: PlayerState[];\r\n\r\n    /**\r\n     * Is the game right now using Song timing or Steps timing?\r\n     * Different options are available depending on this setting.\r\n     */\r\n    // Default to the song timing UNLIKE STEPMANIA. This is because\r\n    // we haven't perfected the pass through chain to steps yet. -Struz\r\n    public isUsingStepTiming = false;\r\n\r\n\r\n    // Timing position corrections\r\n    private lastPositionTimer = new GameTimer();\r\n    private lastPositionSeconds = 0;\r\n    private paused = false;\r\n\r\n    private constructor() {\r\n        this.curSteps = [];\r\n        this.selectedSteps = 0;\r\n\r\n        this.playerState = [];\r\n        for (const pn of Helpers.forEachEnum(PlayerNumber)) {\r\n            this.playerState[pn] = new PlayerState();\r\n            // this.playerState[pn].setPlayerNumber(pn);\r\n        }\r\n        this.hasteRate = 1.0;\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /** Reset the game state. */\r\n    public reset() {\r\n        this.paused = false;\r\n    }\r\n\r\n    /** All the logic involved with loading a new song. */\r\n    public loadNextSong(newSong: Song | undefined) {\r\n        this.pause();\r\n        SOUNDMAN.pauseMusic();\r\n        this.resetMusicStatistics();\r\n        if (newSong === undefined) {\r\n            return;\r\n        }\r\n\r\n        this.setCurSong(newSong);\r\n        // IMPORTANT: make the primitives and stuff?\r\n        // Screen.setupSong()\r\n        // Sets steps display\r\n    }\r\n\r\n    /** Change the current song. */\r\n    public setCurSong(newSong: Song | undefined) {\r\n        if (this.curSong !== undefined) {\r\n            // TODO: release lookup data for the old song\r\n            this.curSong.songTiming.releaseLookup();\r\n        }\r\n        console.log('changed song!');\r\n        this.curSong = newSong;\r\n        // TODO: broadcast song has changed.\r\n        if (this.curSong !== undefined) {\r\n            // TODO: request lookup data for the new song\r\n            this.curSong.songTiming.prepareLookup();\r\n        }\r\n    }\r\n\r\n    public play() { SOUNDMAN.handleSongTimer(true); }\r\n\r\n    public pause() { SOUNDMAN.handleSongTimer(false); }\r\n    public isPaused() { return !SOUNDMAN.isHandlingSongTimer(); }\r\n\r\n    /** Update the game state.\r\n     * @param delta The time that has passed since the last update.\r\n     */\r\n    public update(delta: number) {\r\n        // FOREACH_PlayerNumber\r\n        // TODO: fix this, just p1 for now\r\n        this.playerState[0].update(delta);\r\n    }\r\n\r\n    public resetMusicStatistics() {\r\n        this.position.reset();\r\n        this.lastPositionTimer.touch();\r\n        this.lastPositionSeconds = 0;\r\n\r\n        this.setBgmTime(0, 0, 0, 0);\r\n        // FOREACH_PlayerNumber\r\n        // TODO: fix\r\n        this.playerState[0].position.reset();\r\n    }\r\n\r\n    public getSongPercent(beat: number) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    public setBgmTime(time: number, beat: number, timeNoOffset: number, beatNoOffset: number) {\r\n        GameState.currentBgmTime = time;\r\n        GameState.currentBgmBeat = beat;\r\n\r\n        /* This timer is generally only used for effects tied to the background music\r\n         * when GameSoundManager is aligning music beats.  Alignment doesn't handle\r\n         * g_fVisualDelaySeconds. */\r\n        GameState.currentBgmTimeNoOffset = timeNoOffset;\r\n        GameState.currentBgmBeatNoOffset = beatNoOffset;\r\n    }\r\n\r\n    public setPlayerBgmBeat(pn: PlayerNumber, beat: number, beatNoOffset: number) {\r\n        GameState.currentBgmBeatPlayer[pn] = beat;\r\n        GameState.currentBgmBeatPlayerNoOffset[pn] = beatNoOffset;\r\n    }\r\n\r\n    public updateSongPosition(positionSeconds: number, timing: TimingData, timestamp: GameTimer = gZeroTimer) {\r\n        /* It's not uncommon to get a lot of duplicated positions from the sound\r\n         * driver, like so: 13.120953,13.130975,13.130975,13.130975,13.140998,...\r\n         * This causes visual stuttering of the arrows. To compensate, keep a\r\n         * RageTimer since the last change. */\r\n        if (positionSeconds === this.lastPositionSeconds && !this.paused) {\r\n            positionSeconds += this.lastPositionTimer.ago();\r\n        } else {\r\n            this.lastPositionTimer.touch();\r\n            this.lastPositionSeconds = positionSeconds;\r\n        }\r\n\r\n        // If we were paused then positionSeconds will be the same as before, so the following\r\n        // updateSongPosition calls will be a no-op\r\n        this.position.updateSongPosition(positionSeconds, timing, timestamp);\r\n\r\n        // TODO: fixme to be a FOREACH_EnabledPlayer\r\n        // Just do p1 for now\r\n        const pn = 0;\r\n        if (this.curSteps.length) {\r\n            this.playerState[pn].position.updateSongPosition(positionSeconds,\r\n                this.curSteps[pn].timingData, timestamp);\r\n            this.setPlayerBgmBeat(pn, this.playerState[pn].position.songBeatVisible,\r\n                this.playerState[pn].position.songBeatNoOffset);\r\n        }\r\n        this.setBgmTime(GAMESTATE.position.musicSecondsVisible,\r\n            this.position.songBeatVisible,\r\n            positionSeconds,\r\n            this.position.songBeatNoOffset);\r\n    }\r\n\r\n    /**\r\n     * Takes an already created Song and Howl and sets up the game ready to play them.\r\n     * @param songData the Song to play.\r\n     * @param songMusic the created Howl representing the sound file.\r\n     * @param seek number of seconds to start playing at.\r\n     */\r\n    public loadSong(songData: Song, songMusic: Howl, seek?: number) {\r\n        // TODO: IMPORTANT: write functions to ensure that a Song is loaded before we play the Music\r\n        // See PlayMusic() in C++ for an example.\r\n        this.loadNextSong(songData);\r\n\r\n        const toPlay = new MusicToPlay();\r\n        toPlay.music = songMusic;\r\n        toPlay.hasTiming = true;\r\n        toPlay.timing = songData.songTiming;\r\n        if (seek !==  undefined) {\r\n            toPlay.startSeconds = seek;\r\n        }\r\n        GAMESTATE.play();\r\n        // TODO: don't always immediately start the song, have an init function instead\r\n        SOUNDMAN.startMusic(toPlay);\r\n    }\r\n}\r\nconst GAMESTATE = GameState.getInstance();\r\nexport default GAMESTATE;\r\n","import SongPosition from './SongPosition';\r\nimport GAMESTATE from './GameState';\r\nimport { PassByRef } from './GameConstantsAndTypes';\r\n\r\ninterface CacheDisplayedBeat {\r\n    beat: number;\r\n    displayedBeat: number;\r\n    velocity: number;\r\n}\r\n\r\ninterface CacheNoteStat {\r\n    beat: number;\r\n    notesLower: number; // int\r\n    notesUpper: number; // int\r\n}\r\n\r\n// Not quite sure what this does but it seems theme related -Struz\r\nconst ARROW_SPACING = 1;\r\n\r\n/** Functions that return properties of arrows based on Style and PlayerOptions. */\r\nclass ArrowEffects {\r\n    /**\r\n     * Holds a vector sorted by real beat, the beat that would be displayed\r\n     * in the NoteField (because they are affected by scroll segments), and\r\n     * also the velocity.\r\n     * This vector will be populated on Player::Load() be used a lot in\r\n     * ArrowEffects to determine the target beat in O(log N).\r\n     */\r\n    public static displayedBeatCache: CacheDisplayedBeat[] = [];\r\n    /** Holds a vector sorted by beat, the cumulative number of notes from\r\n     * the start of the song.\r\n     */\r\n    public static noteStatCache: CacheNoteStat[] = [];\r\n\r\n    // OPTIONS - may need to move these to another class later\r\n    /* All floats have a corresponding speed setting, which determines how fast\r\n    * PlayerOptions::Approach approaches. */\r\n    /** timeSpacing of 0 means cmod, mmod as we are using beat instead of time. */\r\n    public static timeSpacing = 0;\r\n    public static maxScrollBpm = 0;  // What happens if we set this > 0? -Struz\r\n    // next two used if !timeSpacing (xMods)\r\n    public static scrollSpeed = 220;  // This seems to have an overcentralising effect. FIXME: -Struz\r\n    public static speedScrollSpeed = 1;\r\n    // next two used it timeSpacing (CMod)\r\n    public static scrollBpm = 1000;\r\n    public static speedScrollBpm = 1;\r\n\r\n    // Next one was on PlayerState for some reason\r\n    /** Stores the bpm that was picked for reading the chart if the player is using an mmod. */\r\n    public static readBpm = 400;\r\n\r\n    /* For visibility testing: if bAbsolute is false, random modifiers must return\r\n     * the minimum possible scroll speed. */\r\n    public static getYOffset(\r\n        noteBeat: number, peakYOffsetOut: PassByRef<number>,\r\n        isPastPeakOut: PassByRef<boolean>) {\r\n\r\n        // Fail fast if no song\r\n        if (GAMESTATE.curSong === undefined) { return 0; }\r\n\r\n        peakYOffsetOut.value = Number.MAX_VALUE;\r\n        isPastPeakOut.value = true;\r\n\r\n        let yOffset = 0;\r\n        const position = GAMESTATE.position; // TODO: get position from args\r\n\r\n        const songBeat = position.songBeatVisible;\r\n        const curSteps = GAMESTATE.curSong.getSteps(GAMESTATE.selectedSteps);\r\n        // curSteps is unused for now as we're just relying on song timing\r\n        const timingData = GAMESTATE.curSong.songTiming;\r\n\r\n        /* Usually, timeSpacing is 0 or 1, in which case we use entirely beat spacing or\r\n         * entirely time spacing (respectively). Occasionally, we tween between them. */\r\n        if (this.timeSpacing !== 1) {\r\n            // !== 1 means cmod, mmod\r\n            // No editor, no constant spacing\r\n            yOffset = ArrowEffects.getDisplayedBeat(noteBeat) - ArrowEffects.getDisplayedBeat(songBeat);\r\n            yOffset *= timingData.getDisplayedSpeedPercent(position.songBeatVisible, position.musicSecondsVisible);\r\n            yOffset *= 1 - this.timeSpacing;\r\n        }\r\n\r\n        if (this.timeSpacing !== 0) {\r\n            // !== 0 means xmod\r\n            const songSeconds = GAMESTATE.position.musicSecondsVisible;\r\n            const noteSeconds = timingData.getElapsedTimeFromBeat(noteBeat);\r\n            // DEBUGGING: the song is literally ahead of the beat here, hence why we have the weird shit\r\n            // happening. Why is it not looking ahead properly?\r\n            const secondsUntilStep = noteSeconds - songSeconds;\r\n            const bpm = this.scrollBpm;\r\n            const bps = (bpm / 60); // If we support music rate we need to divide by it here\r\n            const yOffsetTimeSpacing = secondsUntilStep * bps;\r\n            yOffset += yOffsetTimeSpacing * this.timeSpacing;\r\n        }\r\n        yOffset *= ARROW_SPACING;\r\n\r\n        // Factor in scroll speed\r\n        let scrollSpeed = this.scrollSpeed;\r\n        if (this.maxScrollBpm !== 0) {\r\n            scrollSpeed = this.maxScrollBpm / (this.readBpm * 1); // If we support music rate change the 1 here\r\n        }\r\n\r\n        if (yOffset < 0) {\r\n            return yOffset * scrollSpeed;\r\n        }\r\n        yOffset *= scrollSpeed;\r\n        peakYOffsetOut.value *= scrollSpeed;\r\n        return yOffset;\r\n        // Below here was special options for mods, ignored\r\n    }\r\n\r\n    public static getDisplayedBeat(beat: number) {\r\n        // binary search\r\n        const data = ArrowEffects.displayedBeatCache;\r\n        const max = data.length - 1;\r\n        let l = 0;\r\n        let r = max;\r\n        while (l <= r) {\r\n            const m = Math.trunc((l + r) / 2); // int\r\n            if ((m === 0 || data[m].beat <= beat) && (m === max || beat < data[m + 1].beat)) {\r\n                return data[m].displayedBeat + data[m].velocity * (beat - data[m].beat);\r\n            } else if (data[m].beat <= beat) {\r\n                l = m + 1;\r\n            } else {\r\n                r = m - 1;\r\n            }\r\n        }\r\n        return beat;\r\n    }\r\n}\r\nexport default ArrowEffects;\r\n","import NoteHelpers, { NoteType } from '../NoteTypes';\r\nimport { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN, directionToLaneIndex } from './EntitiesConstants';\r\nimport RESOURCEMAN, { DOWN_TAP_NOTE_SHEET_NAME } from '../ResourceManager';\r\nimport AnimatedGameSprite from './AnimatedGameSprite';\r\nimport ArrowEffects from '../ArrowEffects';\r\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\r\nimport GameSprite from './GameSprite';\r\n\r\nconst NOTESKIN = 'USWCelETT';\r\n\r\nclass TapNoteSprite extends AnimatedGameSprite {\r\n    private direction: TapNoteDirection;\r\n    private noteType: NoteType;\r\n    private noteBeat: number;\r\n\r\n\r\n    /** Create a new tap note sprite.\r\n     * @param direction the direction the arrow should go in.\r\n     * @param noteBeat the beat the note lands on.\r\n     */\r\n    constructor(direction: TapNoteDirection, noteBeat: number) {\r\n        GameSprite.checkDependencies();\r\n        let noteType = NoteHelpers.beatToNoteType(noteBeat);\r\n        if (noteType === NoteType.N_192ND) {\r\n            // 192nd notes use the same sprite as 64th notes anyway\r\n            noteType = NoteType.N_64TH;\r\n        }\r\n        super(RESOURCEMAN.getSpriteInfo(DOWN_TAP_NOTE_SHEET_NAME), noteType);\r\n\r\n        this.direction = direction;\r\n        this.noteType = noteType;\r\n        this.noteBeat = noteBeat;\r\n\r\n        // Set the rotation based on the direction, using the down arrow as a reference\r\n        this.sprite.rotation = (90 * this.direction) * (Math.PI / 180);\r\n\r\n        // Set the x based on the note track\r\n        const laneIndex = directionToLaneIndex(this.direction);\r\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\r\n        this.setYPosBasedOnBeat();\r\n\r\n        // Ensure it starts animated\r\n        this.sprite.play();\r\n    }\r\n\r\n    public getDirection() { return this.direction; }\r\n    public getNoteType() { return this.noteType; }\r\n    public getBeat() { return this.noteBeat; }\r\n\r\n    public update(deltaTime: number) {\r\n        // // 1 / 60 = 0.016 is when we move 3 px per frame. More than this and we move more, less and we move less.\r\n        // // Multiply by FPS (60) to get the amount to move (more or less).\r\n        // const movement = 3 * (deltaTime * 60);\r\n        // this.sprite.y += movement;\r\n        // this.sprite.y = 400; // TODO: base this off the beat the note is on so we can just create notes @ beats\r\n        this.setYPosBasedOnBeat();\r\n        return this;\r\n    }\r\n\r\n    private setYPosBasedOnBeat() {\r\n        const peakYOffset = {value: 0};\r\n        const isPastPeakOut = {value: false};\r\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\r\n        // and we want it synced to the receptors.\r\n        this.sprite.y = ArrowEffects.getYOffset(this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\r\n    }\r\n}\r\nexport default TapNoteSprite;\r\n","import { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN, directionToLaneIndex } from './EntitiesConstants';\r\nimport RESOURCEMAN, { TAP_MINE_SHEET_NAME } from '../ResourceManager';\r\nimport AnimatedGameSprite from './AnimatedGameSprite';\r\nimport ArrowEffects from '../ArrowEffects';\r\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\r\nimport GameSprite from './GameSprite';\r\n\r\nconst NOTESKIN = 'USWCelETT';\r\n\r\nclass TapMineSprite extends AnimatedGameSprite {\r\n    private direction: TapNoteDirection;  // Used for x position\r\n    private noteBeat: number;\r\n\r\n\r\n    /** Create a new mine sprite.\r\n     * @param direction the direction the arrow should go in.\r\n     * @param noteBeat the beat the mine lands on.\r\n     */\r\n    constructor(direction: TapNoteDirection, noteBeat: number) {\r\n        GameSprite.checkDependencies();\r\n        super(RESOURCEMAN.getSpriteInfo(TAP_MINE_SHEET_NAME), 0);\r\n\r\n        this.direction = direction;\r\n        this.noteBeat = noteBeat;\r\n\r\n        // Set the x based on the note track\r\n        const laneIndex = directionToLaneIndex(this.direction);\r\n        this.sprite.x = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\r\n        this.setYPosBasedOnBeat();\r\n\r\n        // Ensure it starts animated\r\n        this.sprite.play();\r\n    }\r\n\r\n    public getDirection() { return this.direction; }\r\n    public getBeat() { return this.noteBeat; }\r\n\r\n    public update(deltaTime: number) {\r\n        // // 1 / 60 = 0.016 is when we move 3 px per frame. More than this and we move more, less and we move less.\r\n        // // Multiply by FPS (60) to get the amount to move (more or less).\r\n        // const movement = 3 * (deltaTime * 60);\r\n        // this.sprite.y += movement;\r\n        // this.sprite.y = 400; // TODO: base this off the beat the note is on so we can just create notes @ beats\r\n        this.setYPosBasedOnBeat();\r\n        return this;\r\n    }\r\n\r\n    // TODO: find a way to generalise this beat pos stuff across everything\r\n    // that needs it\r\n\r\n    // TODO: mines look silly when they disappear at the arrows - fix this\r\n\r\n    private setYPosBasedOnBeat() {\r\n        const peakYOffset = {value: 0};\r\n        const isPastPeakOut = {value: false};\r\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\r\n        // and we want it synced to the receptors.\r\n        this.sprite.y = ArrowEffects.getYOffset(this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\r\n    }\r\n}\r\nexport default TapMineSprite;\r\n","import * as PIXI from 'pixi.js-legacy';\r\nimport Entity from './Entity';\r\n\r\nimport GameSprite, { Drawable } from './GameSprite';\r\nimport { TapNoteDirection, directionToLaneIndex,\r\n    LANE_MARGIN, TAPNOTE_WIDTH_PX, HOLD_BOTTOM_CAP_HEIGHT_PX } from './EntitiesConstants';\r\nimport { GameSpriteInfo } from '../ResourceManager';\r\nimport ArrowEffects from '../ArrowEffects';\r\nimport { RECEPTOR_MARGIN_TOP_PX } from './TapNoteReceptorSprite';\r\n\r\n// Base class for long note types like holds & rolls.\r\n// Represents the tail portion of a long note. The head is still a TapNote.\r\n// It is an entity of its own, with sub-entities that are sprites.\r\nclass BodyAndCapNote extends Entity implements Drawable {\r\n    /** The direction of the arrow at the head of the long note. */\r\n    protected direction: TapNoteDirection;\r\n    /** The beat the head of this long note lands on. */\r\n    protected noteBeat: number;\r\n    /** The duration of this long note in beats. */\r\n    protected duration: number;\r\n\r\n    /** The sprite showing the tiling area of really long notes. */\r\n    protected bodyTilingSprite: GameSprite[] | undefined;\r\n    /** The sprite showing the beginning of the body of the long note. */\r\n    protected bodySprite: GameSprite;\r\n    /** The sprite showing the bottom of the long note. */\r\n    protected bottomCapSprite: GameSprite;\r\n\r\n    /** Are we a candidate for rendering? */\r\n    private onStage: boolean;\r\n    /** The Y height of the long note. */\r\n    private height: number;\r\n\r\n    /**\r\n     * @param direction the direction of the arrow at the head of the long note.\r\n     * @param noteBeat the beat the head of this long note lands on.\r\n     * @param duration the duration of the long note in beats.\r\n     */\r\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number,\r\n                       bodySpriteInfo: GameSpriteInfo, capSpriteInfo: GameSpriteInfo) {\r\n        super();\r\n        this.direction = direction;\r\n        this.noteBeat = noteBeat;\r\n        this.duration = duration;\r\n        this.onStage = false;\r\n\r\n        // We anchor to the top of the hold, but the middle of the cap, so do some maths\r\n        // to make them line up. This height does not include to the tip of the cap.\r\n        this.height = this.calculateLongNoteHeight();\r\n\r\n        // Work out the dimensions for the first segment of the long note. Often this\r\n        // will be all we need to display it fully. This segment is special because\r\n        // it starts drawing the texture from part way down, so that it will always\r\n        // line up with the texture of the bottom cap.\r\n        let firstBodySegmentTexStartY = 0;\r\n        let firstBodySegmentTexHeight = 0;\r\n        firstBodySegmentTexStartY = bodySpriteInfo.height - (this.height % bodySpriteInfo.height);\r\n        firstBodySegmentTexHeight = bodySpriteInfo.height - firstBodySegmentTexStartY;\r\n\r\n        // If we can't fit the long note entirely into the first section then we need a tiling section.\r\n        if (this.height > bodySpriteInfo.height) {\r\n            this.bodyTilingSprite = [];\r\n\r\n            let remainingHeight = this.height - firstBodySegmentTexHeight;\r\n            while (remainingHeight > 0) {\r\n                const segmentHeight = Math.min(remainingHeight, bodySpriteInfo.height);\r\n                let bodySegmentTex: PIXI.Texture;\r\n                if (segmentHeight === bodySpriteInfo.height) {\r\n                    bodySegmentTex = bodySpriteInfo.textures[0][0];\r\n                } else {\r\n                    // Only create new textures for custom dimensions\r\n                    bodySegmentTex = new PIXI.Texture(\r\n                        bodySpriteInfo.textures[0][0].baseTexture,\r\n                        new PIXI.Rectangle(0, 0, bodySpriteInfo.width, segmentHeight),\r\n                    );\r\n                }\r\n                const bodySegmentSprite = new PIXI.Sprite(bodySegmentTex);\r\n                this.bodyTilingSprite.push(new GameSprite(bodySegmentSprite));\r\n\r\n                remainingHeight -= segmentHeight;\r\n            }\r\n        }\r\n\r\n        // Create the first (and sometimes only) segment of the body sprite\r\n        const bodySpriteTex = new PIXI.Texture(\r\n            bodySpriteInfo.textures[0][0].baseTexture,\r\n            new PIXI.Rectangle(\r\n                0, firstBodySegmentTexStartY,\r\n                bodySpriteInfo.width, firstBodySegmentTexHeight,\r\n            ));\r\n        const bodySprite = new PIXI.Sprite(bodySpriteTex);\r\n        this.bodySprite = new GameSprite(bodySprite);\r\n        // Create the cap\r\n        const bottomCapSprite = new PIXI.Sprite(capSpriteInfo.textures[0][0]);\r\n        this.bottomCapSprite = new GameSprite(bottomCapSprite);\r\n\r\n        // Configure the sprite positions after creating the GameSprites in case their\r\n        // constructor does anything funky to the sprites.\r\n\r\n        // Set the x based on the note track\r\n        const laneIndex = directionToLaneIndex(this.direction);\r\n        const laneX = LANE_MARGIN + (TAPNOTE_WIDTH_PX * laneIndex);\r\n        bodySprite.x = laneX;\r\n        if (this.bodyTilingSprite !== undefined) {\r\n            this.bodyTilingSprite.forEach((gs) => gs.getSprite().x = laneX);\r\n        }\r\n        bottomCapSprite.x = laneX;\r\n\r\n        // Make sure we anchor the Y to the top of each component so we have an easy time\r\n        // with maths.\r\n        bodySprite.anchor.y = 0;\r\n        if (this.bodyTilingSprite !== undefined) {\r\n            this.bodyTilingSprite.forEach((gs) => gs.getSprite().anchor.y = 0);\r\n        }\r\n        bottomCapSprite.anchor.y = 0;\r\n\r\n        this.updateSprites();\r\n    }\r\n\r\n    public destroy() {\r\n        this.removeFromStage();\r\n        super.destroy();\r\n    }\r\n\r\n    public isOnStage() { return this.onStage; }\r\n    public addToStage() {\r\n        if (this.onStage) { return this; }\r\n\r\n        this.onStage = true;\r\n        // It is very important that the bottom cap is added first\r\n        // If Z indexing is disabled this is the only way to ensure it draws below.\r\n        this.bottomCapSprite.addToStage();\r\n        if (this.bodyTilingSprite !== undefined) {\r\n            this.bodyTilingSprite.forEach((gs) => gs.addToStage());\r\n        }\r\n        this.bodySprite.addToStage();\r\n        return this;\r\n    }\r\n    public removeFromStage() {\r\n        if (!this.onStage) { return this; }\r\n\r\n        this.onStage = false;\r\n        this.bottomCapSprite.removeFromStage();\r\n        if (this.bodyTilingSprite !== undefined) {\r\n            this.bodyTilingSprite.forEach((gs) => gs.removeFromStage());\r\n        }\r\n        this.bodySprite.removeFromStage();\r\n        return this;\r\n    }\r\n\r\n    public update(deltaTime: number): this {\r\n        this.updateSprites();\r\n        return this;\r\n    }\r\n\r\n    private calculateLongNoteHeight() {\r\n        const peakYOffset = {value: 0};\r\n        const isPastPeakOut = {value: false};\r\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\r\n        // and we want it synced to the receptors.\r\n        const headYPos = ArrowEffects.getYOffset(\r\n            this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\r\n        const capYPos = ArrowEffects.getYOffset(\r\n            this.noteBeat + this.duration,\r\n            peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\r\n        // Because we anchor to the top of the bottom cap we need to subtract half the height\r\n        // to get it to line up with where it should be placed.\r\n        return capYPos - headYPos - (HOLD_BOTTOM_CAP_HEIGHT_PX / 2);\r\n    }\r\n\r\n    private updateSprites() {\r\n        const peakYOffset = {value: 0};\r\n        const isPastPeakOut = {value: false};\r\n        // Add the RECEPTOR_MARGIN_TOP_PX because the beat is synced to the top of the view screen\r\n        // and we want it synced to the receptors.\r\n        const headYPos = ArrowEffects.getYOffset(\r\n            this.noteBeat, peakYOffset, isPastPeakOut) + RECEPTOR_MARGIN_TOP_PX;\r\n\r\n        // Add the non tiling part of the sprite directly at the top\r\n        const bodySprite = this.bodySprite.getSprite();\r\n        bodySprite.y = headYPos;\r\n\r\n        // If applicable, update the tiling portion\r\n        if (this.bodyTilingSprite !== undefined) {\r\n            let tilingPosY = headYPos + bodySprite.height;\r\n            this.bodyTilingSprite.forEach((gs) => {\r\n                gs.getSprite().y = tilingPosY;\r\n                tilingPosY += gs.getSprite().height;\r\n            });\r\n        }\r\n\r\n        this.bottomCapSprite.setPosY(headYPos + this.height);\r\n    }\r\n}\r\nexport default BodyAndCapNote;\r\n","import BodyAndCapNote from './BodyAndCapNote';\r\nimport { TapNoteDirection } from './EntitiesConstants';\r\nimport RESOURCEMAN, {\r\n    DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME,\r\n    DOWN_HOLD_BODY_INACTIVE_SHEET_NAME } from '../ResourceManager';\r\n\r\nclass HoldTailSprite extends BodyAndCapNote {\r\n    /**\r\n     * @param direction the direction of the arrow at the head of the hold.\r\n     * @param noteBeat the beat the head of this hold tail lands on.\r\n     * @param duration the duration of the hold in beats.\r\n     */\r\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number) {\r\n        const bodySpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_HOLD_BODY_INACTIVE_SHEET_NAME);\r\n        const capSpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_HOLD_BOTTOM_CAP_INACTIVE_SHEET_NAME);\r\n        super(direction, noteBeat, duration, bodySpriteInfo, capSpriteInfo);\r\n    }\r\n}\r\nexport default HoldTailSprite;\r\n","import BodyAndCapNote from './BodyAndCapNote';\r\nimport { TapNoteDirection } from './EntitiesConstants';\r\nimport RESOURCEMAN, {\r\n    DOWN_ROLL_BODY_INACTIVE_SHEET_NAME,\r\n    DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME} from '../ResourceManager';\r\n\r\n// This is different from HoldTailSprite because when we add the active portions\r\n// it will need to be animated.\r\n// The current plan is to do this by quick switching the visibility of the 4 sprites.\r\n// .destroy() will need to be overloaded to cleanup the non active sprites, but the\r\n// active ones can be left to the parent.\r\nclass RollTailSprite extends BodyAndCapNote {\r\n    /**\r\n     * @param direction the direction of the arrow at the head of the hold.\r\n     * @param noteBeat the beat the head of this hold tail lands on.\r\n     * @param duration the duration of the hold in beats.\r\n     */\r\n    public constructor(direction: TapNoteDirection, noteBeat: number, duration: number) {\r\n        // TODO: for some reason the roll body has an extra pixel at the bottom. Cut it off.\r\n        // TODO: also, we can't use the same trick as with the holds to flip the Y index because\r\n        //       this one actually needs to point up. We need to find a way to anchor at the bottom and\r\n        //       draw up.\r\n        // Might have to go back to calculating the size and then hiding the top part.\r\n        // So what is drawing in reverse actually doing?\r\n        // - Flips UVs\r\n        // - So that drawing happens.\r\n\r\n        // If the roll/hold is < the height of the original, we need to set the UVs such that we\r\n        // start drawing midway down. We can do that by clamping the texture at creation.\r\n        // If the roll/hold is > the height of the original, we do some very slight scale adjustments\r\n        // to get them to line up without needing to do weird UV stuff on the final leg.\r\n        // UV stuff on the final tile would be the best solution, of course.\r\n\r\n        // What we could do is use tiling sprite for multiples of the height then do the UV\r\n        // adjustment for the final piece. This is probably the best overall solution, but\r\n        // the most code change.\r\n        const bodySpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_ROLL_BODY_INACTIVE_SHEET_NAME);\r\n        const capSpriteInfo = RESOURCEMAN.getSpriteInfo(DOWN_ROLL_BOTTOM_CAP_INACTIVE_SHEET_NAME);\r\n        super(direction, noteBeat, duration, bodySpriteInfo, capSpriteInfo);\r\n    }\r\n}\r\nexport default RollTailSprite;\r\n","import Entity from './Entity';\r\nimport GAMESTATE from '../GameState';\r\nimport ArrowEffects from '../ArrowEffects';\r\nimport NoteHelpers, { TapNoteType, TapNoteSubType } from '../NoteTypes';\r\nimport TapNoteSprite from './TapNoteSprite';\r\nimport { laneIndexToDirection } from './EntitiesConstants';\r\nimport TapMineSprite from './TapMineSprite';\r\nimport GameSprite, { Drawable } from './GameSprite';\r\nimport HoldTailSprite from './HoldTailSprite';\r\nimport RollTailSprite from './RollTailSprite';\r\n\r\n// The note tracks can hold any drawable note\r\ntype DrawableNoteSprite = Drawable;\r\n\r\nclass NoteTrackData {\r\n    /** The tap notes and the note rows they land on. */\r\n    public tapNotes: Map<number, DrawableNoteSprite>;\r\n    /** The end points of holds. Required so we can cull holds when they end. */\r\n    public holdCaps: Map<number, DrawableNoteSprite>;\r\n\r\n    constructor() {\r\n        this.tapNotes = new Map();\r\n        this.holdCaps = new Map();\r\n    }\r\n}\r\n\r\n/** The note field. Doesn't inherently draw anything itself\r\n *  but controls other entities which are drawn.\r\n */\r\nclass NoteField extends Entity {\r\n    // TODO: Eventually optimise this into a genericized vesion of TrackMap.\r\n    // Map is keyed as noteRow=>TapNoteSprite\r\n    /** One map of note rows to the sprites they draw for each note track. */\r\n    private noteTracks: NoteTrackData[];\r\n\r\n    constructor() {\r\n        super();\r\n        this.noteTracks = [];\r\n        this.resetTracks(4);\r\n    }\r\n\r\n    public resetTracks(numTracks: number) {\r\n        // Cleanup any old notes\r\n        for (const track of this.noteTracks) {\r\n            for (const tn of track.tapNotes) {\r\n                tn[1].destroy();\r\n            }\r\n            for (const tn of track.holdCaps) {\r\n                tn[1].destroy();\r\n            }\r\n        }\r\n\r\n        // Reset the tracks\r\n        this.noteTracks = [];\r\n        for (let i = 0; i < numTracks; i++) {\r\n            this.noteTracks.push(new NoteTrackData());\r\n        }\r\n    }\r\n\r\n    public findFirstDisplayedBeat(drawDistanceAfterTargetsPixels: number) {\r\n        const songBeat = GAMESTATE.position.songBeat;\r\n\r\n        let low = 0;\r\n        let high = songBeat;\r\n\r\n        // I'm not sure what the cache does. TODO: work it out -Struz\r\n        const hasCache = ArrowEffects.noteStatCache.length !== 0;\r\n        if (!hasCache) {\r\n            low = high - 4;  // Only scan one measure of 4/4 for performance?? -Struz\r\n        }\r\n\r\n        const NUM_ITERATIONS = 24;\r\n        const MAX_NOTES_AFTER = 64;\r\n\r\n        let firstBeatToDraw = low;\r\n\r\n        // This looks like some kind of beat-and-iteration-bounded binary search -Struz\r\n        for (let i = 0; i < NUM_ITERATIONS; i++) {\r\n            const mid = (low + high) / 2; // float (because it's a beat)\r\n\r\n            const isPastPeakYOffset = {value: false};\r\n            const peakYOffset = {value: 0};\r\n            const yOffset = ArrowEffects.getYOffset(mid, peakYOffset, isPastPeakYOffset);\r\n\r\n            if (yOffset < drawDistanceAfterTargetsPixels ||\r\n                (hasCache && this.getNumNotesRange(mid, songBeat) > MAX_NOTES_AFTER)) {\r\n\r\n                // off screen / too many notes\r\n                firstBeatToDraw = mid; // move towards songBeat\r\n                low = mid;\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n        return firstBeatToDraw;\r\n    }\r\n\r\n    public findLastDisplayedBeat(drawDistanceBeforeTargetsPixels: number) {\r\n        // Fail fast if no song timing\r\n        if (GAMESTATE.curSong === undefined) { return 0; }\r\n\r\n        const displayedPosition = GAMESTATE.position;\r\n        const displayedTiming = GAMESTATE.curSong.songTiming;\r\n        // Probe for last note to draw. Worst case is 0.25x + boost.\r\n        // Adjust search distance so that notes don't pop onto the screen.\r\n        let searchDistance = 10;\r\n        let lastBeatToDraw = displayedPosition.songBeat + searchDistance;\r\n        const speedMultiplier = displayedTiming.getDisplayedSpeedPercent(\r\n            displayedPosition.songBeatVisible, displayedPosition.musicSecondsVisible);\r\n\r\n        const NUM_ITERATIONS = 20;\r\n\r\n        for (let i = 0; i < NUM_ITERATIONS; i++) {\r\n            const isPastPeakYOffset = {value: false};\r\n            const peakYOffset = {value: 0};\r\n            const yOffset = ArrowEffects.getYOffset(lastBeatToDraw, peakYOffset, isPastPeakYOffset);\r\n\r\n            if (yOffset > drawDistanceBeforeTargetsPixels) { // off screen\r\n                lastBeatToDraw -= searchDistance;\r\n            } else { // on screen\r\n                lastBeatToDraw += searchDistance;\r\n            }\r\n            searchDistance /= 2;\r\n        }\r\n\r\n        if (speedMultiplier < 0.75) {\r\n            lastBeatToDraw = Math.min(lastBeatToDraw, displayedPosition.songBeat + 16);\r\n        }\r\n        return lastBeatToDraw;\r\n    }\r\n\r\n    public getNumNotesFromBeginning(beat: number) {\r\n        // binary search\r\n        const data = ArrowEffects.noteStatCache;\r\n        const max = data.length - 1;\r\n        let l = 0;\r\n        let r = max;\r\n        while (l <= r) {\r\n            const m = Math.trunc((l + r) / 2); // int\r\n            if ((m === 0 || data[m].beat <= beat) && (m === max || beat < data[m + 1].beat)) {\r\n                return data[m];\r\n            } else if (data[m].beat <= beat) {\r\n                l = m + 1;\r\n            } else {\r\n                r = m - 1;\r\n            }\r\n        }\r\n        return {beat: 0, notesLower: 0, notesUpper: 0};\r\n    }\r\n\r\n    public getNumNotesRange(low: number, high: number) {\r\n        const noteStatLow = this.getNumNotesFromBeginning(low);\r\n        const noteStatHigh = this.getNumNotesFromBeginning(high);\r\n        return noteStatHigh.notesUpper - noteStatLow.notesLower;\r\n    }\r\n\r\n    public updateNotes(deltaTime: number) {\r\n        // Fail fast if no song\r\n        if (GAMESTATE.curSong === undefined) { return this; }\r\n        const songBeat = GAMESTATE.position.songBeatVisible;\r\n\r\n        const PIXELS_TO_DRAW_OFFSCREEN = 1000;\r\n        const firstBeatToDraw = this.findFirstDisplayedBeat(PIXELS_TO_DRAW_OFFSCREEN);\r\n        const lastBeatToDraw = this.findLastDisplayedBeat(PIXELS_TO_DRAW_OFFSCREEN);\r\n\r\n        const firstRow = NoteHelpers.beatToNoteRow(firstBeatToDraw);\r\n        const lastRow = NoteHelpers.beatToNoteRow(lastBeatToDraw);\r\n\r\n        // TODO: draw beat bars?\r\n\r\n        // We use a direct loop here so we can access the data immediately but the abstraction\r\n        // is lost. Build a generic version of this efficient abstraction somewhere.\r\n\r\n        // TODO: fix steps index below and replace with actual steps index when we have it later\r\n        const nd = GAMESTATE.curSong.getSteps(GAMESTATE.selectedSteps).getNoteData();\r\n        for (let t = 0; t < nd.tapNotes.length; t++) {\r\n            for (const tnEntry of nd.tapNotes[t]) {\r\n                // IMPORTANT: this array MUST be ordered or this continue/break logic won't work.\r\n                if (tnEntry[0] < firstRow) { continue; }\r\n                if (tnEntry[0] > lastRow) { break; }\r\n                if (tnEntry[1].type !== TapNoteType.Tap &&\r\n                    tnEntry[1].type !== TapNoteType.HoldHead &&\r\n                    tnEntry[1].type !== TapNoteType.Mine) { continue; }\r\n\r\n                // If we don't have the note already, create it\r\n                if (this.noteTracks[t].tapNotes.has(tnEntry[0])) { continue; }\r\n\r\n                const beat = NoteHelpers.noteRowToBeat(tnEntry[0]);\r\n                const direction = laneIndexToDirection(t);\r\n                let tnSprite: GameSprite;\r\n                switch (tnEntry[1].type) {\r\n                    case TapNoteType.Tap:\r\n                        tnSprite = new TapNoteSprite(\r\n                            direction,\r\n                            beat,\r\n                        );\r\n                        break;\r\n\r\n                    case TapNoteType.HoldHead:\r\n                        tnSprite = new TapNoteSprite(\r\n                            direction,\r\n                            beat,\r\n                        );\r\n                        let tailSprite: HoldTailSprite | RollTailSprite | undefined;\r\n                        if (tnEntry[1].subType === TapNoteSubType.Hold) {\r\n                            tailSprite = new HoldTailSprite(\r\n                                direction,\r\n                                beat,\r\n                                NoteHelpers.noteRowToBeat(tnEntry[1].duration),\r\n                            );\r\n                        } else {\r\n                            tailSprite = new RollTailSprite(\r\n                                direction,\r\n                                beat,\r\n                                NoteHelpers.noteRowToBeat(tnEntry[1].duration),\r\n                            );\r\n                        }\r\n                        this.noteTracks[t].holdCaps.set(tnEntry[0], tailSprite.addToStage());\r\n                        break;\r\n\r\n                    case TapNoteType.Mine:\r\n                        tnSprite = new TapMineSprite(\r\n                            direction,\r\n                            beat,\r\n                        );\r\n                        break;\r\n                    default:\r\n                        throw new Error(`Unprocessable TapNoteType encountered: ${tnEntry[1].type}`);\r\n                }\r\n                this.noteTracks[t].tapNotes.set(tnEntry[0], tnSprite.setZIndex(-tnEntry[0]).addToStage());\r\n            }\r\n        }\r\n\r\n        // Clean up the notes that are out of range\r\n        // We could do the cleanup in the same loop above but we might end up doing too many .has() lookups\r\n        // Instead, do a separate loop\r\n        const toDestroy: Array<[number, DrawableNoteSprite, Map<number, DrawableNoteSprite>]> = [];\r\n        for (const track of this.noteTracks) {\r\n            for (const tnsEntry of track.tapNotes) {\r\n                if (tnsEntry[0] < firstRow || tnsEntry[0] > lastRow) {\r\n                    // The sprite is out of our valid window for management, destroy it\r\n                    // Avoid doing it in here in case it changes the internals and ruins\r\n                    // iteration.\r\n                    toDestroy.push([tnsEntry[0], tnsEntry[1], track.tapNotes]);\r\n                }\r\n            }\r\n            for (const tnsEntry of track.holdCaps) {\r\n                // We only cull holds based on their end since the start note is often off-screen\r\n                if (tnsEntry[0] > lastRow) {\r\n                    toDestroy.push([tnsEntry[0], tnsEntry[1], track.holdCaps]);\r\n                }\r\n            }\r\n        }\r\n        toDestroy.forEach((tnsAndTrackEntry) => {\r\n            tnsAndTrackEntry[2].delete(tnsAndTrackEntry[0]);\r\n            tnsAndTrackEntry[1].destroy(); // destroy the entity\r\n        });\r\n    }\r\n\r\n    public update(deltaTime: number) {\r\n        this.updateNotes(deltaTime);\r\n        return this;\r\n    }\r\n}\r\nexport default NoteField;\r\n","import * as PIXI from 'pixi.js-legacy';\r\n\r\nimport RESOURCEMAN from './ResourceManager';\r\nimport TapNoteReceptorSprite from './entities/TapNoteReceptorSprite';\r\nimport { TapNoteDirection, TAPNOTE_WIDTH_PX, LANE_MARGIN } from './entities/EntitiesConstants';\r\nimport NoteField from './entities/NoteField';\r\n\r\ninterface ScreenManagerOptions {\r\n    renderCanvas: HTMLCanvasElement;\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\n/** Responsible for drawing to the screen.\r\n * We only allow one ScreenManager and it gets initialised with\r\n * a canvas and PIXI hook later.\r\n */\r\nexport class ScreenManager {\r\n    /** Get the desired FPS of the application. */\r\n    public static desiredFps() { return 60; }\r\n\r\n    // Singleton\r\n    public static getInstance() {\r\n        if (!ScreenManager.instance) {\r\n            ScreenManager.instance = new ScreenManager();\r\n        }\r\n        return ScreenManager.instance;\r\n    }\r\n    private static instance: ScreenManager;\r\n\r\n    /** The Aplication object used to interact with PIXI */\r\n    private pixiApp: PIXI.Application | null = null;\r\n\r\n    private receptorsVisible = false;\r\n    private receptorSprites: TapNoteReceptorSprite[] = [];\r\n\r\n    private noteField: NoteField | undefined;\r\n\r\n    // Private constructor for singleton\r\n    private constructor() {}\r\n\r\n    public initPixi(options: ScreenManagerOptions) {\r\n        console.log('initpixi');\r\n        // Create a new PIXI app.\r\n        this.pixiApp = new PIXI.Application({\r\n            width: options.width,\r\n            height: options.height,\r\n            view: options.renderCanvas,\r\n            backgroundColor: 0x000000,\r\n            forceCanvas: true,\r\n        });\r\n        if (this.pixiApp.renderer instanceof PIXI.CanvasRenderer) {\r\n            console.log('its canvas');\r\n        }\r\n        // TODO: switch this to using pixi-display for performance\r\n        // Uncomment next line to reverse Z ordering if desired\r\n        // this.pixiApp.stage.sortableChildren = true;\r\n        // Tell the resource manager it can load things now\r\n        RESOURCEMAN.loadSprites();\r\n        // Start the tick loop for animations and other such things\r\n        this.pixiApp.ticker.maxFPS = ScreenManager.desiredFps();\r\n        this.pixiApp.ticker.start();\r\n    }\r\n\r\n    public isInit() { return this.pixiApp !== null; }\r\n    public isReadyToDraw() { return this.isInit() && RESOURCEMAN.isDoneLoading(); }\r\n    public getPixiApp() {\r\n        if (this.pixiApp === null) {\r\n            throw new Error('Tried to get null pixiApp. Use isInit() first to ensure it exists.');\r\n        }\r\n        return this.pixiApp;\r\n    }\r\n\r\n    public setBgColor(color: number) { this.getPixiApp().renderer.backgroundColor = color; }\r\n\r\n    // TODO: move receptors into NoteField\r\n    /** Draw the receptors to the screen. If they're already there do nothing. */\r\n    public showReceptors() {\r\n        // TODO: loop over numTracks\r\n        if (this.receptorsVisible) { return; }\r\n        if (this.receptorSprites.length === 0) {\r\n            // Initialise them in arrow order <- v ^ ->\r\n            const initOrder = [\r\n                TapNoteDirection.LEFT,\r\n                TapNoteDirection.DOWN,\r\n                TapNoteDirection.UP,\r\n                TapNoteDirection.RIGHT,\r\n            ];\r\n            for (const direction of initOrder) {\r\n                this.receptorSprites.push(\r\n                    new TapNoteReceptorSprite(direction)\r\n                    .addToStage());\r\n            }\r\n        }\r\n        for (const receptor of this.receptorSprites) {\r\n            receptor.getSprite().visible = true;\r\n        }\r\n\r\n        this.noteField = new NoteField();\r\n        this.receptorsVisible = true;\r\n    }\r\n\r\n    /** Hide the receptors from the screen. */\r\n    public hideReceptors() {\r\n        if (!this.receptorsVisible || this.receptorSprites.length === 0) { return; }\r\n        for (const receptor of this.receptorSprites) {\r\n            receptor.getSprite().visible = false;\r\n        }\r\n        this.receptorsVisible = false;\r\n    }\r\n}\r\nconst SCREENMAN = ScreenManager.getInstance();\r\nexport default SCREENMAN;\r\n","\n\n\n\n\n\n\n\n\r\nimport Vue from 'vue';\r\nimport { Component } from 'vue-property-decorator';\r\n\r\nimport SCREENMAN, { ScreenManager } from '@/lib/ScreenManager';\r\n\r\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\r\n@Component\r\nclass Screen extends Vue {\r\n  public $refs!: {\r\n    renderCanvas: HTMLCanvasElement,\r\n  };\r\n\r\n  public data() {\r\n    return {};\r\n  }\r\n  public provide() {\r\n    return {};\r\n  }\r\n\r\n  public mounted() {\r\n    console.log('mounted');\r\n    // Determine the width and height of the renderer wrapper element.\r\n    const renderCanvas = this.$refs.renderCanvas;\r\n    const width = renderCanvas.offsetWidth;\r\n    const height = renderCanvas.offsetHeight;\r\n\r\n    // Add us to the ScreenManager if we haven't been already.\r\n    if (!SCREENMAN.isInit()) {\r\n      SCREENMAN.initPixi({\r\n        renderCanvas,\r\n        width,\r\n        height,\r\n      });\r\n    }\r\n  }\r\n}\r\nexport default Screen;\r\n","// tslint:disable: max-classes-per-file\r\n\r\nimport { TapNote, TapNoteSubType, TapNotes, MAX_NOTE_ROW } from './NoteTypes';\r\nimport TimingData from './TimingData';\r\nimport { TapNoteType } from './NoteTypes';\r\nimport { NotImplementedError } from './Error';\r\nimport { ASSERT, DEBUG_ASSERT } from './Debug';\r\nimport { PassByRef } from './GameConstantsAndTypes';\r\n\r\n// NoteData is organized by:\r\n//   track - corresponds to different columns of notes on the screen\r\n//   row/index - corresponds to subdivisions of beats\r\n\r\n// C++ code used this type, we need a better type since in C++ maps are sorted.\r\n// Without sorting, iteration over tracks becomes a problem. - Struz\r\n// type TrackMap = Map<number, TapNote>;\r\n\r\nexport class TrackMap {\r\n    // Shut tslint up about functions that may not exist until .proxy() runs\r\n    [x: string]: any;\r\n\r\n    private static skipOverride = ['set', 'entries', 'values', 'keys', 'constructor'];\r\n    private static sortNumbersAsc(a: [number, TapNote], b: [number, TapNote]) {\r\n        return a[0] - b[0];\r\n    }\r\n    // TODO: write tests for me to ensure I stay ordered\r\n    // TODO: iterators - forward and backwards, and specific ranges\r\n\r\n    public size: number;\r\n    private map: Map<number, TapNote>;        /** The map object backing this. */\r\n    private mapReverse: Map<number, TapNote>; /** Required for backwards iteration. */\r\n    private isSorted: boolean;\r\n\r\n\r\n    constructor() {\r\n        this.map = new Map();\r\n        this.mapReverse = new Map();\r\n        this.size = 0;\r\n        this.isSorted = true;\r\n        this.proxy();\r\n    }\r\n\r\n    // Iterator wrappers\r\n    /** Wrapper for map.entries() that ensures that entries are looped in ascending order. */\r\n    public entries(startAt?: number, endAt?: number) {\r\n        this.sort();\r\n        return new TrackMapIterator(this.map, IteratorDirection.Forwards, startAt, endAt);\r\n    }\r\n    public keys() {\r\n        this.sort();\r\n        return this.map.keys();\r\n    }\r\n    public values() {\r\n        this.sort();\r\n        return this.map.values();\r\n    }\r\n    public [Symbol.iterator](): IterableIterator<[number, TapNote]> {\r\n        this.sort();\r\n        return this.map[Symbol.iterator]();\r\n    }\r\n    // Reverse iterators. The reason behind using a reversed map to do reverse\r\n    // iteration is that ES6 maps use hashing and internal [[MapData]] slots.\r\n    // If we were to implement the reverse iteration using arrays we would lose\r\n    // some efficiency, so we take the hit in terms of memory to store a\r\n    // second copy of the map.\r\n    public reverseEntries(startAt?: number, endAt?: number) {\r\n        this.sort();\r\n        return new TrackMapIterator(this.mapReverse, IteratorDirection.Backwards, startAt, endAt);\r\n    }\r\n    public reverseKeys() {\r\n        this.sort();\r\n        return this.mapReverse.keys();\r\n    }\r\n    public reverseValues() {\r\n        this.sort();\r\n        return this.mapReverse.values();\r\n    }\r\n\r\n    // TODO: when we delete we need to mirror the delete to the\r\n    // other map. They will stay sorted this way! Otherwise we need to\r\n    // invalidate and sort again.\r\n\r\n    /** Wrapper for map.set() that sets some extra state. */\r\n    public set(key: number, value: TapNote) {\r\n        this.map.set(key, value);\r\n        this.isSorted = false;\r\n        this.size = this.map.size;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sort the map - relatively expensive operation as it must create a new map.\r\n     * Ideally we won't be using this much as we shouldn't be inserting mid-gameplay.\r\n     */\r\n    private sort() {\r\n        if (this.isSorted) { return; }\r\n\r\n        const sortedEntriesAsc = [...this.map.entries()].sort(TrackMap.sortNumbersAsc);\r\n        // shallow copy with .slice() then reverse it. Possibly not necessary.\r\n        const sortedEntriesDesc = sortedEntriesAsc.slice().reverse();\r\n\r\n        this.map = new Map(sortedEntriesAsc);\r\n        this.mapReverse = new Map(sortedEntriesDesc);\r\n        this.isSorted = true;\r\n        this.proxy();\r\n    }\r\n\r\n    /**\r\n     * Proxy the inner map's functions to the outside of this class.\r\n     * This is so we can use all the map's features with very little work.\r\n     * Each time we change the inner map we need to re-proxy.\r\n     */\r\n    private proxy() {\r\n        const mapProps = Object.getOwnPropertyNames(Object.getPrototypeOf(this.map));\r\n        // For each property of map that's a function and that we don't\r\n        // want to override ourselves, proxy that function directly via a bound function.\r\n        mapProps.forEach((prop) => {\r\n            if (TrackMap.skipOverride.indexOf(prop) !== -1 ||\r\n                typeof (this.map as any)[prop] !== 'function') {\r\n                return;\r\n            }\r\n            const mapFunc = (this.map as any)[prop].bind(this.map);\r\n            const reverseMapFunc = (this.mapReverse as any)[prop].bind(this.mapReverse);\r\n            // We have to wrap the func rather than assign it directly to\r\n            // ensure our .size method works.\r\n            const wrapFunc = (...args: any) => {\r\n                const retVal = mapFunc(...args);\r\n                reverseMapFunc(...args);\r\n                this.size = this.map.size;  // stay in sync\r\n                // We're primarily concerned with the ascending map, so we return that\r\n                return retVal;\r\n            };\r\n            this[prop] = wrapFunc;\r\n        });\r\n    }\r\n}\r\n\r\nenum IteratorDirection {\r\n    Forwards,\r\n    Backwards,\r\n}\r\n\r\n/**\r\n * Iterator over a TrackMap that keeps state about where in the track it is.\r\n */\r\nclass TrackMapIterator implements IterableIterator<[number, TapNote]> {\r\n    /* Depending on the direction we need different comparisons for using\r\n     * startAt and endAt. */\r\n    private static compare(value1: number, value2: number, direction: IteratorDirection) {\r\n        if (direction === IteratorDirection.Forwards) {\r\n            return value1 >= value2;\r\n        }\r\n        return value1 <= value2;\r\n    }\r\n\r\n    private it: Iterator<[number, TapNote]>;\r\n    // We need to store the last next() result as we internally need next() to\r\n    // set up the iterator.\r\n    private lastNextResult: IteratorResult<[number, TapNote]> | undefined;\r\n    private direction: IteratorDirection;\r\n    private start: number | undefined;\r\n    private end: number | undefined;\r\n\r\n    // TODO: make the startAt version of this as performant as the possible implementations\r\n    // at https://en.cppreference.com/w/cpp/algorithm/lower_bound\r\n    constructor(map: Map<number, TapNote>, direction: IteratorDirection,\r\n                startAt?: number, endAt?: number) {\r\n        this.it = map.entries();\r\n        this.direction = direction;\r\n        this.start = startAt;\r\n        this.end = endAt;\r\n        if (this.start === undefined) { return; }\r\n\r\n        // Set the iterator to start at the given index\r\n        // We need to use this.it.next() rather than this.next() so that\r\n        // we get fine grained control over how we store lastNextResult and don't\r\n        // skip too far ahead with extra this.it.next() calls.\r\n        let result = this.it.next();\r\n        while (!result.done) {\r\n            if (TrackMapIterator.compare(result.value[0], this.start, this.direction)) {\r\n                this.lastNextResult = result;\r\n                return;\r\n            }\r\n            result = this.it.next();\r\n        }\r\n    }\r\n\r\n    public next(): IteratorResult<[number, TapNote]> {\r\n        if (this.lastNextResult === undefined) {\r\n            this.lastNextResult = this.it.next();\r\n        }\r\n        const ret = this.lastNextResult;\r\n\r\n        // If we've been told to end at a certain point and we're at that point\r\n        // then send a done IteratorResult and stop iterating.\r\n        if (this.end !== undefined) {\r\n            if (TrackMapIterator.compare(ret.value[0], this.end, this.direction)) {\r\n                return {value: ret.value, done: true};\r\n            }\r\n        }\r\n\r\n        // Otherwise keep iterating as usual\r\n        this.lastNextResult = this.it.next();\r\n        return ret;\r\n    }\r\n\r\n    public [Symbol.iterator](): IterableIterator<[number, TapNote]> {\r\n        return this;\r\n    }\r\n\r\n    // /** Peek the iterator without going anywhere.\r\n    //  * Useful for assessing whether we start at the end of a range already.\r\n    //  */\r\n    // public peek(): IteratorResult<[number, TapNote]> {\r\n    //     if (this.lastNextResult === undefined) {\r\n    //         this.lastNextResult = this.it.next();\r\n    //     }\r\n    //     return this.lastNextResult;\r\n    // }\r\n\r\n    public track(): number {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    public row(): number {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    public finished(): boolean {\r\n        // We can't know if we're finished if we haven't gone anywhere\r\n        if (this.lastNextResult === undefined) {\r\n            return false;\r\n        }\r\n        return this.lastNextResult.done;\r\n    }\r\n\r\n    // TODO: fill this out when I understand more about the use cases\r\n}\r\n\r\n// Helper functions that were #defined in C++. Translated with the same format for clarity.\r\n/** Act on each non empty row in the specific track. */\r\nexport function FOREACH_NONEMPTY_ROW_IN_TRACK(\r\n    nd: NoteData, track: number, row: PassByRef<number>,\r\n    fn: (row: PassByRef<number>) => void) {\r\n        // Takes row in so that it can pass it back out again if necessary\r\n        for (row.value = -1; nd.getNextTapNoteRowForTrack(track, row); row.value++) {\r\n            fn(row);\r\n        }\r\n    }\r\n/** Act on each non empty row in the specified track within the specified range. */\r\n\r\n/** Act on each non empty row in the specified track within the specified range, going in reverse order. */\r\n/** Act on each non empty row for all of the tracks. */\r\nexport function FOREACH_NONEMPTY_ROW_ALL_TRACKS(\r\n    nd: NoteData, row: PassByRef<number>, fn: (row: PassByRef<number>) => void) {\r\n        for (row.value = -1; nd.getNextTapNoteRowForAllTracks(row); row.value++) {\r\n            fn(row);\r\n        }\r\n    }\r\n/** Act on each non empty row for all of the tracks within the specified range. */\r\n// I'm not sure why but this loop is 1-indexed while the array is 0-indexed, so it translates between.\r\n// TODO: make it all 0 indexed since the users add 1 to their values just to get them subtracted again here.\r\nexport function FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE(\r\n    nd: NoteData, row: PassByRef<number>, start: number,\r\n    last: number, fn: (row: PassByRef<number>) => void) {\r\n        for (row.value = start - 1; nd.getNextTapNoteRowForAllTracks(row) && row.value < last;) {\r\n            fn(row);\r\n        }\r\n    }\r\n\r\n/** Holds data about the notes that the player is supposed to hit. */\r\nexport class NoteData {\r\n    // IMPORTANT: this is one hell of a class.....needs doing asap!\r\n    // We need all track iterators and shit, it's wild\r\n\r\n    // There's no point in inserting empty notes into the map.\r\n    // Any blank space in the map is defined to be empty.\r\n    public tapNotes: TrackMap[] = []; // TODO: make this private once we have a standard way of iterating over it\r\n    public loaded: boolean = false;\r\n\r\n    public setOccurranceTimeForAllTaps(timingData: TimingData) { throw new NotImplementedError(); }\r\n    public countNotesInColumn(\r\n        timingData: TimingData,\r\n        noteCounts: Array<Map<TapNoteType, number>>,\r\n        holdDurations: Array<Map<TapNoteSubType, number>>) { throw new NotImplementedError(); }\r\n\r\n    public getNumTracks() { return this.tapNotes.length; }\r\n    public setNumTracks(newNumTracks: number) {\r\n        this.tapNotes.length = newNumTracks;\r\n        for (let i = 0; i < newNumTracks; i++) {\r\n            // If we extended it then make sure we create the new maps)\r\n            this.tapNotes[i] = (this.tapNotes[i] === undefined ? new TrackMap() : this.tapNotes[i]);\r\n        }\r\n    }\r\n    public isComposite() { throw new NotImplementedError(); }\r\n    public equals(other: NoteData) { return this.tapNotes === other.tapNotes; }\r\n\r\n    public getTapNote(track: number, row: number): TapNote {\r\n        // TODO: I think I can improve the original application's performance by not\r\n        // doing ANOTHER .get() here, but instead just returning the TapNote()\r\n        // out of the function. Or keeping a constant iterator which can straight return the value.\r\n        // Optimise later, only if performance suffers.\r\n        const trackMap = this.tapNotes[track];\r\n        const noteRow = trackMap.get(row);\r\n        // The distinction betwen this and findTapNote is that this returns an empty note\r\n        // if the note doesn't explicitly exist.\r\n        return (noteRow === undefined) ? TapNotes.newEmpty() : noteRow;\r\n    }\r\n\r\n    public findTapNote(track: number, row: number): TapNote | undefined { return this.tapNotes[track].get(row); }\r\n    public removeTapNote(track: number, row: number) { this.tapNotes[track].delete(row); }\r\n\r\n    // I wonder if we'll need this - Struz\r\n    /**\r\n     * Return an iterator range for [rowBegin,rowEnd).\r\n     *\r\n     * This can be used to efficiently iterate trackwise over a range of notes.\r\n     * It's like FOREACH_NONEMPTY_ROW_IN_TRACK_RANGE, except it only requires\r\n     * two map searches (iterating is constant time), but the iterators will\r\n     * become invalid if the notes they represent disappear, so you need to\r\n     * pay attention to how you modify the data.\r\n     * @param iTrack the column to use.\r\n     * @param iStartRow the starting point.\r\n     * @param iEndRow the ending point.\r\n     * @param begin the eventual beginning point of the range.\r\n     * @param end the eventual end point of the range.\r\n     */\r\n    public getTapNoteRange(track: number, startRow: number, endRow: number,\r\n                           iterator: undefined, constIterator: undefined) { throw new NotImplementedError(); }\r\n    // Omitted overloaded getTapNoteRange()\r\n\r\n    // Omitted all the iterator funcs - need to work out how I'll handle this\r\n\r\n    public getTapNoteRangeInclusive() { throw new NotImplementedError(); }\r\n    // Omitted overloaded getTapNoteRangeInclusive()\r\n\r\n    public getTapNoteRangeExclusive() { throw new NotImplementedError(); }\r\n    // Omitted overloaded getTapNoteRangeExclusive()\r\n\r\n    /* Returns the row of the first TapNote on the track that has a row greater than rowInOut. */\r\n    public getNextTapNoteRowForTrack(track: number, rowInAndOut: PassByRef<number>, ignoreAutoKeysounds = false) {\r\n        const mapTrack = this.tapNotes[track];\r\n        const iter = mapTrack.entries(rowInAndOut.value + 1); // \"find the first note for which row+1 < key == false\"\r\n        let entry = iter.next();\r\n        if (entry.done) { return false; }\r\n\r\n        DEBUG_ASSERT(entry.value[0] > rowInAndOut.value);\r\n\r\n        if (ignoreAutoKeysounds) {\r\n            while (entry.value[1].type === TapNoteType.AutoKeysound) {\r\n                entry = iter.next();\r\n                if (entry.done) { return false; }\r\n            }\r\n        }\r\n        rowInAndOut.value = entry.value[0];\r\n        return true;\r\n    }\r\n\r\n    public getNextTapNoteRowForAllTracks(rowInAndOut: PassByRef<number>) {\r\n        let closestNextRow = MAX_NOTE_ROW;\r\n        let anyHaveNextNote = false;\r\n        for (let t = 0; t < this.getNumTracks(); t++) {\r\n            const newRowThisTrack = {value: rowInAndOut.value};\r\n            if (this.getNextTapNoteRowForTrack(t, newRowThisTrack)) {\r\n                anyHaveNextNote = true;\r\n                ASSERT(newRowThisTrack.value < MAX_NOTE_ROW, 'Row should never exceed MAX_NOTE_ROW');\r\n                closestNextRow = Math.min(closestNextRow, newRowThisTrack.value);\r\n            }\r\n        }\r\n\r\n        if (anyHaveNextNote) {\r\n            rowInAndOut.value = closestNextRow;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public getPrevTapNoteRowForTrack(track: number, rowInAndOut: PassByRef<number>) {\r\n        const mapTrack = this.tapNotes[track];\r\n\r\n        // Find the first note >= rowInOut.\r\n        const iter = mapTrack.reverseEntries(rowInAndOut.value);\r\n\r\n        // If we're at the beginning, we can't move back any more.\r\n        const entry = iter.next();\r\n        if (entry.done) { return false; }\r\n\r\n        // Move back by one\r\n        DEBUG_ASSERT(entry.value[0] < rowInAndOut.value);\r\n        rowInAndOut.value = entry.value[0];\r\n        return true;\r\n    }\r\n\r\n    public getPrevTapNoteRowForAllTracks(rowInAndOut: PassByRef<number>) {\r\n        let closestPrevRow = 0;\r\n        let anyHavePrevNote = false;\r\n        for (let t = 0; t < this.getNumTracks(); t++) {\r\n            const newRowThisTrack = {value: rowInAndOut.value};\r\n            if (this.getPrevTapNoteRowForTrack(t, newRowThisTrack)) {\r\n                anyHavePrevNote = true;\r\n                DEBUG_ASSERT(newRowThisTrack.value < MAX_NOTE_ROW);\r\n                closestPrevRow = Math.max(closestPrevRow, newRowThisTrack.value);\r\n            }\r\n        }\r\n\r\n        if (anyHavePrevNote) {\r\n            rowInAndOut.value = closestPrevRow;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public moveTapNoteTrack(dest: number, src: number) { throw new NotImplementedError(); }\r\n    public setTapNote(track: number, row: number, tn: TapNote) {\r\n        DEBUG_ASSERT(track >= 0 && track < this.getNumTracks());\r\n\r\n        if (row < 0) {\r\n            return;\r\n        }\r\n        // There's no point in inserting empty notes into the map.\r\n        // Any blank space in the map is defined to be empty.\r\n        // If we're trying to insert an empty at a spot where another note\r\n        // already exists, then we're really deleting from the map.\r\n        if (tn.equals(TapNotes.EMPTY)) {\r\n            const trackMap = this.tapNotes[track];\r\n            // remove the element at this position (if any).\r\n            // This will return either true or false.\r\n            trackMap.delete(row);\r\n        } else {\r\n            this.tapNotes[track].set(row, tn);\r\n        }\r\n    }\r\n    /**\r\n     * @brief Add a hold note, merging other overlapping holds and destroying\r\n     * tap notes underneath.\r\n     * @param iTrack the column to work with.\r\n     * @param iStartRow the starting row.\r\n     * @param iEndRow the ending row.\r\n     * @param tn the tap note.\r\n     */\r\n    public addHoldNote(track: number, startRow: number, endRow: number, tn: TapNote) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    public clearRangeForTrack(rowBegin: number, rowEnd: number, track: number) { return new NotImplementedError(); }\r\n    public clearRange(rowBegin: number, rowEnd: number) { return new NotImplementedError(); }\r\n    public clearAll() {\r\n        for (const track of this.tapNotes) {\r\n            track.clear();\r\n        }\r\n    }\r\n    public copyRange() { return new NotImplementedError(); }\r\n    public copyAll() { return new NotImplementedError(); }\r\n\r\n    public isRowEmpty(row: number) { return new NotImplementedError(); }\r\n    /* Determine if a hold note lies on the given spot. Return true if so.  If\r\n     * pHeadRow is non-nullptr, return the row of the head. (Note that this returns\r\n     * false if a hold head lies on iRow itself.) */\r\n    public isHoldNoteAtRow(track: number, row: number, headRow: PassByRef<number>) {\r\n        /* Starting at iRow, search upwards. If we find a TapNoteType_HoldHead, we're within\r\n         * a hold. If we find a tap, mine or attack, we're not--those never lie\r\n         * within hold notes. Ignore autoKeysound. */\r\n        for (const rowPbr = {value: row}; this.getPrevTapNoteRowForTrack(track, rowPbr) && rowPbr.value >= 0;) {\r\n            const tn = this.getTapNote(track, rowPbr.value);\r\n            switch (tn.type) {\r\n                case TapNoteType.HoldHead:\r\n                    if (tn.duration + rowPbr.value < row) {\r\n                        return false;\r\n                    }\r\n                    headRow.value = rowPbr.value;\r\n                    return true;\r\n\r\n                case TapNoteType.Tap:\r\n                case TapNoteType.Mine:\r\n                case TapNoteType.Attack:\r\n                case TapNoteType.Lift:\r\n                case TapNoteType.Fake:\r\n                    return false;\r\n\r\n                case TapNoteType.Empty:\r\n                case TapNoteType.AutoKeysound:\r\n                    // ignore\r\n                    continue;\r\n                default:\r\n                    throw new Error(`Unknwon TapNoteType: ${tn.type}`);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public isThereATapAtRow(row: number) {\r\n        return this.getFirstTrackWithTap(row) !== -1;\r\n    }\r\n\r\n    public isThereATapOrHoldHeadAtRow(row: number) {\r\n        return this.getFirstTrackWithTapOrHoldHead(row) !== -1;\r\n    }\r\n\r\n    /**\r\n     * In the given row return the first track with a tap type.\r\n     * Returns -1 if no track has a tap type note.\r\n     */\r\n    public getFirstTrackWithTap(row: number) {\r\n        for (let t = 0; t < this.getNumTracks(); t++) {\r\n            const tn = this.getTapNote(t, row);\r\n            if (tn.type === TapNoteType.Tap || tn.type === TapNoteType.Lift) {\r\n                return t;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * In the given row return the first track with a tap or hold-head type.\r\n     * Returns -1 if no track has a tap or hold-head type.\r\n     */\r\n    public getFirstTrackWithTapOrHoldHead(row: number) {\r\n        for (let t = 0; t < this.getNumTracks(); t++) {\r\n            const tn = this.getTapNote(t, row);\r\n            if (tn.type === TapNoteType.Tap ||\r\n                tn.type === TapNoteType.Lift ||\r\n                tn.type === TapNoteType.HoldHead) {\r\n                return t;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    // TODO: finish me off sometime from NoteData.h\r\n}\r\nexport default NoteData;\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Screen.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Screen.vue?vue&type=template&id=1165683c&scoped=true&\"\nimport script from \"./Screen.vue?vue&type=script&lang=ts&\"\nexport * from \"./Screen.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Screen.vue?vue&type=style&index=0&id=1165683c&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1165683c\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"chart-picker\"},[_c('v-select',{attrs:{\"items\":_vm.packs,\"item-text\":\"name\",\"item-value\":\"name\",\"label\":\"Pack\"},on:{\"change\":function($event){return _vm.changePackEvent()}},model:{value:(_vm.selectedPack),callback:function ($$v) {_vm.selectedPack=$$v},expression:\"selectedPack\"}}),_c('v-select',{attrs:{\"items\":_vm.charts,\"item-text\":\"name\",\"item-value\":\"name\",\"label\":\"Chart\"},on:{\"change\":function($event){return _vm.changeChartEvent()}},model:{value:(_vm.selectedChart),callback:function ($$v) {_vm.selectedChart=$$v},expression:\"selectedChart\"}}),_c('v-select',{attrs:{\"items\":_vm.steps,\"item-text\":_vm.getStepsItemText,\"item-value\":_vm.getStepsItemValue,\"label\":\"Steps\"},on:{\"change\":function($event){return _vm.changeStepsEvent()}},model:{value:(_vm.selectedSteps),callback:function ($$v) {_vm.selectedSteps=$$v},expression:\"selectedSteps\"}})],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import axios from 'axios';\r\nimport { Howl } from 'howler';\r\n\r\nconst OGG_LOAD_TIMEOUT = 60000; // Milliseconds\r\nconst OGG_LOAD_POLL    = 200;   // Milliseconds\r\n\r\nclass FileOperations {\r\n    // URI must already be encoded\r\n    public static loadTextFile(uri: string) {\r\n        return axios.get(uri, {responseType: 'text'}).then((response) => {\r\n            return response.data;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load an ogg file as a howl.\r\n     * @param uri The URI of the ogg file.\r\n     * @param stream if true allow streaming the file.\r\n     * @returns a promise which will return a Howl on successful completion.\r\n     */\r\n    public static loadOggFileAsHowl(uri: string, stream = false): Promise<Howl> {\r\n        let loaded = false;\r\n        let error: Error | null = null;\r\n        const oggHowl = new Howl({\r\n            src: [uri],\r\n            html5: stream,\r\n            onload: () => {\r\n                loaded = true;\r\n            },\r\n            onloaderror: (_, msg) => {\r\n                error = new Error(`error loading .ogg file at ${uri}: ${msg}`);\r\n            },\r\n        });\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const startTime = Date.now();\r\n            const timeout = OGG_LOAD_TIMEOUT;\r\n            const checkLoaded = () => {\r\n                if (loaded) {\r\n                    console.log(`succesfully loaded .ogg file at ${uri}`);\r\n                    resolve(oggHowl);\r\n                } else if (error !== null) {\r\n                    throw error;\r\n                } else if (Date.now() > startTime + timeout) {\r\n                    throw new Error(`timed out after ${timeout}ms while loading .ogg file at ${uri}`);\r\n                } else {\r\n                    setTimeout(checkLoaded, OGG_LOAD_POLL);\r\n                }\r\n            };\r\n            checkLoaded();\r\n        });\r\n    }\r\n}\r\nexport default FileOperations;\r\n","import NoteData from './NoteData';\r\nimport Helpers, { StepsType, Difficulty } from './GameConstantsAndTypes';\r\nimport TimingData from './TimingData';\r\nimport { NoteDataUtil } from './NoteDataUtil';\r\nimport Song from './Song';\r\n\r\n/**\r\n * Enforce a limit on the number of chars for the description.\r\n *\r\n * In In The Groove, this limit was 12: we do not need such a limit now.\r\n */\r\nexport const MAX_STEPS_DESCRIPTION_LENGTH = 255;\r\n\r\n/** The different ways of displaying the BPM. */\r\nexport enum DisplayBPM {\r\n    ACTUAL, /** Display the song's actual BPM. */\r\n    SPECIFIED, /** Display a specified value or values. */\r\n    RANDOM, /** Display a random selection of BPMs. */\r\n    NUM,\r\n    Invalid,\r\n}\r\n\r\n/**\r\n * Holds note information for a Song.\r\n * A Song may have one or more Notes.\r\n */\r\nexport class Steps {\r\n    /**\r\n     * The TimingData used by the Steps.\r\n     * This is required to allow Split Timing.\r\n     */\r\n    public timingData: TimingData = new TimingData();\r\n    // Type info for these steps\r\n    public stepsType: StepsType = StepsType.Invalid;\r\n    /** The string form of the StepsType, for dealing with unrecognized styles. */\r\n    public stepsTypeName: string = '';\r\n    /** The Song these Steps are associated with */\r\n    public song: Song;\r\n\r\n    // The name of the edit, or some other useful description.\r\n    // This used to also contain the step author's name.\r\n    public description: string = '';\r\n    // The style of the chart. (e.g. \"Pad\", \"Keyboard\")\r\n    public chartStyle: string = '';\r\n    // The difficulty that these steps are assigned to.\r\n    public difficulty: Difficulty = Difficulty.Invalid;\r\n    // The numeric difficulty of the Steps, ranging from MIN_METER to MAX_METER.\r\n    public meter: number = -1;\r\n    // NOTE: omitted radar values - I do not know what these are\r\n    // The name of the person who created the Steps\r\n    public credit: string = '';\r\n    // The name of the chart\r\n    public chartName: string = '';\r\n    // How is the BPM displayed for the chart?\r\n    public displayBPMType: number = DisplayBPM.ACTUAL;\r\n    // What is the minimum specified BPM?\r\n    public specifiedBpmMin: number = 0;\r\n    // What is the maximum specified BPM?\r\n    // If this is a range then min should not be equal to max\r\n    public specifiedBpmMax: number = 0;\r\n\r\n    // Note data for the song\r\n    private noteData: NoteData = new NoteData();\r\n    // Compressed note data for the song\r\n    private noteDataCompressed: string;\r\n    private noteDataIsFilled: boolean = false;\r\n\r\n    constructor(noteData: string, song: Song) {\r\n        this.noteDataCompressed = noteData;\r\n        this.song = song;\r\n    }\r\n\r\n    public getNoteData() { return this.noteData; }\r\n    public getCompressedNoteData() { return this.noteDataCompressed; }\r\n    public isNoteDataFilled() { return this.noteDataIsFilled; }\r\n    public getTimingData() { return this.timingData.empty() ? this.song.songTiming : this.timingData; }\r\n\r\n    public decompress() {\r\n        if (this.noteDataIsFilled) {\r\n            return; // already decompressed\r\n        }\r\n\r\n        // load from compressed\r\n        // Omitted composite - not supporting (for now) - Struz\r\n        this.noteDataIsFilled = true;\r\n        this.noteData.setNumTracks(Helpers.getStepsTypeInfo(this.stepsType).numTracks);\r\n        NoteDataUtil.loadFromSmNoteDataString(this.noteData, this.noteDataCompressed);\r\n    }\r\n\r\n    public tidyUpData(): void {\r\n        // Don't set the StepsType to dance single if it's invalid.  That just\r\n        // causes unrecognized charts to end up where they don't belong.\r\n        // Leave it as StepsType_Invalid so the Song can handle it specially.  This\r\n        // is a forwards compatibility feature, so that if a future version adds a\r\n        // new style, editing a simfile with unrecognized Steps won't silently\r\n        // delete them. -Kyz\r\n        if (this.stepsType === StepsType.Invalid) {\r\n            const stepsTypeString = this.stepsTypeName;\r\n            console.warn(`Detected steps with unknown style '${stepsTypeString}' in sm data`);\r\n        } else if (this.stepsTypeName === '') {\r\n            // TODO: lookup the StepsTypeInfo for the stepsType and set the typeName using it\r\n        }\r\n\r\n        if (this.difficulty === Difficulty.Invalid) {\r\n            // TODO: something about setting the difficulty based on the description\r\n        }\r\n\r\n        if (this.difficulty === Difficulty.Invalid) {\r\n            if (this.meter === 1) {\r\n                this.difficulty = Difficulty.Beginner;\r\n            } else if (this.meter <= 3) {\r\n                this.difficulty = Difficulty.Easy;\r\n            } else if (this.meter <= 6) {\r\n                this.difficulty = Difficulty.Medium;\r\n            } else {\r\n                this.difficulty = Difficulty.Hard;\r\n            }\r\n        }\r\n\r\n        if (this.meter < 1) {\r\n            // meter is invalid!\r\n            // TODO: translate prediction function, if it ever seems useful - Struz\r\n            // this.meter = this.predictMeter()\r\n        }\r\n    }\r\n}\r\nexport default Steps;\r\n","import NoteData from './NoteData';\r\nimport { PLAYER_INVALID, PlayerNumber } from './PlayerNumber';\r\nimport NoteHelpers, { TapNote, TapNotes, MAX_NOTE_ROW, TapNoteType, BEATS_PER_MEASURE } from './NoteTypes';\r\n\r\n/**\r\n * Utility functions that deal with NoteData.\r\n *\r\n * Things should go in here if they can be (cleanly and efficiently)\r\n * implemented using only NoteData's primitives; this improves abstraction\r\n * and makes it much easier to change NoteData internally in the future.\r\n */\r\nexport class NoteDataUtil {\r\n// tslint:disable-next-line: variable-name\r\n    public static loadFromSmNoteDataString(out: NoteData, smNoteData_: string): void {\r\n        // Load note data\r\n        let smNoteData: string = '';\r\n        let indexCommentStart = 0;\r\n        let indexCommentEnd = 0;\r\n        let index = 0;\r\n\r\n        // Remove comments from the passed in note data\r\n// tslint:disable-next-line: no-conditional-assignment\r\n        while ( (indexCommentStart = smNoteData_.indexOf('//', indexCommentEnd)) !== -1 ) {\r\n            // Append the data in between the last comment and this comment\r\n            smNoteData += smNoteData_.substr(index, indexCommentStart - indexCommentEnd);\r\n            index += indexCommentStart - indexCommentEnd;\r\n            // Move forward to the end of the comment\r\n            indexCommentEnd = smNoteData_.indexOf('\\n', indexCommentStart);\r\n            indexCommentEnd = (indexCommentEnd === -1 ? smNoteData_.length : indexCommentEnd + 1);\r\n            index += indexCommentEnd - indexCommentStart;\r\n        }\r\n        smNoteData += smNoteData_.substr(index, smNoteData_.length - indexCommentEnd);\r\n\r\n        // Clear notes, but keep the same number of tracks.\r\n        const numTracks = out.getNumTracks();\r\n        out.clearAll();\r\n        out.setNumTracks(numTracks);\r\n\r\n        // We don't support composite yet so ignore composite logic - Struz\r\n        this.loadFromSmNoteDataStringWithPlayer(out, smNoteData, PLAYER_INVALID, numTracks);\r\n    }\r\n\r\n    public static loadFromSmNoteDataStringWithPlayer(\r\n        out: NoteData, smNoteData: string, pn: PlayerNumber, numTracks: number): void {\r\n        // The code in StepMania is very careful about allocations when doing this,\r\n        // probably because they're dealing with entire full libraries of charts.\r\n        // We do one at a time, we don't care. - Struz\r\n\r\n        // General algorithm is:\r\n        // Split notedata on ',' to get measures\r\n        // Split each measure on '\\n' to get rows (still as lists of char)\r\n        //    Seems to be logic to end the line when encountering \\n \\r \\t and ' '\r\n        //    Ignore empty lines - ones that have only those characters\r\n        // For each line in a measure parse the characters into the data structures\r\n\r\n        // Then cleanup by ensuring no leftover hold notes\r\n\r\n        const emptyFilter = (x: string) => {\r\n            return x.length !== 0;\r\n        };\r\n        // Split the song into measures and filter out any empty entries\r\n        const measures = smNoteData.split(',')\r\n            .map((x) => x.trim())\r\n            .filter(emptyFilter);\r\n        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {\r\n            const measure = measures[measureIndex];\r\n\r\n            // Split the measure into lines, trim them all, and remove any empty entries\r\n            // This emulates the StepMania \"find whitespace start & end and line is between that\" logic\r\n            const measureLines = measure.split('\\n')\r\n                .map((x) => x.trim())\r\n                .filter(emptyFilter);\r\n            for (let lineIndex = 0; lineIndex < measureLines.length; lineIndex++) {\r\n                const line = measureLines[lineIndex];\r\n\r\n                // Some calculations for placing data\r\n                const percentIntoMeasure = lineIndex / measureLines.length;\r\n                const beat = (measureIndex + percentIntoMeasure) * BEATS_PER_MEASURE;\r\n                const noteRow = NoteHelpers.beatToNoteRow(beat);\r\n\r\n                // Now for the fun stuff\r\n                for (let trackIndex = 0; trackIndex < numTracks; trackIndex++) {\r\n                    const noteChar = line.charAt(trackIndex);\r\n                    const tn = this.parseTapNoteData(noteChar, out, trackIndex, noteRow);\r\n\r\n                    // Optimization: if we pass TAP_EMPTY, NoteData will do a search\r\n                    // to remove anything in this position.  We know that there's nothing\r\n                    // there, so avoid the search.\r\n                    if (tn.type !== TapNoteType.Empty && noteChar !== '3') {\r\n                        tn.pn = pn;\r\n                        out.setTapNote(trackIndex, noteRow, tn);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Make sure we don't have any hold notes that didn't find a tail.\r\n        for (let t = 0; t < out.getNumTracks(); t++) {\r\n            // TODO: create a class-standard way of iterating through tracks\r\n            // preferably keeping the track variable private.\r\n            const track = out.tapNotes[t];\r\n            for (const [row, tn] of track) {\r\n                if (tn.type === TapNoteType.HoldHead && tn.duration === MAX_NOTE_ROW) {\r\n                    const beat = NoteHelpers.noteRowToBeat(row);\r\n                    console.log(`While loading .sm/.ssc note data, there was an unmatched 2 at beat ${beat}`);\r\n                    out.removeTapNote(t, row);\r\n                }\r\n            }\r\n        }\r\n        // We don't use Advanced Type Iterators so we don't need to revalidate ATIs\r\n    }\r\n\r\n    /** Parse a single character into a TapNote.\r\n     * @param noteChar the text character defining the qualities of the note.\r\n     * @param nd the NoteData to parse the note into. This is required for finding hold starts.\r\n     * @param track the track that we're parsing.\r\n     * @param noteRow the note row this note is on.\r\n     * @returns A new TapNote.\r\n     */\r\n    public static parseTapNoteData(noteChar: string,\r\n                                   nd: NoteData,\r\n                                   track: number,\r\n                                   noteRow: number): TapNote {\r\n        let tn: TapNote = TapNotes.newEmpty();\r\n\r\n        switch (noteChar) {\r\n            case '0': tn = TapNotes.newEmpty(); break;\r\n            case '1': tn = TapNotes.newOriginalTap(); break;\r\n            case '2':\r\n            case '4':\r\n                tn = (noteChar === '2') ? TapNotes.newOriginalHoldHead() : TapNotes.newOriginalRollHead();\r\n                // Set the hold note to have infinite length; We'll clamp it\r\n                // when we hit the tail.\r\n                tn.duration = MAX_NOTE_ROW;\r\n                break;\r\n            case '3':\r\n                // This is the end of a hold, search for the beginning\r\n                const headRow = {value: 0};\r\n                if (!nd.isHoldNoteAtRow(track, noteRow, headRow)) {\r\n                    console.warn(`Unmatched 3 in track=${track} for noteRow=${noteRow}`);\r\n                } else {\r\n                    const holdNote = nd.findTapNote(track, headRow.value);\r\n                    if (holdNote === undefined) {\r\n                        throw new Error(`holdNote should never be undefined: ${track}, ${headRow.value}`);\r\n                    }\r\n                    holdNote.duration = noteRow - headRow.value;\r\n                }\r\n                // This won't write tn, but keep parsing normally anyway.\r\n                break;\r\n            case 'M': tn = TapNotes.newOriginalMine(); break;\r\n            case 'K': tn = TapNotes.newOriginalAutoKeysound(); break;\r\n            case 'L': tn = TapNotes.newOriginalLift(); break;\r\n            case 'F': tn = TapNotes.newOriginalFake(); break;\r\n            default:\r\n                // Invalid data\r\n                tn = TapNotes.newEmpty();\r\n                break;\r\n        }\r\n\r\n        // Some optional checks for keysounds stuff. We don't support that yet - Struz\r\n        return tn;\r\n    }\r\n}\r\nexport default NoteDataUtil;\r\n","import Steps from './Steps';\r\nimport TimingData from './TimingData';\r\nimport { StepsType } from './GameConstantsAndTypes';\r\n\r\n// Holds all music metadata and steps for one song\r\nexport class Song {\r\n    // Probably not useful for my purposes - Struz\r\n    // See Song.h in StepMania for descriptions.\r\n    public fileName = '';\r\n    public groupName = '';\r\n\r\n    public mainTitle = '';\r\n    public subTitle = '';\r\n    public artist = '';\r\n    public mainTitleTranslit = '';\r\n    public subTitleTranslit = '';\r\n    public artistTranslit = '';\r\n\r\n    // Version of the song/file\r\n    public version = 0;\r\n    // Genre of the song/file\r\n    public genre = '';\r\n    public credit = '';\r\n    public origin = '';\r\n    // omitted musicFile, previewFile, instrumentTrackFile\r\n\r\n    public musicLengthSec = 0;\r\n    public musicSampleStartSec = 0;\r\n    public musicSampleLengthSec = 0;\r\n    public displayBpmType = 0;\r\n    public specifiedBpmMin = 0;\r\n    public specifiedBpmMax = 0;\r\n\r\n    // Omitted bannerFile, jacketFile, CDFile, DiscFile, LyricsFile,\r\n    // BackgroundFile, CDTitleFile, previewVidFile, attacks, attackString\r\n    // hasMusic, hasBanner, hasBackground\r\n\r\n    // Data for translating beats<->seconds\r\n    public songTiming: TimingData = new TimingData();\r\n\r\n    // These 3 were private in C++ but we've made them public here for now\r\n    // The first second that a note is hit\r\n    public firstSecond = 0;\r\n    // The last second that a note is hit\r\n    public lastSecond = 0;\r\n    // The last second of the song for playing purposes\r\n    public specifiedLastSecond = 0;\r\n\r\n    // The steps that belong to this Song\r\n    private steps: Steps[];\r\n    // The steps of a particular StepsType that belong to this Song\r\n    // Indexed by the enum of the step type\r\n    private stepsByType: Steps[][];\r\n    // The steps that are of unrecognised styles\r\n    private unknownStyleSteps = 'placeholder unknown style steps';\r\n\r\n    constructor() {\r\n        this.stepsByType = [];\r\n        for (let i = 0; i < StepsType.NUM; i++) {\r\n            this.stepsByType[i] = [];\r\n        }\r\n        this.steps = [];\r\n    }\r\n\r\n    public addSteps(steps: Steps): void {\r\n        // TODO: check that the steps type is valid?\r\n        this.steps.push(steps);\r\n        this.stepsByType[steps.stepsType].push(steps);\r\n    }\r\n    public hasSteps(): boolean { return this.steps.length > 0; }\r\n    public getSteps(index: number) { return this.steps[index]; }\r\n    public getAllSteps() { return this.steps; }\r\n\r\n    public tidyUpData() {\r\n        this.songTiming.tidyUpData(false);\r\n\r\n        for (const steps of this.steps) {\r\n            steps.timingData.tidyUpData(true);\r\n        }\r\n    }\r\n}\r\nexport default Song;\r\n","import MsdFile from './MsdFile';\r\nimport Steps, { DisplayBPM } from './Steps';\r\nimport Song from './Song';\r\nimport { Helpers, Difficulty } from './GameConstantsAndTypes';\r\nimport TimingData from './TimingData';\r\nimport { ROWS_PER_BEAT, NoteHelpers } from './NoteTypes';\r\nimport { TimeSignatureSegment, DelaySegment, BPMSegment,\r\n     WarpSegment, StopSegment, TickcountSegment } from './TimingSegments';\r\n\r\n/**\r\n * The highest allowable speed before Warps come in.\r\n *\r\n * This was brought in from StepMania 4's recent betas.\r\n */\r\nconst FAST_BPM_WARP = 9999999;\r\n\r\n/** The maximum file size for edits. */\r\nconst MAX_EDIT_STEPS_SIZE_BYTES\t= 60 * 1024; // 60KB\r\n\r\n// Functions used in function table below to set song data efficiently\r\ntype SongTimingInfo = Array<{[key: number]: number}>;\r\ntype SongParseFn = (info: SongTagInfo) => void;\r\n\r\ninterface SongTagInfo {\r\n    song: Song;\r\n    params: string[];\r\n    bpmChanges: SongTimingInfo;\r\n    stops: SongTimingInfo;\r\n}\r\n\r\nfunction SMSetTitle(info: SongTagInfo) {\r\n    info.song.mainTitle = info.params[1];\r\n}\r\n\r\nfunction SMSetSubtitle(info: SongTagInfo) {\r\n    info.song.subTitle = info.params[1];\r\n}\r\n\r\nfunction SMSetArtist(info: SongTagInfo) {\r\n    info.song.artist = info.params[1];\r\n}\r\n\r\nfunction SMSetTitleTranslit(info: SongTagInfo) {\r\n    info.song.mainTitleTranslit = info.params[1];\r\n}\r\n\r\nfunction SMSetSubtitleTranslit(info: SongTagInfo) {\r\n    info.song.subTitleTranslit = info.params[1];\r\n}\r\n\r\nfunction SMSetArtistTranslit(info: SongTagInfo) {\r\n    info.song.artistTranslit = info.params[1];\r\n}\r\nfunction SMSetGenre(info: SongTagInfo) {\r\n    info.song.genre = info.params[1];\r\n}\r\nfunction SMSetCredit(info: SongTagInfo) {\r\n    info.song.credit = info.params[1];\r\n}\r\nfunction SMSetBanner(info: SongTagInfo) {\r\n    console.debug('Skipping parsing banner');\r\n}\r\nfunction SMSetBackground(info: SongTagInfo) {\r\n    console.debug('Skipping parsing background file');\r\n}\r\nfunction SMSetLyricsPath(info: SongTagInfo) {\r\n    console.debug('Skipping parsing lyrics path');\r\n}\r\nfunction SMSetCDTitle(info: SongTagInfo) {\r\n    console.debug('Skipping parsing CD title');\r\n}\r\nfunction SMSetMusic(info: SongTagInfo) {\r\n    console.debug('Skipping parsing music file');\r\n}\r\nfunction SMSetOffset(info: SongTagInfo) {\r\n    info.song.songTiming.setOffset(Helpers.stringToFloat(info.params[1]));\r\n}\r\nfunction SMSetBPMs(info: SongTagInfo) {\r\n    info.bpmChanges = [];\r\n    info.bpmChanges = NoteLoaderSM.parseBpms(info.params[1]);\r\n}\r\nfunction SMSetStops(info: SongTagInfo) {\r\n    info.stops = [];\r\n    info.stops = NoteLoaderSM.parseStops(info.params[1]);\r\n}\r\nfunction SMSetDelays(info: SongTagInfo) {\r\n    NoteLoaderSM.processDelays(info.song.songTiming, info.params[1]);\r\n}\r\nfunction SMSetTimeSignatures(info: SongTagInfo) {\r\n    NoteLoaderSM.processTimeSignatures(info.song.songTiming, info.params[1]);\r\n}\r\nfunction SMSetTickCounts(info: SongTagInfo) {\r\n    NoteLoaderSM.processTickcounts(info.song.songTiming, info.params[1]);\r\n}\r\nfunction SMSetInstrumentTrack(info: SongTagInfo) {\r\n    // Implement this if it turns out to be important. It probably won't - Struz\r\n    // info.loader->ProcessInstrumentTracks(*info.song, (*info.params)[1]);\r\n}\r\nfunction SMSetSampleStart(info: SongTagInfo) {\r\n    info.song.musicSampleStartSec = Helpers.HHMMSSToSeconds(info.params[1]);\r\n}\r\nfunction SMSetSampleLength(info: SongTagInfo) {\r\n    info.song.musicSampleLengthSec = Helpers.HHMMSSToSeconds(info.params[1]);\r\n}\r\nfunction SMSetDisplayBPM(info: SongTagInfo) {\r\n    // #DISPLAYBPM:[xxx][xxx:xxx]|[*];\r\n    if (info.params[1] === '*') {\r\n        info.song.displayBpmType = DisplayBPM.RANDOM;\r\n    } else {\r\n        info.song.displayBpmType = DisplayBPM.SPECIFIED;\r\n        info.song.specifiedBpmMin = Helpers.stringToFloat(info.params[1]);\r\n        // No max specified\r\n        if (info.params.length < 3 || info.params[2] === '') {\r\n            info.song.specifiedBpmMax = info.song.specifiedBpmMin;\r\n        } else {\r\n            info.song.specifiedBpmMax = Helpers.stringToFloat(info.params[2]);\r\n        }\r\n    }\r\n}\r\nfunction SMSetSelectable(info: SongTagInfo) {\r\n    // Implement this if it turns out to be important. It probably won't - Struz\r\n}\r\nfunction SMSetBGChanges(info: SongTagInfo) {\r\n    // Implement this if it turns out to be important. It probably won't  - Struz\r\n    // info.loader->ProcessBGChanges(*info.song, (*info.params)[0], info.path, (*info.params)[1]);\r\n}\r\nfunction SMSetFGChanges(info: SongTagInfo) {\r\n   // Implement this if it turns out to be important. It probably won't - Struz\r\n}\r\nfunction SMSetKeysounds(info: SongTagInfo) {\r\n    // Seems pretty useless for an online viewer - Struz\r\n}\r\nfunction SMSetAttacks(info: SongTagInfo) {\r\n    // I don't even know what attacks are - Struz\r\n    // info.loader->ProcessAttackString(info.song->m_sAttackString, (*info.params));\r\n    // info.loader->ProcessAttacks(info.song->m_Attacks, (*info.params));\r\n}\r\n\r\n// Function table for setting song data efficiently\r\nconst songTagHandlers: Map<string, SongParseFn> = new Map([\r\n    ['TITLE', SMSetTitle],\r\n    ['SUBTITLE', SMSetSubtitle],\r\n    ['ARTIST', SMSetArtist],\r\n    ['TITLETRANSLIT', SMSetTitleTranslit],\r\n    ['SUBTITLETRANSLIT', SMSetSubtitleTranslit],\r\n    ['ARTISTTRANSLIT', SMSetArtistTranslit],\r\n    ['GENRE', SMSetGenre],\r\n    ['CREDIT', SMSetCredit],\r\n    ['BANNER', SMSetBanner],\r\n    ['BACKGROUND', SMSetBackground],\r\n    // Save \"#LYRICS\" for later, so we can add an internal lyrics tag.\r\n    ['LYRICSPATH', SMSetLyricsPath],\r\n    ['CDTITLE', SMSetCDTitle],\r\n    ['MUSIC', SMSetMusic],\r\n    ['OFFSET', SMSetOffset],\r\n    ['BPMS', SMSetBPMs],\r\n    ['STOPS', SMSetStops],\r\n    ['FREEZES', SMSetStops],\r\n    ['DELAYS', SMSetDelays],\r\n    ['TIMESIGNATURES', SMSetTimeSignatures],\r\n    ['TICKCOUNTS', SMSetTickCounts],\r\n    ['INSTRUMENTTRACK', SMSetInstrumentTrack],\r\n    ['SAMPLESTART', SMSetSampleStart],\r\n    ['SAMPLELENGTH', SMSetSampleLength],\r\n    ['DISPLAYBPM', SMSetDisplayBPM],\r\n    ['SELECTABLE', SMSetSelectable],\r\n    // It's a bit odd to have the tag that exists for backwards compatibility\r\n    // in this list and not the replacement, but the BGCHANGES tag has a\r\n    // number on the end, allowing up to NUM_BackgroundLayer tags, so it\r\n    // can't fit in the map. -Kyz\r\n    ['ANIMATIONS', SMSetBGChanges],\r\n    ['FGCHANGES', SMSetFGChanges],\r\n    ['KEYSOUNDS', SMSetKeysounds],\r\n    // Attacks loaded from file\r\n    ['ATTACKS', SMSetAttacks],\r\n    /* Tags that no longer exist, listed for posterity.  May their names\r\n        * never be forgotten for their service to Stepmania. -Kyz\r\n        * LASTBEATHINT: // unable to identify at this point: ignore\r\n        * MUSICBYTES: // ignore\r\n        * FIRSTBEAT: // cache tags from older SM files: ignore.\r\n        * LASTBEAT: // cache tags from older SM files: ignore.\r\n        * SONGFILENAME: // cache tags from older SM files: ignore.\r\n        * HASMUSIC: // cache tags from older SM files: ignore.\r\n        * HASBANNER: // cache tags from older SM files: ignore.\r\n        * SAMPLEPATH: // SamplePath was used when the song has a separate preview clip. -aj\r\n        * LEADTRACK: // XXX: Does anyone know what LEADTRACK is for? -Wolfman2000\r\n        * MUSICLENGTH: // Loaded from the cache now. -Kyz\r\n        */\r\n]);\r\n\r\n// Reads a song from a .sm file\r\nexport class NoteLoaderSM {\r\n    /**\r\n     * Convert a row value to the proper beat value.\r\n     * This is primarily used for assistance with converting SMA files.\r\n     * @param line The line that contains the value.\r\n     * @param rowsPerBeat the number of rows per beat according to the original file.\r\n     * @return the converted beat value.\r\n     */\r\n    public static rowToBeat(line: string, rowsPerBeat: number) {\r\n        // Trim r and R characters from the sides of the string\r\n// tslint:disable-next-line: max-line-length\r\n        // Modifies .trim() polyfill at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim\r\n        const backup = line.replace(/^[rR]+|[rR]+$/g, '');\r\n        // If r or R were present, there's multiple rows per beat\r\n        if (backup !== line) {\r\n            return Helpers.stringToFloat(line) / rowsPerBeat;\r\n        }\r\n        return Helpers.stringToFloat(line);\r\n    }\r\n\r\n    /**\r\n     * Process the different tokens we have available to get NoteData.\r\n     * @param stepsType The current StepsType.\r\n     * @param description The description of the chart.\r\n     * @param difficulty The difficulty (in words) of the chart.\r\n     * @param meter the difficulty (in numbers) of the chart.\r\n     * @param radarValues the calculated radar values.\r\n     * @param noteData the note data itself.\r\n     * @returns the Steps with parsed note data.\r\n     */\r\n    public static loadFromTokens(\r\n        stepsType: string,\r\n        description: string,\r\n        difficulty: string,\r\n        meter: string,\r\n        noteData: string,\r\n        song: Song,\r\n    ): Steps {\r\n        const steps = new Steps(noteData, song);\r\n\r\n        // Backwards compatibility hacks\r\n        switch (stepsType) {\r\n            case 'ez2-single-hard':\r\n                stepsType = 'ez2-single';\r\n                break;\r\n            case 'para':\r\n                stepsType = 'para-single';\r\n                break;\r\n        }\r\n\r\n        // TODO: string to steps type\r\n        steps.stepsType = Helpers.stringToStepsType(stepsType);\r\n        steps.stepsTypeName = stepsType;\r\n        steps.description = description;\r\n        steps.credit = description; // This is often used for both\r\n        steps.chartName = description; // One more for good measure\r\n        steps.difficulty = Helpers.oldStyleStringToDifficulty(difficulty);\r\n\r\n        // Handle hacks that originated back when StepMania didn't have\r\n        // Difficulty_Challenge. (At least v1.64, possibly v3.0 final...)\r\n        if (steps.difficulty === Difficulty.Hard) {\r\n            if (description === 'smaniac' || description === 'challenge') {\r\n                steps.difficulty = Difficulty.Challenge;\r\n            }\r\n        }\r\n        if (steps.difficulty === Difficulty.Invalid) {\r\n            steps.difficulty = Difficulty.Edit;\r\n        }\r\n        if (meter.length === 0) {\r\n            meter = '1';\r\n        }\r\n        steps.meter = Helpers.stringToInt(meter);\r\n\r\n        steps.tidyUpData();\r\n\r\n        return steps;\r\n    }\r\n\r\n    /**\r\n     * Parse BPM Changes data from a string.\r\n     * @param line the string in question.\r\n     * @param rowsPerBeat the number of rows per beat for this purpose.\r\n     * @returns a SongTimingInfo containing the data.\r\n     */\r\n    public static parseBpms(line: string, rowsPerBeat: number = -1): SongTimingInfo {\r\n        const songBpmInfo: SongTimingInfo = [];\r\n\r\n        const bpmChangeExpressions = line.split(',');\r\n        for (const expression of bpmChangeExpressions) {\r\n            const arrayBpmChangeValues = expression.split('=');\r\n            if (arrayBpmChangeValues.length !== 2) {\r\n                console.error(`.sm data has invalid #BPMs value \"${expression}\" (must have exactly one \"=\"), ignored`);\r\n                continue;\r\n            }\r\n\r\n            const beat = this.rowToBeat(arrayBpmChangeValues[0], rowsPerBeat);\r\n            const newBpm = Helpers.stringToFloat(arrayBpmChangeValues[1]);\r\n            if (newBpm === 0) {\r\n                console.error(`.sm file has a 0 BPM; ignored`);\r\n                continue;\r\n            }\r\n            songBpmInfo.push([beat, newBpm]);\r\n        }\r\n        return songBpmInfo;\r\n    }\r\n\r\n    /**\r\n     * Parse Stops data from a string.\r\n     * @param line the string in question.\r\n     * @param rowsPerBeat the number of rows per beat for this purpose.\r\n     * @returns a SongTimingInfo containing the data.\r\n     */\r\n    public static parseStops(line: string, rowsPerBeat: number = -1): SongTimingInfo {\r\n        const songStopInfo = [];\r\n\r\n        const arrayFreezeExpressions = line.split(',');\r\n        for (const expression of arrayFreezeExpressions) {\r\n            const arrayFreezeValues = expression.split('=');\r\n            if (arrayFreezeValues.length !== 2) {\r\n                console.error(`.sm data has invalid #STOPS value \"${expression}\" (must have exactly one \"=\"), ignored`);\r\n                continue;\r\n            }\r\n\r\n            const freezeBeat = this.rowToBeat(arrayFreezeValues[0], rowsPerBeat);\r\n            const freezeSeconds = Helpers.stringToFloat(arrayFreezeValues[1]);\r\n            if (freezeSeconds === 0) {\r\n                console.error(`.sm file has a zero-length stop; ignored`);\r\n                continue;\r\n            }\r\n            songStopInfo.push([freezeBeat, freezeSeconds]);\r\n        }\r\n        return songStopInfo;\r\n    }\r\n\r\n    /**\r\n     * Process the Delay Segments from the string.\r\n     * @param out the TimingData being modified.\r\n     * @param line the string in question.\r\n     * @param rowsPerBeat the number of rows per beat for this purpose.\r\n     */\r\n    public static processDelays(out: TimingData, line: string, rowsPerBeat: number = -1): void {\r\n        const arrayDelayExpressions = line.split(',');\r\n        for (const expression of arrayDelayExpressions) {\r\n            const arrayDelayValues = expression.split('=');\r\n            if (arrayDelayValues.length !== 2) {\r\n// tslint:disable-next-line: max-line-length\r\n                console.error(`.sm data has invalid #DELAYS value \"${expression}\" (must have exactly one \"=\"), ignored`);\r\n                continue;\r\n            }\r\n\r\n            const freezeBeat = this.rowToBeat(arrayDelayValues[0], rowsPerBeat);\r\n            const freezeSeconds = Helpers.stringToFloat(arrayDelayValues[1]);\r\n            if (freezeSeconds <= 0) {\r\n                console.error(`.sm file has an invalid dealy at beat ${freezeBeat}, length ${freezeSeconds}}; ignored`);\r\n                continue;\r\n            }\r\n            out.addSegment(new DelaySegment(NoteHelpers.beatToNoteRow(freezeBeat), freezeSeconds));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the Time Signature Segments from the string.\r\n     * @param out the TimingData being modified.\r\n     * @param line the string in question.\r\n     * @param rowsPerBeat the number of rows per beat for this purpose.\r\n     */\r\n    public static processTimeSignatures(out: TimingData, line: string, rowsPerBeat: number = -1): void {\r\n        const vs1 = line.split(',');\r\n        for (const s1 of vs1) {\r\n            const vs2 = s1.split('=');\r\n            if (vs2.length < 3) {\r\n                console.error(`.sm data has invalid time signature change with ${vs2.length} values, ignored`);\r\n                continue;\r\n            }\r\n\r\n            const beat = this.rowToBeat(vs2[0], rowsPerBeat);\r\n            const numerator = Helpers.stringToInt(vs2[1]);\r\n            const denominator = Helpers.stringToInt(vs2[2]);\r\n\r\n            if (beat < 0) {\r\n                console.error(`.sm data has invalid time signature change with beat ${beat}, ignored`);\r\n                continue;\r\n            }\r\n            if (numerator < 1) {\r\n// tslint:disable-next-line: max-line-length\r\n                console.error(`.sm data has invalid time signature change with beat ${beat}, numerator ${numerator}, ignored`);\r\n                continue;\r\n            }\r\n            if (denominator < 1) {\r\n// tslint:disable-next-line: max-line-length\r\n                console.error(`.sm data has invalid time signature change with beat ${beat}, denominator ${denominator}, ignored`);\r\n                continue;\r\n            }\r\n\r\n            out.addSegment(new TimeSignatureSegment(NoteHelpers.beatToNoteRow(beat), numerator, denominator));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the Tickcount Segments from the string.\r\n     * @param out the TimingData being modified.\r\n     * @param line the string in question.\r\n     * @param rowsPerBeat the number of rows per beat for this purpose.\r\n     */\r\n    public static processTickcounts(out: TimingData, line: string, rowsPerBeat: number = -1): void {\r\n        const arrayTickcountExpressions = line.split(',');\r\n        for (const expression of arrayTickcountExpressions) {\r\n            const arrayTickcountValues = expression.split('=');\r\n            if (arrayTickcountValues.length !== 2) {\r\n// tslint:disable-next-line: max-line-length\r\n                console.error(`.sm data has invalid #TICKCOUNTS value \"${expression}\" (must have exactly one \"=\"), ignored`);\r\n                continue;\r\n            }\r\n\r\n            const tickcountBeat = this.rowToBeat(arrayTickcountValues[0], rowsPerBeat);\r\n            // TODO: emulate try/catch stuff\r\n            // This parseInt is intended, as the source code used it and not the helper function here\r\n            const ticks = parseInt(arrayTickcountValues[1], 10);\r\n            if (isNaN(ticks)) {\r\n                continue;\r\n            }\r\n            const clampedTicks = Helpers.clamp(ticks, 0, ROWS_PER_BEAT);\r\n            out.addSegment(new TickcountSegment(NoteHelpers.beatToNoteRow(tickcountBeat), ticks));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process BPM and stop segments from the data.\r\n     * @param out the TimingData being modified.\r\n     * @param vBPMs the vector of BPM changes.\r\n     * @param vStops the vector of stops.\r\n     */\r\n    public static processBpmsAndStops(out: TimingData, bpms: SongTimingInfo, stops: SongTimingInfo): void {\r\n        // Precondition: no BPM change or stop has 0 for its value (change.second).\r\n        //     (The ParseBPMs and ParseStops functions make sure of this.)\r\n        // Postcondition: all BPM changes, stops, and warps are added to the out\r\n        //     parameter, already sorted by beat.\r\n        // REMOVEME: Iterator declarations\r\n        // Current BPM (positive or negative)\r\n        let bpm = 0;\r\n        // Beat at which the previous timing change occurred\r\n        let prevbeat = 0;\r\n        // Start/end of current warp (-1 if not currently warping)\r\n        let warpstart = -1;\r\n        let warpend = -1;\r\n        // BPM prior to current warp, to detect if it has changed\r\n        let prewarpbpm = 0;\r\n        // How far off we have gotten due to negative changes\r\n        let timeofs = 0;\r\n\r\n        // Sort BPM changes and stops by beat. Order matters.\r\n        // TODO(StepMania): Make sorted lists a precondition rather than sorting them here.\r\n        // The caller may know that the lists are sorted already (e.g. if\r\n        // loaded from cache).\r\n        // It's a list of pairs so we sort by the first value (beat).\r\n        const compareFirst = (a: { [key: number]: number }, b: { [key: number]: number }): number => a[0] - b[0];\r\n        bpms.sort(compareFirst);\r\n        stops.sort(compareFirst);\r\n\r\n        // NOTE: the following code was done with iterators in C++. This is my ugly interpretation.\r\n        // TODO: once the tests are working change this to be more JavaScript-ey\r\n\r\n        // Convert stops that come before beat 0.  All these really do is affect\r\n        // where the arrows are with respect to the music, i.e. the song offset.\r\n        // Positive stops subtract from the offset, and negative add to it.\r\n        let stopIndex = 0;\r\n        const stopMax = stops.length;\r\n        for (const stopPair of stops) {\r\n            if (stopPair[0] >= 0) {\r\n                break;\r\n            }\r\n            out.adjustOffset(-stopPair[1]);\r\n            stopIndex++;\r\n        }\r\n\r\n        // Get rid of BPM changes that come before beat 0.  Positive BPMs before\r\n        // the chart don't really do anything, so we just ignore them.  Negative\r\n        // BPMs cause unpredictable behavior, so ignore them as well and issue a\r\n        // warning.\r\n        let bpmIndex = 0;\r\n        const bpmMax = bpms.length;\r\n        for (const bpmPair of bpms) {\r\n            if (bpmPair[0] >= 0) {\r\n                break;\r\n            }\r\n            bpm = bpmPair[1];\r\n            if (bpm < 0 && bpmPair[1] < 0) {\r\n                console.debug('.sm data has a negative BPM prior to beat 0. These cause problems; ignoring.');\r\n            }\r\n            bpmIndex++; // Keep track of where we got to in negative bpms\r\n        }\r\n\r\n        // It's beat 0.  Do you know where your BPMs are?\r\n        if (bpm === 0) {\r\n            // Nope.  Can we just use the next BPM value?\r\n            if (bpmIndex === bpmMax) {\r\n                // Nope.\r\n                bpm = 60;\r\n                console.debug('.sm data has no valid BPMs. Defaulting to 60.');\r\n            } else {\r\n                // Yep. Get the next BPM.\r\n                bpm = bpms[bpmIndex][1];\r\n                bpmIndex++;\r\n                console.debug('.sm data does not establish a BPM before beat 0. ' +\r\n                              'Using the value from the next BPM change');\r\n            }\r\n        }\r\n        // We always want to have an initial BPM.  If we start out warping, this\r\n        // BPM will be added later.  If we start with a regular BPM, add it now.\r\n        if (bpm > 0 && bpm <= FAST_BPM_WARP) {\r\n            out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(0), bpm));\r\n        }\r\n\r\n        // Iterate over all BPMs and stops in tandem\r\n        while (bpmIndex < bpmMax || stopIndex < stopMax) {\r\n            // Get the next change in order, with BPMs taking precedence\r\n            // when they fall on the same beat.\r\n            const changeIsBpm = (stopIndex === stopMax) ||\r\n                (bpmIndex < bpmMax && bpms[bpmIndex][0] <= stops[stopIndex][0]);\r\n            const change = changeIsBpm ? bpms[bpmIndex] : stops[stopIndex];\r\n\r\n            // Calculate the effects of time at the current BPM.  \"Infinite\"\r\n            // BPMs (SM4 warps) imply that zero time passes, so skip this\r\n            // step in that case.\r\n            if (bpm <= FAST_BPM_WARP) {\r\n                timeofs += (change[0] - prevbeat) * 60 / bpm;\r\n\r\n                // If we were in a warp and it finished during this\r\n                // timeframe, create the warp segment.\r\n                if (warpstart >= 0 && bpm > 0 && timeofs > 0) {\r\n                    // timeofs represents how far past the end we are\r\n                    warpend = change[0] - (timeofs * bpm / 60);\r\n                    // warpend and warpstart are floats in the StepMania code, use appropriate constructor\r\n                    out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\r\n                        warpend - warpstart, false));\r\n\r\n                    // If the BPM changed during the warp, put that\r\n                    // change at the beginning of the warp.\r\n                    if (bpm !== prewarpbpm) {\r\n                        out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(warpstart), bpm));\r\n                    }\r\n                    // No longer warping\r\n                    warpstart = -1;\r\n                }\r\n            }\r\n\r\n            // Save the current beat for the next round of calculations\r\n            prevbeat = change[0];\r\n\r\n            // Now handle the timing changes themselves\r\n            if (changeIsBpm) {\r\n                // Does this BPM change start a new warp?\r\n                if (warpstart < 0 && (change[1] < 0 || change[1] > FAST_BPM_WARP)) {\r\n                    // Yes.\r\n                    warpstart = change[0];\r\n                    prewarpbpm = bpm;\r\n                    timeofs = 0;\r\n                } else if (warpstart < 0) {\r\n                    // No, and we aren't currently warping either.\r\n                    // Just a normal BPM change.\r\n                    out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(change[0]), change[1]));\r\n                }\r\n                bpm = change[1];\r\n                bpmIndex++;\r\n            } else {\r\n                // Does this stop start a new warp?\r\n                if (warpstart < 0 && change[1] < 0) {\r\n                    // Yes.\r\n                    warpstart = change[0];\r\n                    prewarpbpm = bpm;\r\n                    timeofs = change[1];\r\n                } else if (warpstart < 0) {\r\n                    // No, and we aren't currently warping either.\r\n                    // Just a normal stop.\r\n                    out.addSegment(new StopSegment(NoteHelpers.beatToNoteRow(change[0]), change[1]));\r\n                } else {\r\n                    // We're warping already. Stops affect the time\r\n                    // offset directly.\r\n                    timeofs += change[1];\r\n\r\n                    // If a stop overcompensates for the time\r\n                    // deficit, the warp ends and we stop for the\r\n                    // amount it goes over.\r\n                    if (change[1] > 0 && timeofs > 0) {\r\n                        warpend = change[0];\r\n                        // warpend and warpstart are floats in the StepMania code, use appropriate constructor\r\n                        out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\r\n                            warpend - warpstart, false));\r\n                        out.addSegment(new StopSegment(NoteHelpers.beatToNoteRow(change[0]), timeofs));\r\n\r\n                        // Now, are we still warping because of\r\n                        // the BPM value?\r\n                        if (bpm < 0 || bpm > FAST_BPM_WARP) {\r\n                            // Yep.\r\n                            warpstart = change[0];\r\n                            // prewarpbpm remains the same\r\n                            timeofs = 0;\r\n                        } else {\r\n                            // Nope, warp is done.  Add any\r\n                            // BPM change that happened in\r\n                            // the meantime.\r\n                            if (bpm !== prewarpbpm) {\r\n                                // bpm is a float in the StepMania code, use appropriate constructor\r\n                                out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart), bpm, false));\r\n                            }\r\n                            warpstart = -1;\r\n                        }\r\n                    }\r\n                }\r\n                stopIndex++;\r\n            }\r\n        }\r\n\r\n        // If we are still warping, we now have to consider the time remaining\r\n        // after the last timing change.\r\n        if (warpstart >= 0) {\r\n            // Will this warp ever end?\r\n            if (bpm < 0 || bpm > FAST_BPM_WARP) {\r\n                // No, so it ends the entire chart immediately.\r\n                // XXX There must be a less hacky and more accurate way\r\n                // to do this.\r\n                warpend = 99999999;\r\n            } else {\r\n                // Yes. Figure out when it will end.\r\n                warpend = prevbeat - (timeofs * bpm / 60);\r\n            }\r\n            // warpend and warpstart are floats in the StepMania code, use appropriate constructor\r\n            out.addSegment(new WarpSegment(NoteHelpers.beatToNoteRow(warpstart),\r\n                 warpend - warpstart, false));\r\n\r\n            // As usual, record any BPM change that happened during the warp\r\n            if (bpm !== prewarpbpm) {\r\n                out.addSegment(new BPMSegment(NoteHelpers.beatToNoteRow(warpstart), bpm));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempt to load the specified sm data.\r\n     * @param msdFile: an MsdFile with the parsed fields for the data.\r\n     * @return a Song that has the song information.\r\n     */\r\n    public static loadFromSimfile(msdFile: MsdFile): Song {\r\n        const song = new Song();\r\n\r\n        const reusedSongInfo: SongTagInfo = {\r\n            song,\r\n            params: [],\r\n            bpmChanges: [],\r\n            stops: [],\r\n        };\r\n\r\n        for (let i = 0; i < msdFile.getNumValues(); i++) {\r\n            const numParams = msdFile.getNumParams(i);\r\n            const params = msdFile.getValue(i);\r\n            const valueName = params[0].toUpperCase();\r\n            reusedSongInfo.params = params; // Ensure we're passing params in\r\n\r\n            const handler = songTagHandlers.get(valueName);\r\n            if (handler !== undefined) {\r\n                handler(reusedSongInfo);\r\n                // We ignore #BGCHANGES.* because we don't care about backgrounds\r\n            } else if (valueName === 'NOTES' || valueName === 'NOTES2') {\r\n                if (numParams < 7) {\r\n                    throw new Error(`.sm file has ${numParams} fields in a #NOTES tag, but should have at least 7.`);\r\n                }\r\n\r\n                const steps = this.loadFromTokens(\r\n                    params[1],\r\n                    params[2],\r\n                    params[3],\r\n                    params[4],\r\n                    params[6],\r\n                    song,\r\n                );\r\n                steps.decompress();\r\n                song.addSteps(steps);\r\n            }\r\n        }\r\n        if (!song.hasSteps()) {\r\n            throw new Error('did not find step data for song');\r\n        }\r\n\r\n        // Turn negative time changes into warps\r\n        this.processBpmsAndStops(song.songTiming, reusedSongInfo.bpmChanges, reusedSongInfo.stops);\r\n\r\n        // Do a cascade through all our data structures to tidy up any edge cases or\r\n        // backwards compatibility issues that exist.\r\n        this.tidyUpData();\r\n        // In StepMania this is only called when adding the song to the cache.\r\n        // We have no cache so do it here. -Struz\r\n        song.tidyUpData();\r\n\r\n        // IMPORTANT: write my own cascade of tidyUpData() functions and call them here\r\n        // Cut out any things that aren't necessary.\r\n        // Line 633 in Song.cpp is the motherload.\r\n        // Read this file carefully! It has gems like not allowing multiple steps of the same StepsType and Difficulty.\r\n\r\n        return song;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the relevant notedata from the simfile.\r\n     * @param msdFile the .sm file data.\r\n     * @returns the Steps we loaded the data into.\r\n     */\r\n    // NOTE: commented out because currently unused\r\n    // public static loadNoteDataFromSimfile(msdFile: MsdFile): Steps {\r\n    //     for (let i = 0; i < msdFile.getNumValues(); i++) {\r\n    //         const numParams = msdFile.getNumParams(i);\r\n    //         const params = msdFile.getValue(i);\r\n    //         const valueName = params[0].toUpperCase();\r\n\r\n    //         // The only tag we care about is the #NOTES tag.\r\n    //         if (valueName === 'NOTES' || valueName === 'NOTES2') {\r\n    //             if (numParams < 7) {\r\n    //                 throw new Error(`.sm file has ${numParams} fields in a #NOTES tag, but should have at least 7.`);\r\n    //             }\r\n\r\n    //             const stepsType: string = params[1].trim();\r\n    //             const description: string = params[2].trim();\r\n    //             let difficulty: string = params[3].trim();\r\n\r\n    //             // Hack - if this is a .edit file, fudge the difficulty\r\n    //             // TODO: we have no way to know this given the data pasted in,\r\n    //             // but StepMania does it by the .edit extension\r\n\r\n    //             // Old version difficulty changes\r\n    //             if (difficulty === 'smaniac') {\r\n    //                 difficulty = 'Challenge';\r\n    //             }\r\n    //             if (difficulty === 'hard') {\r\n    //                 if (description === 'smaniac' || description === 'challenge') {\r\n    //                     difficulty = 'Challenge';\r\n    //                 }\r\n    //             }\r\n\r\n    //             // OMITTED: if the stepsType, description, and difficulty match, don't load the\r\n    //             // data. Probably for performance reasons.\r\n\r\n\r\n    //             const noteData: string = params[6].trim();\r\n    //             const steps = new Steps(noteData);\r\n    //             steps.decompress();\r\n    //             steps.tidyUpData();\r\n    //             return steps;\r\n    //         }\r\n    //     }\r\n    //     throw new Error('could not find note data');\r\n    // }\r\n\r\n    /**\r\n     * @brief Perform some cleanup on the loaded song.\r\n     * @param song a reference to the song that may need cleaning up.\r\n     */\r\n    public static tidyUpData() {\r\n        // IGNORED: a bunch of background changes. First cut isn't going to support background / foreground gimmicks.\r\n        // IGNORED: we never load from cache so we shouldn't have to call song.tidyUpData() here\r\n    }\r\n}\r\nexport default NoteLoaderSM;\r\n","// The class that reads the various .SSC and .SM files\r\n\r\nexport class MsdFile {\r\n    // Each value has multiple parameters\r\n    private values: string[][] = [];\r\n\r\n    constructor(data: string) {\r\n        this.readBuffer(data, true);\r\n    }\r\n\r\n    // Get a param by index\r\n    public getParam(valueIndex: number, paramIndex: number): string {\r\n        return this.values[valueIndex][paramIndex];\r\n    }\r\n\r\n    // Get a value by index\r\n    public getValue(valueIndex: number) {\r\n        return this.values[valueIndex];\r\n    }\r\n\r\n    public getNumValues() {\r\n        return this.values.length;\r\n    }\r\n\r\n    public getNumParams(valueIndex: number) {\r\n        return this.values[valueIndex].length;\r\n    }\r\n\r\n    // Transcribed from StepMania source code to ensure it was done right\r\n    // This could definitely be done in a more \"JavaScript-ey\" way\r\n    private readBuffer(buf: string, unescape: boolean): void {\r\n        let readingValue: boolean = false;\r\n        let i: number = 0;\r\n        let currentParam: string[] = [];\r\n\r\n        while (i < buf.length) {\r\n            // Detect and skip comments - from // onwards in a line\r\n            if (i + 1 < buf.length && buf[i] === '/' && buf[i + 1] === '//') {\r\n                do {\r\n                    i++;\r\n                }\r\n                while (i < buf.length && buf[i] !== '\\n');\r\n                continue;\r\n            }\r\n\r\n            // TODO: files missing ';'s\r\n            // stretch goal\r\n\r\n            // Start reading a new value\r\n            if (!readingValue && buf[i] === '#') {\r\n                this.addValue();\r\n                readingValue = true;\r\n            }\r\n\r\n            if (!readingValue) {\r\n                if (unescape && buf[i] === '\\\\') {\r\n                    i += 2;\r\n                } else {\r\n                    ++i;\r\n                }\r\n                continue; // Nothing else is meaningful outside of a value\r\n            }\r\n\r\n            // : and ; end the current param, if any\r\n            // NOTE: the C++ code has an extra `iProcessedLen != -1` guard which we have removed\r\n            if (buf[i] === ':' || buf[i] === ';') {\r\n                this.addParam(currentParam);\r\n            }\r\n\r\n            // # and : begin new params\r\n            if (buf[i] === '#' || buf[i] === ':') {\r\n                ++i;\r\n                currentParam = [];\r\n                continue;\r\n            }\r\n\r\n            // ; ends the current value\r\n            if (buf[i] === ';') {\r\n                readingValue = false;\r\n                ++i;\r\n                continue;\r\n            }\r\n\r\n            // We've gone through all the control characters.\r\n            // All that is left is either an escaped character,\r\n            // ie \\#, \\\\, \\:, etc., or a regular character.\r\n            if (unescape && i < buf.length && buf[i] === '\\\\') {\r\n                ++i;\r\n            }\r\n            if (i < buf.length) {\r\n                currentParam.push(buf[i++]);\r\n            }\r\n        }\r\n\r\n        // Add any unterminated value at the end\r\n        if (readingValue) {\r\n            this.addParam(currentParam);\r\n        }\r\n    }\r\n\r\n    // Add a parameter to the last added value\r\n    private addParam(param: string[]): void {\r\n        this.values[this.values.length - 1].push( param.join('').trim() );\r\n    }\r\n\r\n    // Add a new value\r\n    private addValue(): void {\r\n        this.values.push([]);\r\n    }\r\n}\r\nexport default MsdFile;\r\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\nimport Vue from 'vue';\r\nimport { Component } from 'vue-property-decorator';\r\nimport axios from 'axios';\r\nimport { Pack, ChartURLs, Chart } from '@/lib/ChartPicker';\r\nimport Steps from '@/lib/Steps';\r\nimport Song from '@/lib/Song';\r\nimport FileOperations from '@/lib/FileOperations';\r\nimport NoteLoaderSM from '@/lib/NoteLoaderSM';\r\nimport GAMESTATE from '@/lib/GameState';\r\nimport MsdFile from '@/lib/MsdFile';\r\n\r\n// This can be overridden with the process.env.VUE_APP_PACK_URL_PREFIX environment variable\r\nconst DEFAULT_PACK_URL_PREFIX = 'https://s3-us-west-2.amazonaws.com/struz.simfile-viewer/';\r\n\r\nconst PACK_PATH_PREFIX = process.env.VUE_APP_PACK_URL_PREFIX || DEFAULT_PACK_URL_PREFIX;\r\nconst PACK_INDEX_FILENAME = process.env.VUE_APP_PACK_INDEX_FILENAME || 'packs.json';\r\nconst DEFAULT_SELECTED_CHART = {name: '<Select a chart>', oggFilename: '', simFilename: ''};\r\n\r\ninterface StepsItem {\r\n  index: number; // Since we can't have the value as an object\r\n  steps: Steps;\r\n}\r\n// Actually text should be the name of the edit / difficulty slot\r\n// .steps.meter - .steps.description, ordered by .index\r\n\r\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\r\n@Component\r\nclass ChartPicker extends Vue {\r\n  public selectedPack = 'Loading';\r\n  public packs: Pack[] = [\r\n    {\r\n      name: 'Loading',\r\n      charts: [],\r\n    },\r\n  ];\r\n\r\n  public selectedChart = 'Loading';\r\n  public charts: Chart[] = [\r\n    {\r\n      name: 'Loading',\r\n      oggFilename: 'Loading',\r\n      simFilename: 'Loading',\r\n    },\r\n  ];\r\n\r\n  public selectedSteps: number = -1;\r\n  public steps: Steps[] = [];\r\n\r\n  public provide() {\r\n    return {};\r\n  }\r\n\r\n  public mounted() {\r\n    // Fetch and return the pack data\r\n    axios.get(`${process.env.BASE_URL}${PACK_INDEX_FILENAME}`).then((response) => {\r\n      this.packs = response.data;\r\n      // Insert default/dummy charts\r\n      this.packs.forEach((pack) => {\r\n        pack.charts.unshift(DEFAULT_SELECTED_CHART);\r\n      });\r\n      // Set default pack\r\n      this.selectedPack = this.packs[0].name;\r\n      // Set default chart from default pack\r\n      this.charts = this.packs[0].charts;\r\n      this.selectedChart = DEFAULT_SELECTED_CHART.name;\r\n    }).catch((error) => {\r\n      console.error(`failed to get pack info from url: ${error}`);\r\n    });\r\n  }\r\n\r\n  private findPack(name: string): Pack {\r\n    const foundPack = this.packs.find((pack) => pack.name === name);\r\n    if (foundPack === undefined) {\r\n      throw new Error(`Could not find pack with name ${name}`);\r\n    }\r\n    return foundPack;\r\n  }\r\n\r\n  private findChart(name: string): Chart {\r\n    const foundChart = this.charts.find((chart) => chart.name === name);\r\n    if (foundChart === undefined) {\r\n      throw new Error(`Could not find chart with name ${name}`);\r\n    }\r\n    return foundChart;\r\n  }\r\n\r\n  private changePackEvent(event: any) {\r\n    this.charts = this.findPack(this.selectedPack).charts;\r\n    this.selectedChart = this.charts[0].name;\r\n  }\r\n\r\n  private changeChartEvent(event: any) {\r\n    const packName = this.selectedPack;\r\n    const chart = this.findChart(this.selectedChart);\r\n\r\n    if (chart === DEFAULT_SELECTED_CHART) { return; } // nothing to load\r\n\r\n    const ogg = chart.oggFilename === null ? null :\r\n      `${encodeURIComponent(packName)}/${encodeURIComponent(chart.name)}/` +\r\n      `${encodeURIComponent(chart.oggFilename)}`;\r\n    const simFile = `${encodeURIComponent(packName)}/${encodeURIComponent(chart.name)}` +\r\n                    `/${encodeURIComponent(chart.simFilename)}`;\r\n    const urls: ChartURLs = {ogg, simFile};\r\n    this.changeChart(urls);\r\n    // Emit an event for any other components that might want to do something\r\n    this.$emit('changeChart', urls);\r\n  }\r\n\r\n  private changeStepsEvent(event: any) {\r\n    const stepsIndex = this.selectedSteps;\r\n\r\n    // const packName = this.selectedPack;\r\n    // const chart = this.findChart(this.selectedChart);\r\n\r\n    if (stepsIndex === null) { return; } // nothing to change\r\n    if (GAMESTATE.curSong === undefined) { return; }\r\n    // Find it again here in case we sort the model for display purposes\r\n    const steps = this.steps[stepsIndex];\r\n    GAMESTATE.selectedSteps = GAMESTATE.curSong.getAllSteps().indexOf(steps);\r\n    // Emit an event for any other components that might want to do something\r\n    this.$emit('changeSteps', steps);\r\n  }\r\n\r\n  private getStepsItemText(item: Steps) {\r\n    return `${item.meter} - ${item.description}`;\r\n  }\r\n  private getStepsItemValue(item: Steps) { return this.steps.indexOf(item); }\r\n\r\n  /**\r\n   * Handle loading a new chart based on the provided URL for an ogg and .sm file.\r\n   * @param urls the relevant URLs to load the chart.\r\n   */\r\n  private changeChart(urls: ChartURLs) {\r\n    if (urls.ogg === null) { throw new Error('no ogg not supported yet!'); }\r\n\r\n    let newSong: Song | null;\r\n    const absoluteSimURI = `${PACK_PATH_PREFIX}packs/${urls.simFile}`;\r\n    const p1 = FileOperations.loadTextFile(absoluteSimURI)\r\n      .then((smText) => {\r\n        const msdFile = new MsdFile(smText);\r\n        newSong = NoteLoaderSM.loadFromSimfile(msdFile);\r\n        console.log('loaded sm data');\r\n\r\n        // Add it to our model\r\n        this.steps = newSong.getAllSteps();\r\n        this.selectedSteps = 0;\r\n      })\r\n      .catch((error) => {\r\n        console.error(`failed to load .sm file at '${absoluteSimURI}': ${error}`);\r\n      });\r\n\r\n    let newHowl: Howl | null;\r\n    const absoluteHowlURI = `${PACK_PATH_PREFIX}packs/${urls.ogg}`;\r\n    const p2 = FileOperations.loadOggFileAsHowl(absoluteHowlURI, false)\r\n      .then((howl) => {\r\n        newHowl = howl;\r\n        console.log('loaded music');\r\n      })\r\n      .catch((error) => {\r\n        console.error(`failed to load .ogg file at '${absoluteHowlURI}': ${error}`);\r\n      });\r\n\r\n    // Once both parts have been loaded, tee up the new song\r\n    Promise.all([p1, p2])\r\n      .then(() => {\r\n        if (newSong === null) { throw new Error('song did not load properly'); }\r\n        if (newHowl === null) { throw new Error('howl did not load properly'); }\r\n        GAMESTATE.loadSong(newSong, newHowl, this.$data.seek);\r\n      })\r\n      .catch((error) => {\r\n        console.error(`failed to load song into game: ${error}`);\r\n      });\r\n    console.log('chart changed: ' +  urls.ogg);\r\n  }\r\n}\r\nexport default ChartPicker;\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ChartPicker.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/vuetify-loader/lib/loader.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ChartPicker.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ChartPicker.vue?vue&type=template&id=8bc634de&scoped=true&\"\nimport script from \"./ChartPicker.vue?vue&type=script&lang=ts&\"\nexport * from \"./ChartPicker.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"8bc634de\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!Z:/Code/itg/simfile-viewer/node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VSelect } from 'vuetify/lib'\ninstallComponents(component, {VSelect})\n","import NoteHelpers from './NoteTypes';\r\nimport GAMESTATE from './GameState';\r\nimport { FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE } from './NoteData';\r\nimport { Howl } from 'howler';\r\nimport clapOgg from '../assets/sounds/assist_clap.ogg';\r\n\r\nexport class RhythmAssist {\r\n    public static rowLastCrossed = -1;\r\n    public static clapSound = new Howl({\r\n        src: [clapOgg],\r\n        volume: 0.6,  // TODO: make this a setting\r\n    });\r\n\r\n    public static playTicks() {\r\n        const metronome = false;\r\n        const clap = true;\r\n\r\n        // TODO: make this player position rather than overall song position\r\n        // if things don't work properly\r\n        const position = GAMESTATE.position;\r\n        const positionSeconds = position.musicSeconds;\r\n\r\n        // This next line is for playing sounds early so they come out on time.\r\n        // Worry about that later. -Struz\r\n        // positionSeconds += SOUNDMAN->GetPlayLatency() + (float)CommonMetrics::TICK_EARLY_SECONDS + 0.250f;\r\n\r\n        const song = GAMESTATE.curSong;\r\n        if (song === undefined) { return; }\r\n        const timing = song.songTiming;\r\n        const nd = song.getSteps(GAMESTATE.selectedSteps).getNoteData();\r\n\r\n        // const timing = GAMESTATE.curSteps[0].timingData;  // TODO: use player number if ever applicable\r\n        const songBeat = timing.getBeatFromElapsedTimeNoOffset(positionSeconds);\r\n        const songRow = Math.max(0, NoteHelpers.beatToNoteRowNotRounded(songBeat));\r\n        if (songRow < RhythmAssist.rowLastCrossed) {\r\n            this.rowLastCrossed = songRow;\r\n        }\r\n\r\n        if (clap) {\r\n            let clapRow = -1;\r\n            // FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE\r\n            // IMPORTANT:\r\n            // for each index crossed since the last update\r\n            // TODO: reverse arguments to this function so it looks nicer when chaining in\r\n            const row = {value: 0};\r\n            FOREACH_NONEMPTY_ROW_ALL_TRACKS_RANGE(nd, row, this.rowLastCrossed + 1, songRow + 1, (r) => {\r\n                if (nd.isThereATapOrHoldHeadAtRow(r.value)) {\r\n                    clapRow = r.value;\r\n                }\r\n            });\r\n            if (clapRow !== -1 && timing.isJudgableAtRow(clapRow)) {\r\n                const tickBeat = NoteHelpers.noteRowToBeat(clapRow);\r\n                const tickSecond = timing.getElapsedTimeFromBeatNoOffset(tickBeat);\r\n                const secondsUntil = tickSecond - position.musicSeconds;\r\n                // TODO: if we implement music rate, /= secondsUntil by the music rate\r\n                // TODO: when playing the sound use the magic formulae to play in time\r\n                // console.log(`clap @ beat=${tickBeat}`);\r\n                this.clapSound.play();\r\n            }\r\n        }\r\n\r\n        if (metronome && this.rowLastCrossed !== -1) {\r\n            const lastCrossedMeasureIndex = {value: 0};\r\n            const lastCrossedBeatIndex = {value: 0};\r\n            const lastCrossedRowsRemainder = {value: 0};\r\n            timing.noteRowToMeasureAndBeat(RhythmAssist.rowLastCrossed, lastCrossedMeasureIndex,\r\n                lastCrossedBeatIndex, lastCrossedRowsRemainder);\r\n\r\n            const currentMeasureIndex = {value: 0};\r\n            const currentBeatIndex = {value: 0};\r\n            const currentRowsRemainder = {value: 0};\r\n            timing.noteRowToMeasureAndBeat(songRow, currentMeasureIndex,\r\n                currentBeatIndex, currentRowsRemainder);\r\n\r\n            let metronomeRow = -1;\r\n            let changedMeasure = false;\r\n\r\n            // If we crossed a measure or a beat, we need to make the metronome sound\r\n            if (lastCrossedMeasureIndex.value !== currentMeasureIndex.value ||\r\n                lastCrossedBeatIndex.value !== currentBeatIndex.value) {\r\n                    metronomeRow = songRow - currentRowsRemainder.value;\r\n                    changedMeasure = currentMeasureIndex.value - lastCrossedMeasureIndex.value > 0;\r\n            }\r\n\r\n            if (metronomeRow !== -1) {\r\n                const tickBeat = NoteHelpers.noteRowToBeat(metronomeRow);\r\n                const tickSecond = timing.getElapsedTimeFromBeatNoOffset(tickBeat);\r\n                const secondsUntil = tickSecond - position.musicSeconds;\r\n                // TODO: if we implement music rate, /= secondsUntil by the music rate\r\n\r\n                // TODO: synchronisation / \"play at time\"\r\n                if (changedMeasure) {\r\n                    console.log('metronome measure');\r\n                } else {\r\n                    console.log('metronome beat');\r\n                }\r\n            }\r\n        }\r\n        RhythmAssist.rowLastCrossed = songRow;\r\n    }\r\n}\r\nexport default RhythmAssist;\r\n","import GameTimer from './GameTimer';\r\nimport SOUNDMAN from './GameSoundManager';\r\nimport GAMESTATE from './GameState';\r\nimport RhythmAssist from './RhythmAssist';\r\nimport SCREENMAN from './ScreenManager';\r\nimport ENTITYMAN from './entities/EntityManager';\r\n\r\nexport const gGameplayTimer = new GameTimer();\r\n\r\n/** Main rendering and update loop. */\r\nclass GameLoop {\r\n    public static drawnArrow = false;\r\n    public static drawnFrames = 0;\r\n    public static totalTime = 0;\r\n    public static gameLoop(outsideDeltaTime: number) {\r\n        // TODO: do some comparisons to work out which is better\r\n        // Seems like our deltaTime is more realistic. Theirs caps at 6 (100ms) due to minFPS?\r\n        // We don't actually have a minFPS - will this be a problem? -Struz\r\n        // For sound stuff our clock is better as it will give the real time elapsed (or closer to).\r\n        GameLoop.drawnFrames++;\r\n        const deltaTime = gGameplayTimer.getDeltaTime();\r\n        GameLoop.totalTime += deltaTime;\r\n        if (GameLoop.totalTime > 1) {\r\n            GameLoop.totalTime = 0;\r\n            GameLoop.drawnFrames = 0;\r\n        }\r\n\r\n        // Update SOUNDMAN early (before any RageSound::GetPosition calls), to flush position data.\r\n        SOUNDMAN.update(deltaTime);\r\n\r\n        GAMESTATE.update(deltaTime);\r\n        RhythmAssist.playTicks();\r\n\r\n        if (SCREENMAN.isReadyToDraw() && !this.drawnArrow) {\r\n            // TODO: not sure where to put this\r\n            SCREENMAN.showReceptors();\r\n\r\n            this.drawnArrow = true;\r\n        }\r\n\r\n        ENTITYMAN.update(deltaTime);\r\n\r\n        // TODO: process input if we get that far\r\n        // TODO: draw screen based on state\r\n    }\r\n}\r\nexport default GameLoop;\r\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\nimport Vue from 'vue';\r\nimport { Component } from 'vue-property-decorator';\r\n\r\nimport Screen from './components/Screen.vue';\r\nimport ChartPicker from './components/ChartPicker.vue';\r\n\r\nimport { Howl } from 'howler';\r\nimport GameLoop from './lib/GameLoop';\r\nimport SCREENMAN from '@/lib/ScreenManager.ts';\r\nimport SOUNDMAN from './lib/GameSoundManager';\r\nimport GAMESTATE from './lib/GameState';\r\nimport { DebugTools } from './lib/Debug';\r\n\r\n// Register our main loop as soon as the page loads\r\n// TODO: work out why this is so much better for syncing claps\r\n// than the pixi ticker. It may just be that we want the audio\r\n// loops way faster than screen draws.\r\n// NOTE: very well might have been placebo from the two tries.\r\n// Had the best sync ever with the ticker. I think what happened\r\n// was that I didn't wait for the ticker to warm up - pressing test\r\n// too early on page load fucks the syncing.\r\n(() => {\r\n  function main() {\r\n    const stopMain = window.requestAnimationFrame( main );\r\n\r\n    // Your main loop contents\r\n    GameLoop.gameLoop(0);\r\n  }\r\n\r\n  main(); // Start the cycle\r\n})();\r\n\r\ndeclare global {\r\n  interface Window {\r\n    debugTools: any;\r\n    noteField: any;\r\n    GAMESTATE: any;\r\n    SOUNDMAN: any;\r\n  }\r\n}\r\n// For live debugging\r\nwindow.debugTools = DebugTools;\r\nwindow.GAMESTATE = GAMESTATE;\r\nwindow.SOUNDMAN = SOUNDMAN;\r\n\r\n// See https://vuejs.org/v2/guide/typescript.html for why we do the below\r\n@Component({\r\n  name: 'App',\r\n  components: {\r\n    Screen,\r\n    ChartPicker,\r\n  },\r\n})\r\nclass App extends Vue {\r\n  public seek = 0;\r\n\r\n  public seekTrack() {\r\n    SOUNDMAN.musicSeek(this.$data.seek);\r\n  }\r\n\r\n  public playPauseTrack() {\r\n    if (!GAMESTATE.isPaused()) {\r\n      GAMESTATE.pause();\r\n      SOUNDMAN.pauseMusic();\r\n    } else {\r\n      GAMESTATE.play();\r\n      SOUNDMAN.resumeMusic();\r\n    }\r\n  }\r\n}\r\nexport default App;\r\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vuetify-loader/lib/loader.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vuetify-loader/lib/loader.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=8d3d7042&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!Z:/Code/itg/simfile-viewer/node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VApp } from 'vuetify/lib'\nimport { VBtn } from 'vuetify/lib'\nimport { VContainer } from 'vuetify/lib'\nimport { VContent } from 'vuetify/lib'\nimport { VFlex } from 'vuetify/lib'\nimport { VLayout } from 'vuetify/lib'\nimport { VSpacer } from 'vuetify/lib'\nimport { VTextField } from 'vuetify/lib'\nimport { VToolbar } from 'vuetify/lib'\nimport { VToolbarTitle } from 'vuetify/lib'\ninstallComponents(component, {VApp,VBtn,VContainer,VContent,VFlex,VLayout,VSpacer,VTextField,VToolbar,VToolbarTitle})\n","import Vue from 'vue';\r\nimport './plugins/vuetify';\r\nimport App from './App.vue';\r\n\r\nVue.config.productionTip = false;\r\n\r\nnew Vue({\r\n  render: (h) => h(App),\r\n}).$mount('#app');\r\n","module.exports = __webpack_public_path__ + \"media/assist_clap.131e5c1e.ogg\";"],"sourceRoot":""}